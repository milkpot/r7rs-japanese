\chapter{式}
\label{expressionchapter}

\newcommand{\syntax}{{\em Syntax: }}
\newcommand{\semantics}{{\em Semantics: }}

式型は{\em プリミティブ}または{\em 派生}に分類されます。
プリミティブ式型は変数や手続き呼び出しなどです。
派生式型は意味論的にプリミティブでなく、代わりにマクロで定義されているものです。
\ref{derivedsection}~節にいくつかの派生式型の適切な構文定義が掲載されています。

{\cf delay}, {\cf delay-force}, および {\cf parameterize} 式型と密接に関連する手続き
{\cf force}, {\cf promise?}, {\cf make-promise}, および {\cf make-parameter}
もこの章で説明しています。

\section{プリミティブ式型}
\label{primitivexps}

\subsection{変数参照}\unsection

\begin{entry}{%
\pproto{\hyper{variable}}{\exprtype}}

変数\index{variable}(\ref{variablesection}~節)から成る式は変数参照です。
変数参照の値はその変数が束縛されている場所に格納されている値です。
束縛されていない\index{unbound}変数を参照することはエラーです。

\begin{scheme}
(define x 28)
x   \ev  28%
\end{scheme}
\end{entry}

\subsection{リテラル式}\unsection
\label{literalsection}

\begin{entry}{%
\proto{quote}{ \hyper{datum}}{\exprtype}
\pproto{\singlequote\hyper{datum}}{\exprtype}
\pproto{\hyper{constant}}{\exprtype}}

{\cf (quote \hyper{datum})}は\hyper{datum}に評価されます。\mainschindex{'}
\hyper{datum}
には任意のSchemeのオブジェクトの外部表現(\ref{externalreps}~節を参照)を指定できます。
Schemeのコードにリテラル定数を含めるためにこの記法を使います。

\begin{scheme}%
(quote a)                     \ev  a
(quote \sharpsign(a b c))     \ev  \#(a b c)
(quote (+ 1 2))               \ev  (+ 1 2)%
\end{scheme}

{\cf (quote \hyper{datum})}は省略して\singlequote\hyper{datum}と書くことが出来ます。
この2種類の記法はあらゆる点で等価です。

\begin{scheme}
'a                   \ev  a
'\#(a b c)           \ev  \#(a b c)
'()                  \ev  ()
'(+ 1 2)             \ev  (+ 1 2)
'(quote a)           \ev  (quote a)
''a                  \ev  (quote a)%
\end{scheme}

数値定数、文字列定数、文字定数、ベクタ定数、バイトベクタ定数、ブーリアン定数は
それ自身に評価されます。
クォートする必要はありません。

\begin{scheme}
'145932    \ev  145932
145932     \ev  145932
'"abc"     \ev  "abc"
"abc"      \ev  "abc"
'\#\space   \ev  \#\space
\#\space   \ev  \#\space
'\#(a 10)  \ev  \#(a 10)
\#(a 10)  \ev  \#(a 10)
'\#u8(64 65)  \ev  \#u8(64 65)
\#u8(64 65)  \ev  \#u8(64 65)
'\schtrue  \ev  \schtrue
\schtrue   \ev  \schtrue%
\end{scheme}

\ref{storagemodel}~節で述べたように、
{\cf set-car!}や{\cf string-set!}のような変更手続きを使用して定数
(すなわちリテラル式の値)の変更を試みるのはエラーです。

\end{entry}

\subsection{手続き呼び出し}\unsection

\begin{entry}{%
\pproto{(\hyper{operator} \hyperi{operand} \dotsfoo)}{\exprtype}}

手続き呼び出しは、呼び出す手続きに対する式に続く渡す引数に対する式を括弧で囲った中に書きます。
演算子と被演算子の式が評価され(順番は規定されていません)、結果の手続きに結果の引数が渡されます。
\mainindex{call}\mainindex{procedure call}
\begin{scheme}%
(+ 3 4)                          \ev  7
((if \schfalse + *) 3 4)         \ev  12%
\end{scheme}

この文章に掲載されている手続きは、標準ライブラリからエクスポートされている変数の値として利用可能です。
例えば、上記の例の加算手続きと乗算手続きは、baseライブラリの変数{\cf +}および{\cf *}の値です。
\lambdaexp{} (\ref{lambda}~節を参照) を評価することで新しい手続きを作ることが出来ます。

手続きは任意の個数の値を返すことが出来ます(\ref{proceduresection}~節の\ide{values}を参照)。
この報告書で定義されている手続きのほとんどは、ひとつの値を返します。
{\cf apply}のような手続きの場合、引数に渡した手続きを呼び出した戻り値がそのまま返されます。
例外はそれぞれ個別の説明に記載されています。


\begin{note} 他のLisp方言と異なり、評価順は規定されていません。
また、演算子の式と被演算子の式は常に同じ評価規則で評価されます。
\end{note}

\begin{note}
評価順は規定されていませんが、
演算子と被演算子の式を並列的に評価する場合は
何らかの逐次的な評価順と一貫性を持たなければならないという制約があります。
評価順は手続き呼び出しのたびに異なっていても構いません。
\end{note}

\begin{note} 多くのLisp方言では、空リスト{\tt ()}は自分自身に評価される正当な式です。
Schemeではエラーです。
\end{note}

\end{entry}


\subsection{手続き}\unsection
\label{lamba}

\begin{entry}{%
\proto{lambda}{ \hyper{formals} \hyper{body}}{\exprtype}}

\syntax
\hyper{formals}は後述の仮引数リストです。
\hyper{body}はゼロ個以上の定義に続くひとつ以上の式です。

\semantics
\vest \lambdaexp{}は手続きに評価されます。
\lambdaexp{}が評価されたときの有効な環境が手続きの一部として記憶されます。
後ほど手続きがいくつかの実引数を伴って呼び出されると、
\lambdaexp{}が評価されたときの環境が仮引数リストの変数に新しい場所を束縛することによって拡張され、
対応する実引数の値がそれらの場所に格納されます。
(\defining{新しい}場所とは、それまで存在していたどの場所とも異なる場所のことです。)
次に、ラムダ式の本体の式
(定義があれば、{\cf letrec*}形式で表されます --- \ref{letrecstar}~節を参照)
が、その拡張された環境で逐次的に評価されます。
その本体の最後の式の結果が、その手続き呼び出しの結果として返されます。


\begin{scheme}
(lambda (x) (+ x x))      \ev  {\em{}手続き}
((lambda (x) (+ x x)) 4)  \ev  8

(define reverse-subtract
  (lambda (x y) (- y x)))
(reverse-subtract 7 10)         \ev  3

(define add4
  (let ((x 4))
    (lambda (y) (+ x y))))
(add4 6)                        \ev  10%
\end{scheme}

\hyper{Formals}は以下のいずれかの形です。

\begin{itemize}
\item {\tt(\hyperi{variable} \dotsfoo)}:
手続きは固定の個数の引数を取ります。
手続きが呼ばれたとき、引数は対応する変数に束縛されている新しい場所に格納されます。

\item \hyper{variable}:
手続きは任意の個数の引数を取ります。
手続きが呼ばれたとき、実引数の並びは新しく割り当てられたリストに変換され、
そのリストが\hyper{variable}に束縛されている新しい場所に格納されます。

\item {\tt(\hyperi{variable} \dotsfoo{} \hyper{variable$_{n}$}\ {\bf.}\
\hyper{variable$_{n+1}$})}:
最後の変数の前にスペースで区切られたピリオドがある場合、
手続きは$n$個以上の引数を取ります。
ただし$n$はピリオドの前の仮引数の数です
(最低ひとつ以上なければエラーです)。
最後の変数の束縛に格納される値は
他の仮引数に対して実引数を一致させた後に残った実引数の
新たに割り当てられたリストになります。
\end{itemize}

\hyper{variable}が\hyper{formals}に2回以上現れる場合はエラーです。

\begin{scheme}
((lambda x x) 3 4 5 6)          \ev  (3 4 5 6)
((lambda (x y . z) z)
 3 4 5 6)                       \ev  (5 6)%
\end{scheme}

\end{entry}

\lambdaexp{} を評価した結果作成された手続きはそれぞれ
(概念的に)ある記憶領域の位置に紐付けられます。
それにより手続きに対して\ide{eqv?}および\ide{eq?}を適用することができます
(\ref{equivalencesection}~節を参照)。


\subsection{条件判定}\unsection

\begin{entry}{%
\proto{if}{ \hyper{test} \hyper{consequent} \hyper{alternate}}{\exprtype}
\rproto{if}{ \hyper{test} \hyper{consequent}}{\exprtype}}  %\/ if hyper = italic

\syntax
\hyper{test}、\hyper{consequent}および\hyper{alternate}は式です。

\semantics
{\cf if}式は以下のように評価されます。
まず、\hyper{test}が評価されます。
その結果が真の値\index{true}であった場合
(\ref{booleansection}~節を参照)、
\hyper{consequent}が評価され、その値が返されます。
そうでなければ\hyper{alternate}が評価され、その値が返されます。
\hyper{test}の結果が偽の値であり、\hyper{alternate}が指定されていない場合、
式の結果は規定されていません。

\begin{scheme}
(if (> 3 2) 'yes 'no)           \ev  yes
(if (> 2 3) 'yes 'no)           \ev  no
(if (> 3 2)
    (- 3 2)
    (+ 3 2))                    \ev  1%
\end{scheme}

\end{entry}


\subsection{代入}\unsection
\label{assignment}

\begin{entry}{%
\proto{set!}{ \hyper{variable} \hyper{expression}}{\exprtype}}

\semantics
\hyper{expression}が評価され、
その結果の値が\hyper{variable}の束縛されている場所に格納されます。
\hyper{variable}が{\cf set!}式を囲むいずれの有効範囲\index{region}にも
大域的にも束縛されていなければエラーです。
{\cf set!}式の結果は規定されていません。

\begin{scheme}
(define x 2)
(+ x 1)                 \ev  3
(set! x 4)              \ev  \unspecified
(+ x 1)                 \ev  5%
\end{scheme}

\end{entry}

\subsection{インクルード}\unsection
\label{inclusion}
\begin{entry}{%
\proto{include}{ \hyperi{string} \hyperii{string} \dotsfoo}{\exprtype}
\rproto{include-ci}{ \hyperi{string} \hyperii{string} \dotsfoo}{\exprtype}}

\semantics
\ide{include}および\ide{include-ci}は両方とも、
文字列定数として表されたひとつ以上のファイル名を取り、
処理系固有のアルゴリズムを適用して対応するファイルを検索し、
{\cf read}を繰り返し適用したかのように順番にそのファイルの内容を読み込み、
そのファイルから読み込んだ内容を含む{\cf begin}式で、
その{\cf include}式または{\cf include-ci}式を実質的に置換します。
この2つの違いは以下のようなものです。
\ide{include-ci}は各ファイルの先頭に{\cf{}\#!fold-case}指令があるかのように読み込みます。
\ide{include}はそのようなことをしません。

\begin{note}
処理系は、インクルードする側のファイルがあるディレクトリでファイルを検索することが推奨されます。
また、ユーザが他の検索ディレクトリを指定するための方法を用意することが推奨されます。
\end{note}

\end{entry}

\section{派生式型}
\label{derivedexps}

この節の構文は、\ref{macrosection}~節で述べられてるように、衛生的です。
リファレンス目的のため、
この節で説明している構文のほとんどを前の節で説明したプリミティブ構文に変換する構文定義が
\ref{derivedsection}~節に掲載されています。


\subsection{条件判定}\unsection

\begin{entry}{%
\proto{cond}{ \hyperi{clause} \hyperii{clause} \dotsfoo}{\exprtype}
\pproto{else}{\auxiliarytype}
\pproto{=>}{\auxiliarytype}}

\syntax
\hyper{clauses}は、以下のいずれかの形をひとつ以上取ります。
\begin{scheme}
(\hyper{test} \hyperi{expression} \dotsfoo)%
\end{scheme}
ただし\hyper{test}は任意の式です。
\begin{scheme}
(\hyper{test} => \hyper{expression})%
\end{scheme}
最後の\hyper{clause}は、以下のような``else節''にすることも出来ます。
\begin{scheme}
(else \hyperi{expression} \hyperii{expression} \dotsfoo)\rm.%
\end{scheme}
\mainschindex{else}
\mainschindex{=>}

\semantics
{\cf cond}式は以下のように評価されます。
まず、真の値\index{true}(\ref{booleansection}~節を参照)
に評価されるまで、一連の\hyper{clause}の\hyper{test}式が順番に評価されます。
\hyper{test}が真の値に評価されると、
その\hyper{clause}の中の残りの\hyper{expression}が順に評価され、
その\hyper{clause}の中の最後の\hyper{expression}の結果が
{\cf cond}式全体の値として返されます。

選択された\hyper{clause}が\hyper{test}だけで\hyper{expression}を持たない場合、
\hyper{test}の値が結果として返されます。
選択された\hyper{clause}が\ide{=>}代理形を使っている場合、
まず\hyper{expression}が評価されます。
その値が引数をひとつ受け取る手続きでなければエラーです。
\hyper{test}の値に対してその手続きが呼び出され、
その手続きが返した値が{\cf cond}式から返されます。

すべての\hyper{test}が\schfalse{}に評価され、else節がない場合、
{\cf cond}式の結果は規定されていません。
else節があれば、その\hyper{expression}が順に評価され、
その最後の値が返されます。

\begin{scheme}
(cond ((> 3 2) 'greater)
      ((< 3 2) 'less))         \ev  greater%

(cond ((> 3 3) 'greater)
      ((< 3 3) 'less)
      (else 'equal))            \ev  equal%

(cond ((assv 'b '((a 1) (b 2))) => cadr)
      (else \schfalse{}))         \ev  2%
\end{scheme}


\end{entry}


\begin{entry}{%
\proto{case}{ \hyper{key} \hyperi{clause} \hyperii{clause} \dotsfoo}{\exprtype}}

\syntax
\hyper{key}は任意の式を指定できます。
それぞれの\hyper{clause}は以下の形です。
\begin{scheme}
((\hyperi{datum} \dotsfoo) \hyperi{expression} \hyperii{expression} \dotsfoo)\rm,%
\end{scheme}
ただしそれぞれの\hyper{datum}は何らかのオブジェクトの外部表現です。
式の中に同じ\hyper{datum}がふたつ以上ある場合はエラーです。
また、\hyper{clause}は以下の形も指定できます。
\begin{scheme}
((\hyperi{datum} \dotsfoo) => \hyper{expression})%
\end{scheme}
最後の\hyper{clause}は以下のいずれかの形を持つ``else節''に出来ます。
\begin{scheme}
(else \hyperi{expression} \hyperii{expression} \dotsfoo)
(else => \hyper{expression})\rm.%
\end{scheme}
\schindex{else}

\semantics
{\cf case}式は以下のように評価されます。
\hyper{key}が評価され、その結果が各々の\hyper{datum}と比較されます。
\hyper{key}の評価結果が\hyper{datum}と等しい
({\cf eqv?}の意味で; \ref{eqv?}~節を参照)
場合、対応する\hyper{clause}内の式が順番に評価され、
その\hyper{clause}の最後の式の結果が{\cf case}式の結果として返されます。

\hyper{key}の評価結果がどの\hyper{datum}とも異なる場合、
else節があれば、その式が評価され、その最後の結果が{\cf case}式の結果になります。
そうでなければ、{\cf case}式の結果は規定されていません。

選択された\hyper{clause}またはelse節が\ide{=>}代理形を使っている場合、
まず\hyper{expression}が評価されます。
その値がひとつの引数を受け取る手続きでなければエラーです。
\hyper{key}の値に対してその手続きが呼び出され、
その手続きが返した値が{\cf case}式から返されます。

\begin{scheme}
(case (* 2 3)
  ((2 3 5 7) 'prime)
  ((1 4 6 8 9) 'composite))     \ev  composite
(case (car '(c d))
  ((a) 'a)
  ((b) 'b))                     \ev  \unspecified
(case (car '(c d))
  ((a e i o u) 'vowel)
  ((w y) 'semivowel)
  (else => (lambda (x) x)))     \ev  c%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{and}{ \hyperi{test} \dotsfoo}{\exprtype}}

\semantics
\hyper{test}式が左から右に評価され、
いずれかの式が\schfalse{}に評価されると、そこで\schfalse{}が返されます。
残りの式は評価されません。
すべての式が真の値に評価された場合、その最後の式の値が返されます。
式がひとつも無い場合、\schtrue{}を返します。

\begin{scheme}
(and (= 2 2) (> 2 1))           \ev  \schtrue
(and (= 2 2) (< 2 1))           \ev  \schfalse
(and 1 2 'c '(f g))             \ev  (f g)
(and)                           \ev  \schtrue%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{or}{ \hyperi{test} \dotsfoo}{\exprtype}}

\semantics
\hyper{test}式が左から右に評価され、
真の値(\ref{booleansection}~節を参照)
に評価された最初の式の値が返されます
残りの式は評価されません。
すべての式が\schfalse{}に評価された場合、
または式がひとつもない場合、\schfalse{}を返します。

\begin{scheme}
(or (= 2 2) (> 2 1))            \ev  \schtrue
(or (= 2 2) (< 2 1))            \ev  \schtrue
(or \schfalse \schfalse \schfalse) \ev  \schfalse
(or (memq 'b '(a b c))
    (/ 3 0))                    \ev  (b c)%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{when}{ \hyper{test} \hyperi{expression} \hyperii{expression} \dotsfoo}{\exprtype}}

\syntax
\hyper{test}は式です。

\semantics
\hyper{test}が評価され、それが真の値に評価された場合、
\hyper{expression}が順番に評価されます。
{\cf when}式の戻り値は規定されていません。

\begin{scheme}
(when (= 1 1.0)
  (display "1")
  (display "2"))  \ev  \unspecified
 \>{\em and prints}  12%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{unless}{ \hyper{test} \hyperi{expression} \hyperii{expression} \dotsfoo}{\exprtype}}

\syntax
\hyper{test}は式です。

\semantics
\hyper{test}が評価され、それが\schfalse{}に評価された場合、
\hyper{expression}が順番に評価されます。
{\cf unless}式の戻り値は規定されていません。

\begin{scheme}
(unless (= 1 1.0)
  (display "1")
  (display "2"))  \ev  \unspecified
 \>{\em and prints nothing}%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{cond-expand}{ \hyperi{ce-clause} \hyperii{ce-clause} \dotsfoo}{\exprtype}}

\syntax
\ide{cond-expand}式型は処理系に依存して異なる式に静的に展開される方法を提供します。
\hyper{ce-clause}節は以下の形を取ります。

{\tt(\hyper{feature requirement} \hyper{expression} \dotsfoo)}

最後の節は以下の形の``else節''に出来ます。

{\tt(else \hyper{expression} \dotsfoo)}

\hyper{feature requirement}は以下の形のいずれかひとつを取ります。

\begin{itemize}
\item {\tt\hyper{feature identifier}}
\item {\tt(library \hyper{library name})}
\item {\tt(and \hyper{feature requirement} \dotsfoo)}
\item {\tt(or \hyper{feature requirement} \dotsfoo)}
\item {\tt(not \hyper{feature requirement})}
\end{itemize}

\semantics
各処理系は、インポート可能なライブラリのリストと同様に、
存在する特徴識別子のリストを管理しています。
それぞれの\hyper{feature identifier}および{\tt(library \hyper{library name})}を、
それが処理系の持つリストにある場合は \schtrue、ない場合は \schfalse に置き換え、
その結果の式を{\cf and}, {\cf or}, {\cf not}の通常の解釈の下で
Schemeのブーリアン式として評価することによって、
\hyper{feature requirement}の値が決定されます。

次に、一連の\hyper{ce-clause}の\hyper{feature requirement}が、
\schtrue を返すまで順番に評価されます。
真の値が見つかったら、対応する\hyper{expression}が{\cf begin}に展開されます。
残りの節は無視されます。
どの\hyper{feature requirement}も \schtrue に評価されない場合、
else節があれば、その\hyper{expression}が含まれます。
そうでなければ、\ide{cond-expand}の動作は規定されていません。
{\cf cond}と異なり、{\cf cond-expand}は何の変数の値にも依存しません。

appendix~\ref{stdfeatures}.
用意されている正確な特徴は処理系定義ですが、
移植性のために特徴の中核となる集合が付録~\ref{stdfeatures}掲載されています。

\end{entry}

\subsection{束縛構文}
\label{bindingsection}

束縛構文
{\cf let}, {\cf let*}, {\cf letrec}, {\cf letrec*}, {\cf let-values}, {\cf let*-values}
はAlgol 60のようなブロック構造をSchemeにもたらします。
最初の4つは同じ構文ですが、
それらが確立する変数束縛の有効範囲\index{region}が異なっています。
{\cf let}式では、どの変数が束縛されるよりも前に初期値が計算されます。
{\cf let*}式では、束縛と評価が逐次的に行われます。
{\cf letrec}式および{\cf letrec*}式では、
初期値が計算されている間もすべての束縛が有効であり、
これによって相互再帰を定義することが出来ます。
{\cf let-values}構文および{\cf let*-values}構文は
それぞれ{\cf let}および{\cf let*}に似たものですが、
多値の式を処理できるよう設計されており、
その戻り値をそれぞれ異なる識別子に束縛できます。

\begin{entry}{%
\proto{let}{ \hyper{bindings} \hyper{body}}{\exprtype}}

\syntax
\hyper{bindings}は以下の形を取ります。
\begin{scheme}
((\hyperi{variable} \hyperi{init}) \dotsfoo)\rm,%
\end{scheme}
それぞれの\hyper{init}は式で、
\hyper{body}はゼロ個以上の定義に続くひとつ以上の式です。
\ref{lambda}~節も参照してください。
束縛される変数のリストに同じ\hyper{variable}がふたつ以上現れた場合はエラーです。

\semantics
\hyper{init}が現在の環境で(何らかの規定されていない順番で)評価され、
その結果を格納した新しい場所に\hyper{variable}が束縛され、
その拡張された環境で\hyper{body}が評価され、
\hyper{body}の最後の式の値が返されます。
各\hyper{variable}の束縛は\hyper{body}をその有効範囲として持ちます。\index{region}

\begin{scheme}
(let ((x 2) (y 3))
  (* x y))                      \ev  6

(let ((x 2) (y 3))
  (let ((x 7)
        (z (+ x y)))
    (* z x)))                   \ev  35%
\end{scheme}

\ref{namedlet}節の``名前付き{\cf let}''も参照してください。

\end{entry}


\begin{entry}{%
\proto{let*}{ \hyper{bindings} \hyper{body}}{\exprtype}}\nobreak

\nobreak
\syntax
\hyper{bindings}は以下の形を取ります。
\begin{scheme}
((\hyperi{variable} \hyperi{init}) \dotsfoo)\rm,%
\end{scheme}
\hyper{body}はゼロ個以上の定義に続くひとつ以上の式です。
\ref{lambda}~節も参照してください。

\semantics
{\cf let*}束縛構文は{\cf let}と同様ですが、束縛が左から右に逐次的に行われます。
{\cf(\hyper{variable} \hyper{init})} によって示される束縛の有効範囲\index{region}は
{\cf let*}式のその束縛より右側の部分になります。
そのため、ふたつめの束縛は最初の束縛が見える環境で行われ、以下同様です。
\hyper{variable}はそれぞれ異なっている必要はありません。

\begin{scheme}
(let ((x 2) (y 3))
  (let* ((x 7)
         (z (+ x y)))
    (* z x)))             \ev  70%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{letrec}{ \hyper{bindings} \hyper{body}}{\exprtype}}

\syntax
\hyper{bindings}は以下の形を取ります。
\begin{scheme}
((\hyperi{variable} \hyperi{init}) \dotsfoo)\rm,%
\end{scheme}
\hyper{body}はゼロ個以上の定義に続くひとつ以上の式です。
\ref{lambda}~節も参照してください。
束縛される変数のリストに同じ\hyper{variable}がふたつ以上現れた場合はエラーです。

\semantics
\hyper{variable}が規定されていない値を格納した新しい場所に束縛され、
その結果の環境で\hyper{init}が(何らかの規定されていない順番で)評価され、
\hyper{init}の結果がそれぞれ対応する\hyper{varible}に代入され、
その結果の環境で\hyper{body}が評価され、
\hyper{body}の最後の式の値が返されます。
各\hyper{variable}の束縛は{\cf letrec}式全体をその有効範囲として持ちます。\index{region}
それにより相互再帰手続きを定義することが可能です。

\begin{scheme}
(letrec ((even?
          (lambda (n)
            (if (zero? n)
                \schtrue
                (odd? (- n 1)))))
         (odd?
          (lambda (n)
            (if (zero? n)
                \schfalse
                (even? (- n 1))))))
  (even? 88))
		\ev  \schtrue%
\end{scheme}

{\cf letrec}には非常に重要な制限がひとつあります。
各\hyper{init}は、どの\hyper{variable}にも代入も参照もせずに評価できなければなりません。
さもなければエラーです。
この制限は必要なものです。
{\cf lambda}式が\hyper{variable}を\hyper{init}の値に束縛する
手続き呼び出しによって{\cf letrec}が定義されているためです。
{\cf letrec}のほとんどの用途では、
\hyper{init}は\lambdaexp{}であり、
この制限は自動的に満たされます。

\end{entry}


\begin{entry}{%
\proto{letrec*}{ \hyper{bindings} \hyper{body}}{\exprtype}}
\label{letrecstar}

\syntax
\hyper{bindings}は以下の形を取ります。
\begin{scheme}
((\hyperi{variable} \hyperi{init}) \dotsfoo)\rm,%
\end{scheme}
\hyper{body}\index{body}はゼロ個以上の定義に続くひとつ以上の式です。
\ref{lambda}~節も参照してください。
束縛される変数のリストに同じ\hyper{variable}がふたつ以上現れた場合はエラーです。

\semantics
\hyper{variable}が新しい場所に束縛され、
左から右の順番で\hyper{init}が評価されその結果がそれぞれ対応する\hyper{variable}に代入され、
その結果の環境で\hyper{body}が評価され、
\hyper{body}の最後の式が返されます。
左から右の評価代入の順番にもかかわらず、
各\hyper{variable}の束縛は{\cf letrec*}式全体をその有効範囲\index{region}として持ちます。
それにより相互再帰手続きを定義することが可能です。

各\hyper{init}は対応する\hyper{variable}の値、およびそれより右側の
どの\hyper{bindings}の\hyper{variable}にも参照も代入もせず評価できなければなりません。
さもなければエラーです。
もうひとつ制限があります。
\hyper{init}の継続を2回以上呼び出すことはエラーです。

\begin{scheme}
(letrec* ((p
           (lambda (x)
             (+ 1 (q (- x 1)))))
          (q
           (lambda (y)
             (if (zero? y)
                 0
                 (+ 1 (p (- y 1))))))
          (x (p 5))
          (y x))
  y)
                \ev  5%
\end{scheme}

\begin{entry}{%
\proto{let-values}{ \hyper{mv binding spec} \hyper{body}}{\exprtype}}

\syntax
\hyper{mv binding spec}は以下の形を取ります。
\begin{scheme}
((\hyperi{formals} \hyperi{init}) \dotsfoo)\rm,%
\end{scheme}

それぞれの\hyper{init}は式で、
\hyper{body}はゼロ個以上の定義に続くひとつ以上の式です。
\ref{lambda}も参照してください。
\hyper{formals}の集合内に同じ変数がふたつ以上現れた場合はエラーです。

\semantics
\hyper{init}が現在の環境で(何らかの規定されていない順番で)
{\cf call-with-values}によって呼び出されたかのように評価され、
\hyper{init}の戻り値を格納した新しい場所に\hyper{formals}内の変数が束縛されます。
ただし\hyper{formals}は、
{\cf lambda}式が手続き呼び出しの際に引数を一致させるのと同じ方法で、
その戻り値を一致させます。
それから、その拡張された環境で\hyper{body}が評価され、
\hyper{body}の最後の式の値が返されます。
それぞれの\hyper{variable}の束縛は\hyper{body}をその有効範囲とします。\index{region}

\hyper{init}の返した値の数が対応する\hyper{formals}に一致しない場合はエラーです。

\begin{scheme}
(let-values (((root rem) (exact-integer-sqrt 32)))
  (* root rem))                \ev  35%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{let*-values}{ \hyper{mv binding spec} \hyper{body}}{\exprtype}}\nobreak

\nobreak
\syntax
\hyper{mv binding spec}は以下の形を取ります。
\begin{scheme}
((\hyper{formals} \hyper{init}) \dotsfoo)\rm,%
\end{scheme}
\hyper{body}はゼロ個以上の定義に続くひとつ以上の式です。
\ref{lambda}も参照してください。
それぞれの\hyper{formals}において、同じ変数がふたつ以上現れた場合はエラーです。

\semantics
{\cf let*-values}構文は{\cf let-values}に似ています。
\hyper{init}が評価され、左から右に逐次的に束縛が作成されます。
それぞれの\hyper{formals}の束縛の有効範囲は
\hyper{body}と同様にその\hyper{init}の右側も含まれます。
そのため、ふたつめの\hyper{init}はひとつめの束縛の集合が見えて初期化された環境で評価され、
以下同様です。

\begin{scheme}
(let ((a 'a) (b 'b) (x 'x) (y 'y))
  (let*-values (((a b) (values x y))
                ((x y) (values a b)))
    (list a b x y)))     \ev (x y x y)%
\end{scheme}

\end{entry}

\end{entry}


\subsection{逐次実行}\unsection
\label{sequencing}

Schemeの逐次実行構文は両方とも{\cf begin}という名前ですが、
それぞれ微妙に異なった形と用途があります。

\begin{entry}{%
\proto{begin}{ \hyper{expression or definition} \dotsfoo}{\exprtype}}

この形の{\cf begin}は\hyper{body}の部分、\hyper{program}の最上位、REPL、
またはこの形の{\cf begin}に直接ネストしている場合に使うことが出来ます。
囲んでいる{\cf begin}構文が存在しない場合とまったく同様に、
内部の式および定義が評価されます。

\begin{rationale}
この形は一般に、
複数の定義を生成し、それらを展開先の文脈に繋ぎ合わせる必要のある
マクロの出力で使われます(\ref{macrosection}~節を参照)。
\end{rationale}

\end{entry}

\begin{entry}{%
\rproto{begin}{ \hyperi{expression} \hyperii{expression} \dotsfoo}{\exprtype}}

この形の{\cf begin}は普通の式として使うことができます。
\hyper{expression}は左から右に逐次的に評価され、
最後の\hyper{expression}の値が返されます。
この式型は代入や入出力のような副作用を逐次実行するために使われます。

\begin{scheme}
(define x 0)

(and (= x 0)
     (begin (set! x 5)
            (+ x 1)))              \ev  6

(begin (display "4 plus 1 equals ")
       (display (+ 4 1)))      \ev  \unspecified
 \>{\em and prints}  4 plus 1 equals 5%
\end{scheme}

\end{entry}

ちなみに、ライブラリ宣言として使われる3つめの形式の{\cf begin}があります。
\ref{librarydeclarations}~節を参照してください。

\subsection{繰り返し}%\unsection

\noindent%
\pproto{(do ((\hyperi{variable} \hyperi{init} \hyperi{step})}{\exprtype}
\mainschindex{do}{\tt\obeyspaces%
     \dotsfoo)\\
    (\hyper{test} \hyper{expression} \dotsfoo)\\
  \hyper{command} \dotsfoo)}

\syntax
\hyper{init}, \hyper{step}, \hyper{test}, \hyper{command}
はすべて式です。

\semantics
{\cf do}式は繰り返し構文です。
束縛する変数の集合、
それらがどのように初期化されるか、
また繰り返しごとにどのように更新されるかを指定します。
終了条件を満たすと、\hyper{expression}を評価したあとループを抜けます。

{\cf do}式は以下のように評価されます。
\hyper{init}式が(何らかの規定されていない順番で)評価され、
\hyper{variable}が新しい場所に束縛され、
\hyper{init}式の結果がその\hyper{variable}の束縛に格納され、
そして繰り返しフェーズが始まります。

\vest それぞれの繰り返しは、\hyper{test}を評価することで始まります。
その結果が偽(\ref{booleansection}~節を参照)であれば、
\hyper{command}式が順番に評価され、
\hyper{step}式が何らかの規定されていない順番で評価され、
\hyper{variable}が新しい場所に束縛され、
\hyper{step}の結果が\hyper{variable}の束縛に格納され、
そして次の繰り返しが始まります。

\vest \hyper{test}が真に評価された場合は、
\hyper{expression}が左から右に評価されされ、
最後の\hyper{expression}の値が返されます。
\hyper{expression}が存在しなければ、{\cf do}式の値は規定されていません。

\vest \hyper{variable}の束縛の有効範囲\index{region}は
\hyper{init}を除く{\cf do}式全体から成ります。
{\cf do}の変数リストに同じ\hyper{variable}がふたつ以上現れた場合はエラーです。

\vest \hyper{step}は省略できます。
その場合の効果は{\cf(\hyper{variable} \hyper{init})}の代わりに
{\cf(\hyper{variable} \hyper{init} \hyper{variable})}と書かれた場合と同じです。

\begin{scheme}
(do ((vec (make-vector 5))
     (i 0 (+ i 1)))
    ((= i 5) vec)
  (vector-set! vec i i))          \ev  \#(0 1 2 3 4)

(let ((x '(1 3 5 7 9)))
  (do ((x x (cdr x))
       (sum 0 (+ sum (car x))))
      ((null? x) sum)))             \ev  25%
\end{scheme}



\begin{entry}{%
\rproto{let}{ \hyper{variable} \hyper{bindings} \hyper{body}}{\exprtype}}

\label{namedlet}
\semantics
``名前付き{\cf let}''は\ide{let}構文の亜種で、
{\cf do}よりも一般的なループ構文です。
再帰を表現するために使うことも出来ます。
普通の{\cf let}と同じ構文と意味論を持ちますが、
\hyper{variable}が\hyper{body}内で
仮引数がその束縛された変数で本体が\hyper{body}である手続きに束縛される点が異なります。
そのため\hyper{variable}という名前の手続きを呼ぶことにより\hyper{body}を繰り返すことが出来ます。

%                                              |  <-- right margin
\begin{scheme}
(let loop ((numbers '(3 -2 1 6 -5))
           (nonneg '())
           (neg '()))
  (cond ((null? numbers) (list nonneg neg))
        ((>= (car numbers) 0)
         (loop (cdr numbers)
               (cons (car numbers) nonneg)
               neg))
        ((< (car numbers) 0)
         (loop (cdr numbers)
               nonneg
               (cons (car numbers) neg))))) %
  \lev  ((6 1 3) (-5 -2))%
\end{scheme}

\end{entry}


\subsection{遅延評価}\unsection

\begin{entry}{%
\proto{delay}{ \hyper{expression}}{lazy library syntax}}

\todo{Fix.}

\semantics
{\cf delay}構文は手続き\ide{force}と共に、
\defining{遅延評価}または\defining{必要渡し}を実装するために使われます。
{\tt(delay~\hyper{expression})}は\defining{promise}と呼ばれるオブジェクトを返します。
これは\hyper{expression}を評価してその戻り値を取得するために
将来のある時点で({\cf force}手続きによって)問い合わせることが出来るオブジェクトです。
\todo{consider removing unspecified effect}
\hyper{expression}が複数の値を返す場合の効果は規定されていません。

\end{entry}

\begin{entry}{%
\proto{delay-force}{ \hyper{expression}}{lazy library syntax}}

\todo{Fix.}

\semantics
{\cf (delay-force \var{expression})}式は概念的には
{\cf (delay (force \var{expression}))}と同様です。
ただし{\cf delay-force}の結果をforceすると、
{\cf (force \var{expression})}に末尾呼び出しする点が異なります。
それに対して
{\cf (delay (force \var{expression}))}
はそうでない場合があります。
そのため{\cf delay}と{\cf force}の長いチェーンとなる可能性のある遅延の繰り返しアルゴリズムは、
{\cf delay-force}を使って書き直すことで、評価中に空間を無制限に消費するのを防くことが出来ます。

\end{entry}

\begin{entry}{%
\proto{force}{ promise}{lazy library procedure}}

{\cf force}手続きは\ide{delay}、\ide{delay-force}または\ide{make-promise}
によって作成された\var{promise}の値を要求します。\index{promise}
そのプロミスに対する値が計算されていなければ、値が計算されて返されます。
プロミスの値は二回目要求されたとき以前計算した値を返すために
キャッシュ(または``メモ化'')されます。
そのため、遅延式は最初に値を要求した{\cf force}呼び出しの
パラメータおよび例外ハンドラを用いて評価されます。
\var{promise}がプロミスでなければ、その値が変更されずに返されます。

\begin{scheme}
(force (delay (+ 1 2)))   \ev  3
(let ((p (delay (+ 1 2))))
  (list (force p) (force p)))  
                               \ev  (3 3)

(define integers
  (letrec ((next
            (lambda (n)
              (delay (cons n (next (+ n 1)))))))
    (next 0)))
(define head
  (lambda (stream) (car (force stream))))
(define tail
  (lambda (stream) (cdr (force stream))))

(head (tail (tail integers)))  
                               \ev  2%
\end{scheme}

以下の例は遅延ストリームフィルタリングアルゴリズムを機械的にSchemeに変換したものです。
構築手続きの呼び出しはそれぞれ{\cf delay}に包まれ、
参照手続きの引数はそれぞれ{\cf force}に包まれています。
手続き本体のまわりでは{\cf (delay (force ...))}の代わりに{\cf (delay-force ...)}を使用することで、
増加してゆく一連の保留中のプロミスが利用可能な記憶領域を使い切らないようにしています。
これは{\cf force}がそのような一連のプロミスを実質的に繰り返しforceしてくれるためです。

\begin{scheme}
(define (stream-filter p? s)
  (delay-force
   (if (null? (force s)) 
       (delay '())
       (let ((h (car (force s)))
             (t (cdr (force s))))
         (if (p? h)
             (delay (cons h (stream-filter p? t)))
             (stream-filter p? t))))))

(head (tail (tail (stream-filter odd? integers))))
                               \ev 5%
\end{scheme}

{\cf delay}、{\cf force}および{\cf delay-force}は主に関数スタイルで書かれるプログラムでの使用が意図されており、
以下の例は良いプログラミングスタイルを示しているわけではありませんが、
何度要求されたかに関わらずひとつのプロミスに対してはひとつの値しか計算されないということを示す例になっています。

\begin{scheme}
(define count 0)
(define p
  (delay (begin (set! count (+ count 1))
                (if (> count x)
                    count
                    (force p)))))
(define x 5)
p                     \ev  {\it{}a promise}
(force p)             \ev  6
p                     \ev  {\it{}a promise, still}
(begin (set! x 10)
       (force p))     \ev  6%
\end{scheme}

処理系によっては{\cf delay}、{\cf force}および{\cf delay-force}のこの意味論に
様々な拡張が行われている場合があります。

\begin{itemize}
\item プロミスでないオブジェクトに対する{\cf force}の呼び出しは、
単にそのオブジェクトを返す場合があります。

\item プロミスがそのforceされた値といかなる意味でも操作的に区別できない場合があります。
つまり、以下のような式は処理系によって
\schtrue{}または\schfalse{}のいずれに評価される場合もあります。

\begin{scheme}
(eqv? (delay 1) 1)          \ev  \unspecified
(pair? (delay (cons 1 2)))  \ev  \unspecified%
\end{scheme}

\item Implementations may implement ``implicit forcing,'' where
the value of a promise is forced by procedures
that operate only on arguments of a certain type, like {\cf cdr}
and {\cf *}.  However, procedures that operate uniformly on their
arguments, like {\cf list}, must not force them.
\item 処理系は``暗黙のforce''を実装している場合があります。
{\cf cdr}や{\cf *}のような特定の型の引数にのみ作用する手続きが
プロミスの値をforceするという機能です。
しかし、{\cf list}のように引数を一様に処理する手続きはそれらをforceしてはなりません。

\begin{scheme}
(+ (delay (* 3 7)) 13)  \ev  \unspecified
(car
  (list (delay (* 3 7)) 13))    \ev {\it{}a promise}%
\end{scheme}
\end{itemize}
\end{entry}

\begin{entry}{%
\proto{promise?} { \var{obj}}{lazy library procedure}}

{\cf promise?}手続きは、その引数がプロミスであれば\schtrue{}を返し、
そうでなければ\schfalse{}を返します。
プロミスは他のSchemeの型、例えば手続きなど、と独立している必要はないことに注意してください。

\end{entry}

\begin{entry}{%
\proto{make-promise} { \var{obj}}{lazy library procedure}}

{\cf make-promise}手続きは、forceされたときに\var{obj}を返すプロミスを返します。
{\cf delay}に似ていますが、引数は遅延されません。
これは構文ではなく手続きです。
\var{obj}がすでにプロミスであれば、それが返されます。

\end{entry}

\subsection{動的束縛}\unsection

手続き呼び出しが開始されてからそれが戻るまでの間の時間を
手続き呼び出しの\defining{動的存続期間}と呼びます。
Schemeでは、{\cf call-with-current-continuation} (\ref{continuations}~節)
によって、手続き呼び出しが戻った後も、その動的存続期間に入り直すことが出来ます。
そのため、呼び出しの動的存続期間は、連続した単一の時間でない場合があります。

この節では\defining{パラメータオブジェクト}が導入されます。
これは動的存続期間に対して新しい値を束縛できるオブジェクトです。
ある時点でのすべてのパラメータの束縛の集合は\defining{動的環境}と呼ばれます。

\begin{entry}{%
\proto{make-parameter}{ init}{procedure}
\rproto{make-parameter}{ init converter}{procedure}}

新しく割り当てられたパラメータオブジェクトを返します。
パラメータオブジェクトは引数を取らない手続きで、
そのパラメータオブジェクトに紐付けられた値を返します。
初期状態では、この値は{\cf (\var{converter} \var{init})}の値、
変換手続き\var{converter}が指定されていない場合は\var{init}の値です。
紐付けられた値は以下で述べる{\cf parameterize}を使って一時的に変更することが出来ます。

パラメータオブジェクトに引数を渡したときの効果は処理系依存です。
\end{entry}

\begin{entry}{%
\pproto{(parameterize ((\hyperi{param} \hyperi{value}) \dotsfoo)}{syntax}
{\tt\obeyspaces%
\hspace*{1em}\hyper{body})}}
\mainschindex{parameterize}

\syntax
\hyperi{param}および\hyperi{value}は両方とも式です。

\domain{\hyper{param}式の値のいずれかがパラメータオブジェクトでない場合はエラーです。}
\semantics
{\cf parameterize}式は、本体を評価する間、
指定されたパラメータオブジェクトの返す値を変更するために使用します。

\hyper{param}および\hyper{value}式の評価順序は規定されていません。
\hyper{body}は新しい動的環境で評価されます。
その動的環境では、指定されたパラメータが呼ばれると、
対応する値がパラメータオブジェクト作成時に指定した変換手続きに渡した結果を返します。
その後、パラメータの以前の値が、変換手続きに渡されずに復元されます。
\hyper{body}内の最後の式の結果が{\cf parameterize}式全体の結果として返されます。

\begin{note}
変換手続きが冪等でない場合、
{\cf (parameterize ((x (x))) ...)}は、
パラメータ\var{x}を現在の値に束縛しているように見えるものの、
ユーザが期待する結果にならないかもしれません。
\end{note}

処理系がマルチスレッド実行をサポートしている場合、
{\cf parameterize}は現在のスレッドおよび\hyper{body}の中で生成されたスレッド以外の
いかなるスレッドのいかなるパラメータに紐づく値も変更してはなりません。

パラメータオブジェクトは呼び出しチェーンのすべての手続きに値を明示的に渡す必要なく
計算に対する変更可能な設定を指定するために使うことが出来ます。

\begin{scheme}
(define radix
  (make-parameter
   10
   (lambda (x)
     (if (and (exact-integer? x) (<= 2 x 16))
         x
         (error "invalid radix")))))

(define (f n) (number->string n (radix)))

(f 12)                                       \ev "12"
(parameterize ((radix 2))
  (f 12))                                    \ev "1100"
(f 12)                                       \ev "12"

(radix 16)                                   \ev \unspecified

(parameterize ((radix 0))
  (f 12))                                    \ev \scherror%
\end{scheme}
\end{entry}


\subsection{例外処理}\unsection

\begin{entry}{%
\pproto{(guard (\hyper{variable}}{\exprtype}
{\tt\obeyspaces%
\hspace*{4em}\hyperi{cond clause} \hyperii{cond clause} \dotsfoo)\\
\hspace*{2em}\hyper{body})}\\
}
\mainschindex{guard}

\syntax
\hyper{cond clause}は{\cf cond}の仕様に記載されているものと同じです。

\semantics
\hyper{body}は例外ハンドラを持った状態で評価されます。
例外ハンドラでは、
例外オブジェクト(\ref{exceptionsection}~節の\ide{raise}を参照)
が\hyper{variable}に束縛され、
その束縛のスコープ内で、それぞれの節が{\cf cond}式の節であるかのように評価されます。
暗黙の{\cf cond}式は、{\cf guard}式の継続と動的環境で評価されます。
すべての\hyper{cond clause}の\hyper{test}が\schfalse{}に評価され、かつelse節が無い場合、
{\cf raise}または{\cf raise-continuable}の呼び出し元の動的環境で、
ただし現在の例外ハンドラは{\cf guard}式のものとして、
その例外オブジェクトに対して{\cf raise-continuable}が呼び出されます。


例外のより完全な議論は\ref{exceptionsection}~節を参照してください。

\begin{scheme}
(guard (condition
         ((assq 'a condition) => cdr)
         ((assq 'b condition)))
  (raise (list (cons 'a 42))))
\ev 42

(guard (condition
         ((assq 'a condition) => cdr)
         ((assq 'b condition)))
  (raise (list (cons 'b 23))))
\ev (b . 23)%
\end{scheme}
\end{entry}


\subsection{準引用}\unsection
\label{quasiquotesection}

\begin{entry}{%
\proto{quasiquote}{ \hyper{qq template}}{\exprtype} \nopagebreak
\pproto{\backquote\hyper{qq template}}{\exprtype}
\pproto{unquote}{\auxiliarytype}
\pproto{\comma}{\auxiliarytype}
\pproto{unquote-splicing}{\auxiliarytype}
\pproto{\commaatsign}{\auxiliarytype}}

``Quasiquote''\index{backquote}式は、
全部ではないけれど部分的にあらかじめ判っているような
リストやベクタ構造を構築するのに便利です。
\hyper{qq template}内にコンマが無ければ、
\backquote\hyper{qq template}を評価した結果は
\singlequote\hyper{qq template}を評価した結果と等価です。
しかし、\hyper{qq template}内にコンマ\mainschindex{,}がある場合、
コンマに続く式は評価(``反引用'')され、その結果がそのコンマと式の代わりにその構造内に挿入されます。
コンマにホワイトスペースを挟まずアットマーク(\atsign)\mainschindex{,@}が続いた場合、
後続の式はリストに評価できなければエラーであり、
そのリストの開き括弧および閉じ括弧は``剥ぎ取られ''、
そのリストの要素がコンマ+アットマーク式の並びのあった場所に挿入されます。
通常、コンマ+アットマークはリストおよびベクタの\hyper{qq template}内にのみ現れます。

\begin{note}
{\cf @}で始まる識別子を反引用したい場合は、
明示的に{\cf unquote}を使うか、
コンマ+アットマークの並びと一致するのを避けるためにコンマの後にホワイトスペースを置く必要があります。
\end{note}

\begin{scheme}
`(list ,(+ 1 2) 4)  \ev  (list 3 4)
(let ((name 'a)) `(list ,name ',name)) %
          \lev  (list a (quote a))
`(a ,(+ 1 2) ,@(map abs '(4 -5 6)) b) %
          \lev  (a 3 4 5 6 b)
`(({\cf foo} ,(- 10 3)) ,@(cdr '(c)) . ,(car '(cons))) %
          \lev  ((foo 7) . cons)
`\#(10 5 ,(sqrt 4) ,@(map sqrt '(16 9)) 8) %
          \lev  \#(10 5 2 4 3 8)
(let ((foo '(foo bar)) (@baz 'baz))
  `(list ,@foo , @baz))%
          \lev  (list foo bar baz)%
\end{scheme}

準引用式はネストできます。
置換は最も外側の準引用と同じネストレベルに現れた反引用部分にのみ行われます。
ネストレベルは準引用の内側に入るごとにひとつ上がり、
反引用の内側に入るごとにひとつ下がります。

\begin{scheme}
`(a `(b ,(+ 1 2) ,(foo ,(+ 1 3) d) e) f) %
          \lev  (a `(b ,(+ 1 2) ,(foo 4 d) e) f)
(let ((name1 'x)
      (name2 'y))
  `(a `(b ,,name1 ,',name2 d) e)) %
          \lev  (a `(b ,x ,'y d) e)%
\end{scheme}

準引用式は、式の評価中に実行時に構築される任意の構造について、
新しく割り当てられた可変オブジェクトを返す場合もあれば、リテラル構造を返す場合もあります。
再構築する必要のない部分は常にリテラルです。
つまり、

\begin{scheme}
(let ((a 3)) `((1 2) ,a ,4 ,'five 6))%
\end{scheme}

これは、以下のいずれかの式と等価なものとして扱われる場合があります。

\begin{scheme}
`((1 2) 3 4 five 6)

(let ((a 3))
  (cons '(1 2)
        (cons a (cons 4 (cons 'five '(6))))))%
\end{scheme}

しかし、以下の式とは等価ではありません。

\begin{scheme}
(let ((a 3)) (list (list 1 2) a 4 'five 6))%
\end{scheme}

2種類の記法\backquote\hyper{qq template}および
{\tt (quasiquote \hyper{qq template})}は、あらゆる意味において同等です。
{\cf,\hyper{expression}}は{\cf (unquote \hyper{expression})}と同等であり、
{\cf,@\hyper{expression}}は{\cf (unquote-splicing \hyper{expression})}と同等です。
\ide{write}手続きはどちらの書式で出力しても構いません。
\mainschindex{`}

\begin{scheme}
(quasiquote (list (unquote (+ 1 2)) 4)) %
          \lev  (list 3 4)
'(quasiquote (list (unquote (+ 1 2)) 4)) %
          \lev  `(list ,(+ 1 2) 4)
     {\em{}i.e.,} (quasiquote (list (unquote (+ 1 2)) 4))%
\end{scheme}


識別子{\cf quasiquote}、{\cf unquote}、{\cf unquote-splicing}のいずれかが
上で説明した以外の\hyper{qq template}内の部分に現れた場合はエラーです。

\end{entry}

\subsection{Case-lambda}\unsection
\label{caselambdasection}
\begin{entry}{%
\proto{case-lambda}{ \hyper{clause} \dotsfoo}{case-lambda library syntax}}

\syntax
それぞれの\hyper{clause}は
(\hyper{formals} \hyper{body})
の形を取ります。
ただし\hyper{formals}および\hyper{body}は \lambdaexp の場合と同じ構文です。

\semantics
{\cf case-lambda}式は可変個の引数を取る手続きに評価され、
\lambdaexp から返される手続きと同じように字句的スコープを持ちます。
この手続きが呼ばれると、
その引数が\hyper{formals}とマッチする最初の\hyper{clause}が選択されます。
ただしマッチは \lambdaexp の\hyper{formals}に対するものと同様に指定されます。
\hyper{formals}の変数が新しい場所に束縛され、
その場所に引数の値が格納され、
その拡張された環境で\hyper{body}が評価され、
\hyper{body}の結果がその手続き呼び出しの結果として返されます。

引数がどの\hyper{clause}の\hyper{formals}ともマッチしなかった場合はエラーです。

\begin{scheme}
(define range
  (case-lambda
   ((e) (range 0 e))
   ((b e) (do ((r '() (cons e r))
               (e (- e 1) (- e 1)))
              ((< e b) r)))))

(range 3)    \ev (0 1 2)
(range 3 5)  \ev (3 4)%
\end{scheme}

\end{entry}

\section{マクロ}
\label{macrosection}

Schemeのプログラムでは{\em マクロ}と呼ばれる新しい派生式型を
定義して使うことが出来ます。\mainindex{macro}
プログラムによって定義された式型は以下の構文を持ちます。
\begin{scheme}
(\hyper{keyword} {\hyper{datum}} ...)%
\end{scheme}%
ただし\hyper{keyword}はその式型を唯一に決定する識別子です。
この識別子は、そのマクロの{\em 構文キーワード}\index{syntactic keyword}、
または単に{\em キーワード}\index{keyword}と呼ばれます\index{macro keyword}。
\hyper{datum}の数およびその構文は、その式型に依存します。

マクロの実体化は、そのマクロの{\em 使用}\index{macro use}と呼びます。
マクロの使用をよりプリミティブな式にどのように変換するかを指定する規則の集合を、
そのマクロの{\em 変換器}\index{macro transformer}と呼びます。

マクロ定義機能はふたつの部分から成ります。

\begin{itemize}
\item 特定の識別子をマクロキーワードとして確立し、
それをマクロ変換器に紐付け、
マクロが定義されるスコープを制御するために使う式の集合。

\item マクロ変換器を指定するためのパターン言語。
\end{itemize}

マクロの構文キーワードは変数束縛を覆い隠し、
局所変数束縛は構文束縛を覆い隠します。\index{keyword}
意図しない衝突を防ぐためにふたつの仕組みがあります。

\begin{itemize}

\item マクロ変換器が識別子(変数またはキーワード)に対する束縛を挿入した場合、
その識別子は他の識別子との衝突を避けるためにそのスコープにおいて実質的に改名されます。
グローバル変数の定義は束縛を導入する場合もしない場合もあることに注意してください。
\ref{defines}~節を参照してください。

\item マクロ変換器が識別子の自由参照を挿入した場合、
その参照は変換器が指定された場所で可視だった束縛を参照します。
マクロの使用場所のまわりにあるいかなる局所束縛も関係しません。

\end{itemize}

これにより、
パターン言語を用いて定義されたマクロはすべて``衛生的''かつ``参照透明''であり、
Schemeの字句的スコープを保っています。\cite{Kohlbecker86,
hygienic,Bawden88,macrosthatwork,syntacticabstraction}
\mainindex{hygienic}\mainindex{referentially transparent}

処理系は他の種類のマクロ機能を用意している場合もあります。

\subsection{構文キーワードの束縛構文}
\label{bindsyntax}

{\cf let-syntax}および{\cf letrec-syntax}束縛構文は
{\cf let}および{\cf letrec}に似ていますが、
値を持つ場所に変数を束縛する代わりに、
構文キーワードをマクロ変換器に束縛します。
構文キーワードは{\cf define-syntax}を使って大域的にまたは局所的に束縛することも出来ます。
\ref{define-syntax}~節を参照してください。

\begin{entry}{%
\proto{let-syntax}{ \hyper{bindings} \hyper{body}}{\exprtype}}

\syntax
\hyper{bindings}は以下の形を取ります。
\begin{scheme}
((\hyper{keyword} \hyper{transformer spec}) \dotsfoo)%
\end{scheme}
\hyper{keyword}は識別子、
\hyper{transformer spec}は{\cf syntax-rules}で、
\hyper{body}はゼロ個以上の定義にひとつ以上の式が続いたものです。
束縛されるキーワードのリストに同じ\hyper{keyword}が2回以上現れた場合はエラーです。

\semantics
{\cf let-syntax}式の構文環境を
指定した変換器にキーワード\hyper{keyword}を束縛するマクロで拡張することによって得られた構文環境で
\hyper{body}が展開されます。
それぞれの\hyper{keyword}の束縛は\hyper{body}をその有効範囲とします。

\begin{scheme}
(let-syntax ((given-that (syntax-rules ()
                     ((given-that test stmt1 stmt2 ...)
                      (if test
                          (begin stmt1
                                 stmt2 ...))))))
  (let ((if \schtrue))
    (given-that if (set! if 'now))
    if))                           \ev  now

(let ((x 'outer))
  (let-syntax ((m (syntax-rules () ((m) x))))
    (let ((x 'inner))
      (m))))                       \ev  outer%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{letrec-syntax}{ \hyper{bindings} \hyper{body}}{\exprtype}}

\syntax
{\cf let-syntax}と同じです。

\semantics
{\cf let-syntax}式の構文環境を
指定した変換器にキーワード\hyper{keyword}を束縛するマクロで拡張することによって得られた構文環境で
\hyper{body}が展開されます。
それぞれの\hyper{keyword}の束縛は
\hyper{body}と同様に\hyper{transformer spec}もその有効範囲として持ち、
そのため変換器はその{\cf letrec-syntax}式によって導入されたマクロを使用して
表現することが出来ます。

\begin{scheme}
(letrec-syntax
    ((my-or (syntax-rules ()
              ((my-or) \schfalse)
              ((my-or e) e)
              ((my-or e1 e2 ...)
               (let ((temp e1))
                 (if temp
                     temp
                     (my-or e2 ...)))))))
  (let ((x \schfalse)
        (y 7)
        (temp 8)
        (let odd?)
        (if even?))
    (my-or x
           (let temp)
           (if y)
           y)))        \ev  7%
\end{scheme}

\end{entry}

\subsection{パターン言語}
\label{patternlanguage}

\hyper{transformer spec}は以下のいずれかの形を取ります。

\begin{entry}{%
\pproto{(syntax-rules (\hyper{literal} \dotsfoo)}{\exprtype}
{\tt\obeyspaces%
\hspace*{1em}\hyper{syntax rule} \dotsfoo)\\
}
\pproto{(syntax-rules \hyper{ellipsis} (\hyper{literal} \dotsfoo)}{\exprtype}
{\tt\obeyspaces%
\hspace*{1em}\hyper{syntax rule} \dotsfoo)}\\
\pproto{\_}{\auxiliarytype}
\pproto{\dotsfoo}{\auxiliarytype}}
\mainschindex{_}

\syntax
\hyper{literal}または2番目の形の\hyper{ellipsis}のいずれかが識別子でなければエラーです。
\hyper{syntax rule}が以下の形でない場合もエラーです。
\begin{scheme}
(\hyper{pattern} \hyper{template})%
\end{scheme}
\hyper{syntax rule}内の\hyper{pattern}
は最初の要素が識別子であるリストです。

\hyper{pattern}は識別子、定数、または以下のいずれかです。
\begin{scheme}
(\hyper{pattern} \ldots)
(\hyper{pattern} \hyper{pattern} \ldots . \hyper{pattern})
(\hyper{pattern} \ldots \hyper{pattern} \hyper{ellipsis} \hyper{pattern} \ldots)
(\hyper{pattern} \ldots \hyper{pattern} \hyper{ellipsis} \hyper{pattern} \ldots
  . \hyper{pattern})
\#(\hyper{pattern} \ldots)
\#(\hyper{pattern} \ldots \hyper{pattern} \hyper{ellipsis} \hyper{pattern} \ldots)%
\end{scheme}
\hyper{template}は識別子、定数、または以下のいずれかです。
\begin{scheme}
(\hyper{element} \ldots)
(\hyper{element} \hyper{element} \ldots . \hyper{template})
(\hyper{ellipsis} \hyper{template})
\#(\hyper{element} \ldots)%
\end{scheme}
ただし\hyper{element}は\hyper{template}であるか、
\hyper{template}に\hyper{ellipsis}が続いたものです。
\hyper{ellipsis}は{\cf syntax-rules}の2番目の形で指定された識別子であるか、
そうでなければデフォルトの識別子 {\cf ...} (連続した3つのピリオド) です。\schindex{...}

\semantics {\cf syntax-rules}のインスタンスは、
衛生的な書き換えルールの並びを指定することによって新しいマクロ変換器を生成します。
{\cf syntax-rules}で指定した変換器に紐付けられたキーワードのマクロを使用すると、
\hyper{syntax rule}内のパターンに対してマッチされます。
マッチは最も左の\hyper{syntax rule}から行われます。
マッチが見つかると、そのマクロ使用はテンプレートに従って衛生的に書き換えられます。

\hyper{pattern}内に現れる識別子は、
アンダースコア({\cf \_})、
\hyper{literal}の一覧にあるリテラル識別子、
または\hyper{ellipsis}で、
\hyper{pattern}に現れるそれ以外のすべての識別子は{\em パターン変数}です。

\hyper{syntax rule}のパターンの最初の位置にあるキーワードは、
マッチングに影響せず、パターン変数ともリテラル識別子とも見なされません。

パターン変数は任意の入力要素とマッチし、
テンプレート内のその入力要素を参照するために使われます。
ひとつの\hyper{pattern}内に同じパターン変数が2回以上現れた場合はエラーです。

アンダースコアは任意の入力要素とマッチしますが、パターン変数ではなく、
その要素を参照するために使うことはできません。
アンダースコアが\hyper{literal}のリストに現れた場合はそれが優先され、
\hyper{pattern}内のアンダースコアはリテラルとしてマッチされます。
アンダースコアは\hyper{pattern}内に複数回現れることが出来ます。

\texttt{(\hyper{literal} \dotsfoo)}内に現れた識別子は
対応する入力要素に対してマッチさせるためのリテラル識別子として解釈されます。
入力要素がリテラル識別子にマッチするには、
その入力要素が識別子であり、
マクロ式内のそれとマクロ定義内のそれが両方とも同じ字句的束縛を持っているか、
2つの識別子が同じであり両方とも字句的束縛を持っていない場合に限ります。

部分パターンに\hyper{ellipsis}が続く場合は、
ゼロ個以上のその入力要素にマッチされます。
ただし\hyper{ellipsis}が\hyper{literal}内に現れた場合を除きます。
その場合はリテラルとしてマッチされます。

より正式に言うと、以下の場合に限り入力要素 $E$ はパターン $P$ にマッチします。

\begin{itemize}
\item $P$ がアンダースコア ({\cf \_}) である。

\item $P$ がリテラル識別子でない。または

\item $P$ がリテラル識別子であり、 $E$ が同じ束縛を持つ識別子である。または

\item $P$ がリスト {\cf ($P_1$ $\dots$ $P_n$)} であり、 $E$ が $n$ 個の要素を持つリストであり、
      その要素が $P_1$ から $P_n$ にそれぞれマッチする。または

\item $P$ が真正でないリスト
      {\cf ($P_1$ $P_2$ $\dots$ $P_n$ . $P_{n+1}$)}
      であり、 $E$ が $n$ 個以上の要素を持つリストであるか真正でないリストであり、
      その要素が $P_1$ から $P_n$ にそれぞれマッチし、
      その $n$ 番目の末尾が $P_{n+1}$ にマッチする。または

\item $P$ が
      {\cf ($P_1$ $\dots$ $P_k$ $P_e$ \meta{ellipsis} $P_{m+1}$ \dotsfoo{} $P_n$)}
      の形であり、
      $E$ が $n$ 個の要素を持つ真正リストであり、
      その最初の $k$ 個がそれぞれ $P_1$ から $P_k$ にマッチし、
      続く $m-k$ 個の要素それぞれが $P_e$ にマッチし、
      残りの $n-m$ 個の要素が $P_{m+1}$ から $P_n$ にマッチする。
      または

\item $P$ が
      {\cf ($P_1$ $\dots$ $P_k$ $P_{e}$ \meta{ellipsis} $P_{m+1}$ \dotsfoo{} $P_n$ . $P_x$)}
      の形であり、
      $E$ が $n$ 個の要素を持つリストまたは真正でないリストであり、
      その最初の $k$ 個の要素が $P_1$ から $P_k$ にマッチし、
      続く $m-k$ 個の要素それぞれが $P_e$ にマッチし、
      残りの $n-m$ 個の要素が $P_{m+1}$ から $P_n$ にマッチし、
      $n$ 番目の要素である最後の cdr が $P_x$ にマッチする。
      または

\item $P$ が {\cf \#($P_1$ $\dots$ $P_n$)} の形のベクタであり、
      $E$ が $n$ 個の要素を持つベクタであり、
      その要素が $P_1$ から $P_n$ にマッチする。
      または

\item $P$ が
      {\cf \#($P_1$ $\dots$ $P_k$ $P_{e}$ \meta{ellipsis} $P_{m+1}$ \dotsfoo $P_n$)}
      の形であり、
      $E$ が $n$ 個の要素を持つベクタであり、
      その最初の $k$ 個の要素が $P_1$ から $P_k$ にマッチし、
      続く $m-k$ 個の要素それぞれが $P_e$ にマッチし、
      残りの $n-m$ 個の要素が $P_{m+1}$ から $P_n$ にマッチする。
      または

\item $P$ が定数であり、 $E$ が $P$ と{\cf equal?}手続きの意味において等しい。
\end{itemize}

マクロキーワードを、その束縛のスコープ内において、
そのパターンのいずれにもマッチしない式で使用することはエラーです。

マクロの使用が\hyper{syntax rule}のマッチしたテンプレートに従って書き換えられる際、
テンプレート内のパターン変数が入力にマッチした要素に置き換えられます。
識別子\hyper{ellipsis}がひとつ以上後続する部分パターン内に現れたパターン変数は、
同じ数の\hyper{ellipsis}が後続する部分テンプレート内でだけ使うことが出来ます。
入力中にマッチしたすべての要素により、
指定された通りの現れ方で、出力中のそれらが置き換えられます。
指定された通りに出力を組み上げられない場合はエラーです。

%%% This description of output construction is very vague.  It should
%%% probably be formalized, but that is not easy...

テンプレート内に現れたパターン変数でも識別子\hyper{ellipsis}でもない識別子は、
リテラル識別子として出力中に挿入されます。
リテラル識別子が自由識別子として挿入される場合は、
それは{\cf syntax-rules}が現れたスコープ内のその識別子の束縛を参照します。
リテラル識別子が束縛識別子として挿入された場合は、
自由識別子の意図しない捕捉を防ぐために、実質的に改名されます。

{\cf (\hyper{ellipsis} \hyper{template})}
の形のテンプレートは
\hyper{template}
と同一です。
ただしこのテンプレート内では省略記号は特別な意味を持ちません。
つまり、\hyper{template}内に含まれる省略記号はすべて通常の識別子として扱われます。
特に、テンプレート {\cf (\hyper{ellipsis} \hyper{ellipsis})} は、
単一の \hyper{ellipsis} を生成します。
これにより省略記号を含むコードに展開する構文抽象が可能になります。

\begin{scheme}
(define-syntax be-like-begin
  (syntax-rules ()
    ((be-like-begin name)
     (define-syntax name
       (syntax-rules ()
         ((name expr (... ...))
          (begin expr (... ...))))))))

(be-like-begin sequence)
(sequence 1 2 3 4) \ev 4%
\end{scheme}

例として、
\ide{let}および\ide{cond}が\ref{derivedsection}~節のように定義されている場合、
それらは衛生的であり(要求通りです)、以下はエラーとはなりません。

\begin{scheme}
(let ((=> \schfalse))
  (cond (\schtrue => 'ok)))           \ev ok%
\end{scheme}

{\cf cond}のマクロ変換器は、
{\cf =>}が局所変数であり、
従ってそれは式であり、
マクロ変換器が構文キーワードとして扱うべきbaseライブラリの識別子{\cf =>}とは異なる、
ということを認識します。
そのため上記の例は以下のように展開されます。

\begin{scheme}
(let ((=> \schfalse))
  (if \schtrue (begin => 'ok)))%
\end{scheme}

以下のようには展開されません。

\begin{scheme}
(let ((=> \schfalse))
  (let ((temp \schtrue))
    (if temp ('ok temp))))%
\end{scheme}

もしこのように展開された場合、無効な手続き呼び出しが行われてしまうでしょう。

\end{entry}

\subsection{マクロ変換器のエラー通知}


\begin{entry}{%
\pproto{(syntax-error \hyper{message} \hyper{args} \dotsfoo)}{\exprtype}}
\mainschindex{syntax-error}

{\cf syntax-error}は{\cf error} (\ref{exceptionsection})と同様に動作しますが、
展開のパスと評価のパスが分かれている処理系では
{\cf syntax-error}が展開されたら直ちにエラーを通知するべきです。
これはマクロの無効な使用方法である\hyper{pattern}に対する
{\cf syntax-rules} \hyper{template}として使うことができ、
より説明的なエラーメッセージを提供することができます。
\hyper{message}は文字列リテラルで、
\hyper{args}は追加の情報を提供する任意の式です。
アプリケーションは例外やガードで構文エラーを捕捉できると考えてはいけません。

\todo{Shinn: This doesn't check all non-identifier cases, think of a better example.}

\begin{scheme}
(define-syntax simple-let
  (syntax-rules ()
    ((\_ (head ... ((x . y) val) . tail)
        body1 body2 ...)
     (syntax-error
      "expected an identifier but got"
      (x . y)))
    ((\_ ((name val) ...) body1 body2 ...)
     ((lambda (name ...) body1 body2 ...)
       val ...))))%
\end{scheme}

\end{entry}

