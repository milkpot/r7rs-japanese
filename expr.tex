\chapter{式}
\label{expressionchapter}

\newcommand{\syntax}{{\em 構文: }}
\newcommand{\semantics}{{\em 意味論: }}

式型は{\em プリミティブ}または{\em 派生}に分類されます。
プリミティブ式型は変数や手続き呼び出しなどです。
派生式型は意味論上プリミティブでなく、マクロで定義できるものを言います。
\ref{derivedsection}~節にいくつかの派生式型の適切な構文定義が掲載されています。

{\cf delay}、{\cf delay-force}および{\cf parameterize}式型と密接に関連している
手続き{\cf force}、{\cf promise?}、{\cf make-promise}および{\cf make-parameter}
もこの章で説明しています。

\section{プリミティブ式型}
\label{primitivexps}

\subsection{変数参照}\unsection

\begin{entry}{%
\pproto{\hyper{variable}}{\exprtype}}

変数\index{変数}(\ref{variablesection}~節)から成る式は変数参照です。
変数参照の値はその変数が束縛されている場所に格納されている値です。
束縛されていない\index{束縛されていない}変数を参照することはエラーです。

\begin{scheme}
(define x 28)
x   \ev  28%
\end{scheme}
\end{entry}

\subsection{リテラル式}\unsection
\label{literalsection}

\begin{entry}{%
\proto{quote}{ \hyper{datum}}{\exprtype}
\pproto{\singlequote\hyper{datum}}{\exprtype}
\pproto{\hyper{constant}}{\exprtype}}

{\cf (quote \hyper{datum})}は\hyper{datum}に評価されます。\mainschindex{'}
\hyper{datum}
には任意のSchemeのオブジェクトの外部表現(\ref{externalreps}~節を参照)を指定できます。
Schemeのコードにリテラル定数を含めるためにこの記法を使います。

\begin{scheme}%
(quote a)                     \ev  a
(quote \sharpsign(a b c))     \ev  \#(a b c)
(quote (+ 1 2))               \ev  (+ 1 2)%
\end{scheme}

{\cf (quote \hyper{datum})}は省略して \singlequote\hyper{datum}と書くことができます。
この2種類の記法はあらゆる点で同等です。

\begin{scheme}
'a                   \ev  a
'\#(a b c)           \ev  \#(a b c)
'()                  \ev  ()
'(+ 1 2)             \ev  (+ 1 2)
'(quote a)           \ev  (quote a)
''a                  \ev  (quote a)%
\end{scheme}

数値定数、文字列定数、文字定数、ベクタ定数、バイトベクタ定数、ブーリアン定数は
それ自身に評価されます。
quoteする必要はありません。

\begin{scheme}
'145932    \ev  145932
145932     \ev  145932
'"abc"     \ev  "abc"
"abc"      \ev  "abc"
'\#\space   \ev  \#\space
\#\space   \ev  \#\space
'\#(a 10)  \ev  \#(a 10)
\#(a 10)  \ev  \#(a 10)
'\#u8(64 65)  \ev  \#u8(64 65)
\#u8(64 65)  \ev  \#u8(64 65)
'\schtrue  \ev  \schtrue
\schtrue   \ev  \schtrue%
\end{scheme}

\ref{storagemodel}~節で述べたように
{\cf set-car!} や{\cf string-set!} のような変更手続きを使用して定数
(すなわちリテラル式の値)の変更を試みることはエラーです。

\end{entry}

\subsection{手続き呼び出し}\unsection

\begin{entry}{%
\pproto{(\hyper{operator} \hyperi{operand} \dotsfoo)}{\exprtype}}

手続き呼び出しは、呼び出す手続きの式の後に渡す引数の式を並べ、括弧で囲って書きます。
演算子と被演算子の式が評価され(順番は規定されていません)、結果の手続きに結果の引数が渡されます。
\mainindex{呼び出し}\mainindex{手続き呼び出し}
\begin{scheme}%
(+ 3 4)                          \ev  7
((if \schfalse + *) 3 4)         \ev  12%
\end{scheme}

この文章に掲載されている手続きは標準ライブラリからエクスポートされている変数の値として利用可能です。
例えば上記の例の加算手続きと乗算手続きはbaseライブラリの変数 {\cf +} および {\cf *} の値です。
\lambdaexp{} (\ref{lambda}~節を参照) を評価することで新しい手続きを作ることができます。

手続き呼び出しは任意の個数の値を返すことができます(\ref{proceduresection}~節の\ide{values}を参照)。
この報告書で定義されている手続きのほとんどは単一の値を返します。
{\cf apply}のような手続きの場合、引数に渡した手続きを呼び出した戻り値がそのまま返されます。
例外はそれぞれ個別の説明に記載されています。


\begin{note} 他のLisp方言と異なり評価順は規定されていません。
また演算子の式と被演算子の式は常に同じ評価規則で評価されます。
\end{note}

\begin{note}
評価順は規定されていませんが、
演算子と被演算子の式を並列的に評価する場合は
何らかの逐次的な評価順と一貫性を持たなければならないという制約があります。
評価順は手続き呼び出しのたびに異なっていても構いません。
\end{note}

\begin{note}
多くのLisp方言では空リスト {\tt ()} は自分自身に評価される正当な式です。
Schemeではエラーです。
\end{note}

\end{entry}


\subsection{手続き}\unsection
\label{lamba}

\begin{entry}{%
\proto{lambda}{ \hyper{formals} \hyper{body}}{\exprtype}}

\syntax
\hyper{formals}は後述の仮引数リストです。
\hyper{body}はゼロ個以上の定義に続くひとつ以上の式です。

\semantics
\vest \lambdaexp{}は手続きに評価されます。
\lambdaexp{}が評価されたときの有効な環境が手続きの一部として記憶されます。
後ほど手続きがいくつかの実引数を伴って呼び出されると、
\lambdaexp{}が評価されたときの環境が仮引数リストの変数に新しい場所を束縛することによって拡張され、
対応する実引数の値がそれらの場所に格納されます。
(\defining{新しい場所}とはそれまで存在していたどの場所とも異なる場所のことです。)
次にラムダ式の本体の式
(定義があれば{\cf letrec*} の形で表されます --- \ref{letrecstar}~節を参照)
がその拡張された環境で逐次的に評価されます。
その本体の最後の式の結果がその手続き呼び出しの結果として返されます。


\begin{scheme}
(lambda (x) (+ x x))      \ev  {\em{}手続き}
((lambda (x) (+ x x)) 4)  \ev  8

(define reverse-subtract
  (lambda (x y) (- y x)))
(reverse-subtract 7 10)         \ev  3

(define add4
  (let ((x 4))
    (lambda (y) (+ x y))))
(add4 6)                        \ev  10%
\end{scheme}

\hyper{formals}は以下のいずれかの形です。

\begin{itemize}
\item {\tt(\hyperi{variable} \dotsfoo)}:
手続きは固定の個数の引数を取ります。
手続きが呼ばれると引数が対応する変数に束縛されている新しい場所に格納されます。

\item \hyper{variable}:
手続きは任意の個数の引数を取ります。
手続きが呼ばれると、実引数の並びが新しく割り当てられたリストに変換され、
そのリストが\hyper{variable}に束縛されている新しい場所に格納されます。

\item {\tt(\hyperi{variable} \dotsfoo{} \hyper{variable$_{n}$}\ {\bf.}\
\hyper{variable$_{n+1}$})}:
最後の変数の前にスペースで区切られたピリオドがある場合、
その手続きは$n$個以上の引数を取ります。
ただし$n$はピリオドの前の仮引数の数です
(最低ひとつ以上なければエラーです)。
最後の変数の束縛に格納される値は
他の仮引数に対して実引数を一致させた後に残った実引数の
新たに割り当てられたリストになります。
\end{itemize}

\hyper{variable}が\hyper{formals}に2回以上現れる場合はエラーです。

\begin{scheme}
((lambda x x) 3 4 5 6)          \ev  (3 4 5 6)
((lambda (x y . z) z)
 3 4 5 6)                       \ev  (5 6)%
\end{scheme}

\end{entry}

\lambdaexp{} を評価した結果作成された手続きはそれぞれ
(概念的に)ある記憶領域の位置に紐付けられます。
それにより手続きに対して\ide{eqv?} および\ide{eq?} を適用することができます
(\ref{equivalencesection}~節を参照)。


\subsection{条件判定}\unsection

\begin{entry}{%
\proto{if}{ \hyper{test} \hyper{consequent} \hyper{alternate}}{\exprtype}
\rproto{if}{ \hyper{test} \hyper{consequent}}{\exprtype}}  %\/ if hyper = italic

\syntax
\hyper{test}、\hyper{consequent}および\hyper{alternate}は式です。

\semantics
{\cf if}式は以下のように評価されます。
まず\hyper{test}が評価されます。
その結果が真の値\index{真}(\ref{booleansection}~節を参照)であった場合、
\hyper{consequent}が評価され、その値が返されます。
そうでなければ\hyper{alternate}が評価され、その値が返されます。
\hyper{test}の結果が偽の値であり、\hyper{alternate}が指定されていない場合、
式の結果は規定されていません。

\begin{scheme}
(if (> 3 2) 'yes 'no)           \ev  yes
(if (> 2 3) 'yes 'no)           \ev  no
(if (> 3 2)
    (- 3 2)
    (+ 3 2))                    \ev  1%
\end{scheme}

\end{entry}


\subsection{代入}\unsection
\label{assignment}

\begin{entry}{%
\proto{set!}{ \hyper{variable} \hyper{expression}}{\exprtype}}

\semantics
\hyper{expression}が評価され、
その結果の値が\hyper{variable}の束縛されている場所に格納されます。
\hyper{variable}が{\cf set!} 式を囲むいずれの有効範囲\index{有効範囲}にも
大域的にも束縛されていなければエラーです。
{\cf set!} 式の結果は規定されていません。

\begin{scheme}
(define x 2)
(+ x 1)                 \ev  3
(set! x 4)              \ev  \unspecified
(+ x 1)                 \ev  5%
\end{scheme}

\end{entry}

\subsection{インクルード}\unsection
\label{inclusion}
\begin{entry}{%
\proto{include}{ \hyperi{string} \hyperii{string} \dotsfoo}{\exprtype}
\rproto{include-ci}{ \hyperi{string} \hyperii{string} \dotsfoo}{\exprtype}}

\semantics
\ide{include}および\ide{include-ci}は両方とも
文字列定数として表されたひとつ以上のファイル名を取り、
処理系固有のアルゴリズムを適用して対応するファイルを検索し、
{\cf read}を繰り返し適用したかのように順番にそのファイルの内容を読み込み、
そのファイルから読み込んだ内容を含む{\cf begin}式で
その{\cf include}式または{\cf include-ci}式を実質的に置換します。
この2つの違いは以下のようなものです。
\ide{include-ci}は各ファイルの先頭に {\cf{}\#!fold-case}指令があるかのように読み込みます。
\ide{include}はそのようなことをしません。

\begin{note}
処理系はインクルードする側のファイルがあるディレクトリでファイルを検索することが推奨されます。
またユーザが他の検索ディレクトリを指定するための方法を提供することが推奨されます。
\end{note}

\end{entry}

\section{派生式型}
\label{derivedexps}

この節の構文は\ref{macrosection}~節で述べられてるように衛生的です。
リファレンス目的のため
この節で説明している構文のほとんどを前の節で説明したプリミティブ構文に変換する構文定義が
\ref{derivedsection}~節に掲載されています。


\subsection{条件判定}\unsection

\begin{entry}{%
\proto{cond}{ \hyperi{clause} \hyperii{clause} \dotsfoo}{\exprtype}
\pproto{else}{\auxiliarytype}
\pproto{=>}{\auxiliarytype}}

\syntax
\hyper{clause}は以下のいずれかの形をひとつ以上取ります。
\begin{scheme}
(\hyper{test} \hyperi{expression} \dotsfoo)
(\hyper{test} => \hyper{expression})%
\end{scheme}
ただし\hyper{test}は任意の式です。

最後の\hyper{clause}は以下のような「else節」にすることもできます。
\begin{scheme}
(else \hyperi{expression} \hyperii{expression} \dotsfoo)\rm%
\end{scheme}
\mainschindex{else}
\mainschindex{=>}

\semantics
{\cf cond}式は以下のように評価されます。
まず真の値\index{真}(\ref{booleansection}~節を参照)
に評価されるまで一連の\hyper{clause}の\hyper{test}式が順番に評価されます。
\hyper{test}が真の値に評価されると、
その\hyper{clause}の中の残りの\hyper{expression}が順に評価され、
その\hyper{clause}の中の最後の\hyper{expression}の結果が
{\cf cond}式全体の結果として返されます。

選択された\hyper{clause}が\hyper{test}だけで\hyper{expression}を持たない場合、
\hyper{test}の値が結果として返されます。
選択された\hyper{clause}が \ide{=>} 代理形を使っている場合、
まず\hyper{expression}が評価されます。
その値が引数をひとつ受け取る手続きでなければエラーです。
\hyper{test}の値に対してその手続きが呼び出され、
その手続きが返した値が{\cf cond}式から返されます。

すべての\hyper{test}が \schfalse{}に評価され、else節がない場合、
{\cf cond}式の結果は規定されていません。
else節があれば、その\hyper{expression}が順に評価され、
その最後の値が返されます。

\begin{scheme}
(cond ((> 3 2) 'greater)
      ((< 3 2) 'less))         \ev  greater%

(cond ((> 3 3) 'greater)
      ((< 3 3) 'less)
      (else 'equal))            \ev  equal%

(cond ((assv 'b '((a 1) (b 2))) => cadr)
      (else \schfalse{}))         \ev  2%
\end{scheme}


\end{entry}


\begin{entry}{%
\proto{case}{ \hyper{key} \hyperi{clause} \hyperii{clause} \dotsfoo}{\exprtype}}

\syntax
\hyper{key}は任意の式を指定できます。
それぞれの\hyper{clause}は以下の形です。
\begin{scheme}
((\hyperi{datum} \dotsfoo) \hyperi{expression} \hyperii{expression} \dotsfoo)%
\end{scheme}
ただしそれぞれの\hyper{datum}は何らかのオブジェクトの外部表現です。
式の中に同じ\hyper{datum}がふたつ以上ある場合はエラーです。
また\hyper{clause}には以下の形も指定できます。
\begin{scheme}
((\hyperi{datum} \dotsfoo) => \hyper{expression})%
\end{scheme}
最後の\hyper{clause}は以下のいずれかの形を持つ「else節」にできます。
\begin{scheme}
(else \hyperi{expression} \hyperii{expression} \dotsfoo)
(else => \hyper{expression})\rm%
\end{scheme}
\schindex{else}

\semantics
{\cf case}式は以下のように評価されます。
\hyper{key}が評価され、その結果が各々の\hyper{datum}と比較されます。
\hyper{key}の評価結果が\hyper{datum}と等しい
({\cf eqv?} の意味で; \ref{eqv?}~節を参照)
場合、対応する\hyper{clause}内の式が順番に評価され、
その\hyper{clause}の最後の式の結果が{\cf case}式の結果として返されます。

\hyper{key}の評価結果がどの\hyper{datum}とも異なる場合、
else節があればその式が評価され、その最後の結果が{\cf case}式の結果になります。
そうでなければ{\cf case}式の結果は規定されていません。

選択された\hyper{clause}またはelse節が \ide{=>} 代理形を使っている場合、
まず\hyper{expression}が評価されます。
その値がひとつの引数を受け取る手続きでなければエラーです。
\hyper{key}の値に対してその手続きが呼び出され、
その手続きが返した値が{\cf case}式から返されます。

\begin{scheme}
(case (* 2 3)
  ((2 3 5 7) 'prime)
  ((1 4 6 8 9) 'composite))     \ev  composite
(case (car '(c d))
  ((a) 'a)
  ((b) 'b))                     \ev  \unspecified
(case (car '(c d))
  ((a e i o u) 'vowel)
  ((w y) 'semivowel)
  (else => (lambda (x) x)))     \ev  c%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{and}{ \hyperi{test} \dotsfoo}{\exprtype}}

\semantics
\hyper{test}式が左から右に評価され、
いずれかの式が \schfalse{}に評価されるとそこで \schfalse{}が返されます。
残りの式は評価されません。
すべての式が真の値に評価された場合、その最後の式の値が返されます。
式がひとつも無ければ \schtrue{}を返します。

\begin{scheme}
(and (= 2 2) (> 2 1))           \ev  \schtrue
(and (= 2 2) (< 2 1))           \ev  \schfalse
(and 1 2 'c '(f g))             \ev  (f g)
(and)                           \ev  \schtrue%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{or}{ \hyperi{test} \dotsfoo}{\exprtype}}

\semantics
\hyper{test}式が左から右に評価され、
真の値(\ref{booleansection}~節を参照)
に評価された最初の式の値が返されます。
残りの式は評価されません。
すべての式が \schfalse{}に評価された場合
または式がひとつもない場合は \schfalse{}を返します。

\begin{scheme}
(or (= 2 2) (> 2 1))            \ev  \schtrue
(or (= 2 2) (< 2 1))            \ev  \schtrue
(or \schfalse \schfalse \schfalse) \ev  \schfalse
(or (memq 'b '(a b c))
    (/ 3 0))                    \ev  (b c)%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{when}{ \hyper{test} \hyperi{expression} \hyperii{expression} \dotsfoo}{\exprtype}}

\syntax
\hyper{test}は式です。

\semantics
\hyper{test}が評価され、それが真の値に評価された場合、
\hyper{expression}が順番に評価されます。
{\cf when}式の戻り値は規定されていません。

\begin{scheme}
(when (= 1 1.0)
  (display "1")
  (display "2"))  \ev  \unspecified
 \>{\em and prints}  12%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{unless}{ \hyper{test} \hyperi{expression} \hyperii{expression} \dotsfoo}{\exprtype}}

\syntax
\hyper{test}は式です。

\semantics
\hyper{test}が評価され、それが \schfalse{}に評価された場合、
\hyper{expression}が順番に評価されます。
{\cf unless}式の戻り値は規定されていません。

\begin{scheme}
(unless (= 1 1.0)
  (display "1")
  (display "2"))  \ev  \unspecified
 \>{\em そして何も表示されない}%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{cond-expand}{ \hyperi{ce-clause} \hyperii{ce-clause} \dotsfoo}{\exprtype}}

\syntax
\ide{cond-expand}式型は処理系に依存して異なる式に静的に展開される方法を提供します。
\hyper{ce-clause}節は以下の形を取ります。

{\tt(\hyper{feature requirement} \hyper{expression} \dotsfoo)}

最後の節は以下の形の「else節」にできます。

{\tt(else \hyper{expression} \dotsfoo)}

\hyper{feature requirement}は以下の形のいずれかひとつを取ります。

\begin{itemize}
\item {\tt\hyper{feature identifier}}
\item {\tt(library \hyper{library name})}
\item {\tt(and \hyper{feature requirement} \dotsfoo)}
\item {\tt(or \hyper{feature requirement} \dotsfoo)}
\item {\tt(not \hyper{feature requirement})}
\end{itemize}

\semantics
各処理系はインポート可能なライブラリのリストおよび
存在する機能識別子のリストを管理しています。
それぞれの\hyper{feature identifier}および{\tt(library \hyper{library name})}を、
処理系の持つリストにある場合は \schtrue{}、ない場合は \schfalse{}に置き換え、
その結果の式を{\cf and}、{\cf or}、{\cf not}の通常の解釈の下で
Schemeのブーリアン式として評価することによって、
\hyper{feature requirement}の値が決定されます。

次に一連の\hyper{ce-clause}の\hyper{feature requirement}が %
\schtrue{}を返すまで順番に評価されます。
真の節が見つかれば、対応する\hyper{expression}が{\cf begin}に展開されます。
残りの節は無視されます。
どの\hyper{feature requirement}も \schtrue{}に評価されない場合、
else節があればその\hyper{expression}が含まれます。
そうでなければ\ide{cond-expand}の動作は規定されていません。
{\cf cond}と異なり{\cf cond-expand}は何の変数の値にも依存しません。

提供されている正確な機能は処理系定義ですが、
移植性のために機能の中核的なセットが付録~\ref{stdfeatures}に掲載されています。

\end{entry}

\subsection{束縛構文}
\label{bindingsection}

束縛構文
{\cf let}、{\cf let*}、{\cf letrec}、{\cf letrec*}、
{\cf let-values}、{\cf let*-values}
はAlgol 60のようなブロック構造をSchemeに持ち込みます。
最初の4つは同じ構文ですが、
それらが確立する変数束縛の有効範囲\index{有効範囲}が異なっています。
{\cf let}式ではどの変数が束縛されるよりも前に初期値が計算されます。
{\cf let*} 式では束縛と評価が逐次的に行われます。
{\cf letrec}式および{\cf letrec*} 式では
初期値が計算されている間もすべての束縛が有効であり、
これによって相互再帰を定義することができます。
{\cf let-values}構文および{\cf let*-values}構文は
それぞれ{\cf let}および{\cf let*} に似ていますが、
多値の式を処理できるよう設計されており、
返された多値をそれぞれ異なる識別子に束縛できます。

\begin{entry}{%
\proto{let}{ \hyper{bindings} \hyper{body}}{\exprtype}}

\syntax
\hyper{bindings}は以下の形を取ります。
\begin{scheme}
((\hyperi{variable} \hyperi{init}) \dotsfoo)\rm%
\end{scheme}
それぞれの\hyper{init}は式で、
\hyper{body}はゼロ個以上の定義に続くひとつ以上の式です。
\ref{lambda}~節も参照してください。
束縛される変数のリストに同じ\hyper{variable}がふたつ以上現れた場合はエラーです。

\semantics
\hyper{init}が現在の環境で(何らかの規定されていない順番で)評価され、
その結果を格納した新しい場所に\hyper{variable}が束縛され、
その拡張された環境で\hyper{body}が評価され、
\hyper{body}の最後の式の値が返されます。
各\hyper{variable}の束縛は\hyper{body}をその有効範囲として持ちます。\index{有効範囲}

\begin{scheme}
(let ((x 2) (y 3))
  (* x y))                      \ev  6

(let ((x 2) (y 3))
  (let ((x 7)
        (z (+ x y)))
    (* z x)))                   \ev  35%
\end{scheme}

\ref{namedlet}節の「名前付き{\cf let}」も参照してください。

\end{entry}


\begin{entry}{%
\proto{let*}{ \hyper{bindings} \hyper{body}}{\exprtype}}\nobreak

\nobreak
\syntax
\hyper{bindings}は以下の形を取ります。
\begin{scheme}
((\hyperi{variable} \hyperi{init}) \dotsfoo)\rm%
\end{scheme}
\hyper{body}はゼロ個以上の定義に続くひとつ以上の式です。
\ref{lambda}~節も参照してください。

\semantics
{\cf let*} 束縛構文は{\cf let}と同様ですが、束縛が左から右に逐次的に行われます。
{\cf(\hyper{variable} \hyper{init})} によって示される束縛の有効範囲\index{有効範囲}は
{\cf let*} 式のその束縛より右側の部分になります。
従って2番目の束縛は最初の束縛が見える環境で行われ、以下同様です。
\hyper{variable}がそれぞれ異なっている必要はありません。

\begin{scheme}
(let ((x 2) (y 3))
  (let* ((x 7)
         (z (+ x y)))
    (* z x)))             \ev  70%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{letrec}{ \hyper{bindings} \hyper{body}}{\exprtype}}

\syntax
\hyper{bindings}は以下の形を取ります。
\begin{scheme}
((\hyperi{variable} \hyperi{init}) \dotsfoo)\rm%
\end{scheme}
\hyper{body}はゼロ個以上の定義に続くひとつ以上の式です。
\ref{lambda}~節も参照してください。
束縛される変数のリストに同じ\hyper{variable}がふたつ以上現れた場合はエラーです。

\semantics
規定されていない値を格納した新しい場所に\hyper{variable}が束縛され、
その結果の環境で\hyper{init}が(何らかの規定されていない順番で)評価され、
\hyper{init}の結果がそれぞれ対応する\hyper{varible}に代入され、
その結果の環境で\hyper{body}が評価され、
\hyper{body}の最後の式の値が返されます。
各\hyper{variable}の束縛は{\cf letrec}式全体をその有効範囲として持ちます。\index{有効範囲}
それにより相互再帰手続きを定義することが可能です。

\begin{scheme}
(letrec ((even?
          (lambda (n)
            (if (zero? n)
                \schtrue
                (odd? (- n 1)))))
         (odd?
          (lambda (n)
            (if (zero? n)
                \schfalse
                (even? (- n 1))))))
  (even? 88))
		\ev  \schtrue%
\end{scheme}

{\cf letrec}には非常に重要な制限がひとつあります。
各\hyper{init}はどの\hyper{variable}にも代入も参照もせずに評価できなければなりません。
さもなければエラーです。
この制限は必要なものです。
{\cf lambda}式が\hyper{variable}を\hyper{init}の値に束縛する
手続き呼び出しによって{\cf letrec}が定義されているためです。
{\cf letrec}のほとんどの用途では、
\hyper{init}は\lambdaexp{}であり、
この制限は自動的に満たされます。

\end{entry}


\begin{entry}{%
\proto{letrec*}{ \hyper{bindings} \hyper{body}}{\exprtype}}
\label{letrecstar}

\syntax
\hyper{bindings}は以下の形を取ります。
\begin{scheme}
((\hyperi{variable} \hyperi{init}) \dotsfoo)\rm%
\end{scheme}
\hyper{body}\index{body}はゼロ個以上の定義に続くひとつ以上の式です。
\ref{lambda}~節も参照してください。
束縛される変数のリストに同じ\hyper{variable}がふたつ以上現れた場合はエラーです。

\semantics
\hyper{variable}が新しい場所に束縛され、
左から右の順番で\hyper{init}が評価された結果がそれぞれ対応する\hyper{variable}に代入され、
その結果の環境で\hyper{body}が評価され、
\hyper{body}の最後の式が返されます。
左から右の評価代入の順番にもかかわらず、
各\hyper{variable}の束縛は{\cf letrec*} 式全体をその有効範囲\index{有効範囲}として持ちます。
それにより相互再帰手続きを定義することが可能です。

各\hyper{init}は対応する\hyper{variable}の値およびそれより右側の
どの\hyper{bindings}の\hyper{variable}にも参照も代入もせず評価できなければなりません。
さもなければエラーです。
もうひとつ制限があります。
\hyper{init}の継続を2回以上呼び出すことはエラーです。

\begin{scheme}
(letrec* ((p
           (lambda (x)
             (+ 1 (q (- x 1)))))
          (q
           (lambda (y)
             (if (zero? y)
                 0
                 (+ 1 (p (- y 1))))))
          (x (p 5))
          (y x))
  y)
                \ev  5%
\end{scheme}

\begin{entry}{%
\proto{let-values}{ \hyper{mv binding spec} \hyper{body}}{\exprtype}}

\syntax
\hyper{mv binding spec}は以下の形を取ります。
\begin{scheme}
((\hyperi{formals} \hyperi{init}) \dotsfoo)%
\end{scheme}

それぞれの\hyper{init}は式で、
\hyper{body}はゼロ個以上の定義に続くひとつ以上の式です。
\ref{lambda}も参照してください。
\hyper{formals}の集合内に同じ変数がふたつ以上現れた場合はエラーです。

\semantics
\hyper{init}が現在の環境で(何らかの規定されていない順番で)
{\cf call-with-values}によって呼び出されたかのように評価され、
\hyper{init}の戻り値を格納した新しい場所に\hyper{formals}内の変数が束縛されます。
ただし\hyper{formals}は
{\cf lambda}式が手続き呼び出しの際に引数を一致させるのと同じ方法で
その戻り値を一致させます。
その後その拡張された環境で\hyper{body}が評価され、
\hyper{body}の最後の式の値が返されます。
それぞれの\hyper{variable}の束縛は\hyper{body}をその有効範囲とします。\index{有効範囲}

\hyper{init}の返した値の数が対応する\hyper{formals}に一致しない場合はエラーです。

\begin{scheme}
(let-values (((root rem) (exact-integer-sqrt 32)))
  (* root rem))                \ev  35%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{let*-values}{ \hyper{mv binding spec} \hyper{body}}{\exprtype}}\nobreak

\nobreak
\syntax
\hyper{mv binding spec}は以下の形を取ります。
\begin{scheme}
((\hyper{formals} \hyper{init}) \dotsfoo)%
\end{scheme}
\hyper{body}はゼロ個以上の定義に続くひとつ以上の式です。
\ref{lambda}も参照してください。
それぞれの\hyper{formals}において同じ変数がふたつ以上現れた場合はエラーです。

\semantics
{\cf let*-values}構文は{\cf let-values}に似ていますが、
左から右に逐次的に、\hyper{init}が評価され、束縛が作成されます。
それぞれの\hyper{formals}の束縛の有効範囲は
\hyper{body}だけでなくその\hyper{init}の右側も含まれます。
従って2番目の\hyper{init}は最初の束縛の集合が見えて初期化された環境で評価され、
以下同様です。

\begin{scheme}
(let ((a 'a) (b 'b) (x 'x) (y 'y))
  (let*-values (((a b) (values x y))
                ((x y) (values a b)))
    (list a b x y)))     \ev (x y x y)%
\end{scheme}

\end{entry}

\end{entry}


\subsection{逐次実行}
\label{sequencing}

Schemeの逐次実行構文は両方とも{\cf begin}という名前ですが、
それぞれ微妙に異なった形と用途があります。

\begin{entry}{%
\proto{begin}{ \hyper{expression or definition} \dotsfoo}{\exprtype}}

この形の{\cf begin}は\hyper{body}の一部、\hyper{program}の最上位、REPL、
またはこの形の{\cf begin}に直接ネストしている場合に使うことができます。
囲んでいる{\cf begin}構文が存在しない場合とまったく同様に、
内部の式および定義が評価されます。

\begin{rationale}
この形は一般的に、
複数の定義を生成しそれらを展開先の文脈に繋ぎ合わせる必要のある
マクロの出力で使われます(\ref{macrosection}~節を参照)。
\end{rationale}

\end{entry}

\begin{entry}{%
\rproto{begin}{ \hyperi{expression} \hyperii{expression} \dotsfoo}{\exprtype}}

この形の{\cf begin}は普通の式として使うことができます。
\hyper{expression}は左から右に逐次的に評価され、
最後の\hyper{expression}の値が返されます。
この式型は代入や入出力のような副作用を逐次実行するために使われます。

\begin{scheme}
(define x 0)

(and (= x 0)
     (begin (set! x 5)
            (+ x 1)))              \ev  6

(begin (display "4 plus 1 equals ")
       (display (+ 4 1)))      \ev  \unspecified
 \>{\em そして} 4 plus 1 equals 5 {\em を表示します}%
\end{scheme}

\end{entry}

ちなみにライブラリ宣言として使われる3つめの形式の{\cf begin}があります。
\ref{librarydeclarations}~節を参照してください。

\subsection{繰り返し}%\unsection

\noindent%
\pproto{(do ((\hyperi{variable} \hyperi{init} \hyperi{step})}{\exprtype}
\mainschindex{do}{\tt\obeyspaces%
     \dotsfoo)\\
    (\hyper{test} \hyper{expression} \dotsfoo)\\
  \hyper{command} \dotsfoo)}

\syntax
\hyper{init}、\hyper{step}、\hyper{test}、\hyper{command}
はすべて式です。

\semantics
{\cf do}式は繰り返し構文です。
束縛する変数の集合、
それらがどのように初期化されるか、
また繰り返しごとにどのように更新されるかを指定します。
終了条件を満たすと\hyper{expression}を評価したあとループを抜けます。

{\cf do}式は以下のように評価されます。
\hyper{init}式が(何らかの規定されていない順番で)評価され、
\hyper{variable}が新しい場所に束縛され、
\hyper{init}式の結果がその\hyper{variable}の束縛に格納され、
そして繰り返しフェーズが始まります。

\vest それぞれの繰り返しの始めに\hyper{test}が評価されます。
その結果が偽(\ref{booleansection}~節を参照)であれば
\hyper{command}式が順番に評価され、
\hyper{step}式が何らかの規定されていない順番で評価され、
\hyper{variable}が新しい場所に束縛され、
\hyper{step}の結果が\hyper{variable}の束縛に格納され、
そして次の繰り返しが始まります。

\vest \hyper{test}が真に評価された場合は、
\hyper{expression}が左から右に評価され、
最後の\hyper{expression}の値が返されます。
\hyper{expression}が存在しなければ{\cf do}式の値は規定されていません。

\vest \hyper{variable}の束縛の有効範囲\index{有効範囲}は
\hyper{init}を除く{\cf do}式全体から成ります。
{\cf do}の変数リストに同じ\hyper{variable}がふたつ以上現れた場合はエラーです。

\vest \hyper{step}は省略できます。
その場合は{\cf(\hyper{variable} \hyper{init})}の代わりに
{\cf(\hyper{variable} \hyper{init} \hyper{variable})}と書かれた場合と
同じ効果を持ちます。

\begin{scheme}
(do ((vec (make-vector 5))
     (i 0 (+ i 1)))
    ((= i 5) vec)
  (vector-set! vec i i))          \ev  \#(0 1 2 3 4)

(let ((x '(1 3 5 7 9)))
  (do ((x x (cdr x))
       (sum 0 (+ sum (car x))))
      ((null? x) sum)))             \ev  25%
\end{scheme}



\begin{entry}{%
\rproto{let}{ \hyper{variable} \hyper{bindings} \hyper{body}}{\exprtype}}

\label{namedlet}
\semantics
「名前付き{\cf let}」は\ide{let}構文の亜種で、
{\cf do}よりも一般的なループ構文です。
再帰を表現するために使うこともできます。
普通の{\cf let}と同じ構文と意味論を持ちますが、
\hyper{variable}が\hyper{body}内で
仮引数がその束縛された変数で本体が\hyper{body}である手続きに束縛される点が異なります。
そのため\hyper{variable}という名前の手続きを呼ぶことにより\hyper{body}を繰り返すことができます。

%                                              |  <-- right margin
\begin{scheme}
(let loop ((numbers '(3 -2 1 6 -5))
           (nonneg '())
           (neg '()))
  (cond ((null? numbers) (list nonneg neg))
        ((>= (car numbers) 0)
         (loop (cdr numbers)
               (cons (car numbers) nonneg)
               neg))
        ((< (car numbers) 0)
         (loop (cdr numbers)
               nonneg
               (cons (car numbers) neg))))) %
  \lev  ((6 1 3) (-5 -2))%
\end{scheme}

\end{entry}


\subsection{遅延評価}\unsection

\begin{entry}{%
\proto{delay}{ \hyper{expression}}{lazyライブラリの構文}}

\todo{Fix.}

\semantics
{\cf delay}構文は手続き\ide{force}と共に
\defining{遅延評価}または\defining{必要渡し}を実装するために使われます。
{\tt(delay~\hyper{expression})}は\defining{プロミス}と呼ばれるオブジェクトを返します。
これは\hyper{expression}を評価してその戻り値を取得するために
将来のある時点で({\cf force}手続きによって)問い合わせることができるオブジェクトです。
\todo{consider removing unspecified effect}
\hyper{expression}が多値を返した場合の効果は規定されていません。

\end{entry}

\begin{entry}{%
\proto{delay-force}{ \hyper{expression}}{lazyライブラリの構文}}

\todo{Fix.}

\semantics
{\cf (delay-force \var{expression})}式は概念的には
{\cf (delay (force \var{expression}))}と同様です。
ただし{\cf delay-force}の結果をforceすると
{\cf (force \var{expression})}に末尾呼び出しする点が異なります。
それに対して
{\cf (delay (force \var{expression}))}
はそうでない可能性があります。
そのため{\cf delay}と{\cf force}の長いチェーンとなる可能性のある遅延の繰り返しアルゴリズムは、
{\cf delay-force}を使って書き直すことで、評価中に空間を無制限に消費するのを防くことができます。

\end{entry}

\begin{entry}{%
\proto{force}{ promise}{lazyライブラリの手続き}}

{\cf force}手続きは\ide{delay}、\ide{delay-force}または\ide{make-promise}
によって作成された\var{promise}の値を要求します。\index{プロミス}
そのプロミスに対する値が計算されていなければ値が計算されて返されます。
プロミスの値は二回目要求されたとき以前計算した値を返すために
キャッシュ(または「メモ化」)されます。
そのため遅延式は最初に値を要求した{\cf force}呼び出しの
パラメータおよび例外ハンドラを用いて評価されます。
\var{promise}がプロミスでなければ、その値が変更されずに返されます。

\begin{scheme}
(force (delay (+ 1 2)))   \ev  3
(let ((p (delay (+ 1 2))))
  (list (force p) (force p)))  
                               \ev  (3 3)

(define integers
  (letrec ((next
            (lambda (n)
              (delay (cons n (next (+ n 1)))))))
    (next 0)))
(define head
  (lambda (stream) (car (force stream))))
(define tail
  (lambda (stream) (cdr (force stream))))

(head (tail (tail integers)))  
                               \ev  2%
\end{scheme}

以下の例は遅延ストリームフィルタリングアルゴリズムを機械的にSchemeに変換したものです。
構築手続きの呼び出しはそれぞれ{\cf delay}に包まれ、
参照手続きの引数はそれぞれ{\cf force}に包まれています。
手続き本体のまわりでは{\cf (delay (force ...))}の代わりに{\cf (delay-force ...)}を使用することで、
増加してゆく一連の保留中のプロミスが利用可能な記憶領域を使い切らないようにしています。
これは{\cf force}がそのような一連のプロミスを実質的に繰り返しforceしてくれるためです。

\begin{scheme}
(define (stream-filter p? s)
  (delay-force
   (if (null? (force s)) 
       (delay '())
       (let ((h (car (force s)))
             (t (cdr (force s))))
         (if (p? h)
             (delay (cons h (stream-filter p? t)))
             (stream-filter p? t))))))

(head (tail (tail (stream-filter odd? integers))))
                               \ev 5%
\end{scheme}

{\cf delay}、{\cf force}および{\cf delay-force}は主に関数スタイルで書かれるプログラムでの使用が意図されており、
以下の例は良いプログラミングスタイルを示しているわけではありませんが、
何度要求されたかに関わらずひとつのプロミスに対してはひとつの値しか計算されないということを示す例になっています。

\begin{scheme}
(define count 0)
(define p
  (delay (begin (set! count (+ count 1))
                (if (> count x)
                    count
                    (force p)))))
(define x 5)
p                     \ev  {\it{}プロミス}
(force p)             \ev  6
p                     \ev  {\it{}プロミス(未だに)}
(begin (set! x 10)
       (force p))     \ev  6%
\end{scheme}

処理系によっては{\cf delay}、{\cf force}および{\cf delay-force}のこの意味論に
様々な拡張が行われています。

\begin{itemize}
\item プロミスでないオブジェクトに対して{\cf force}が呼ばれた場合は
単にそのオブジェクトを返しても構いません。

\item プロミスがそのforceされた値といかなる意味でも操作的に区別できなくても構いません。
つまり処理系は以下のような式を %
\schtrue{}または \schfalse{}のいずれに評価しても構いません。

\begin{scheme}
(eqv? (delay 1) 1)          \ev  \unspecified
(pair? (delay (cons 1 2)))  \ev  \unspecified%
\end{scheme}

\item 処理系は「暗黙のforce」を実装しても構いません。
これは{\cf cdr}や {\cf *} のような特定の型の引数にのみ作用する手続きが
プロミスの値をforceするという機能です。
ただし{\cf list}のように引数を一様に処理する手続きはそれらをforceしてはなりません。

\begin{scheme}
(+ (delay (* 3 7)) 13)  \ev  \unspecified
(car
  (list (delay (* 3 7)) 13))    \ev  {\it{}プロミス}%
\end{scheme}
\end{itemize}
\end{entry}

\begin{entry}{%
\proto{promise?} { \var{obj}}{lazyライブラリの手続き}}

{\cf promise?} 手続きはその引数がプロミスであれば \schtrue{}を返し、
そうでなければ \schfalse{}を返します。
プロミスが他のSchemeの型(手続きなど)から独立している必要はないことに注意してください。

\end{entry}

\begin{entry}{%
\proto{make-promise} { \var{obj}}{lazyライブラリの手続き}}

{\cf make-promise}手続きはforceされたときに\var{obj}を返すプロミスを返します。
{\cf delay}に似ていますが引数は遅延されません。
これは構文ではなく手続きです。
\var{obj}がすでにプロミスであればそれが返されます。

\end{entry}

\subsection{動的束縛}\unsection

手続き呼び出しが開始されてからそれが戻るまでの間の時間を
手続き呼び出しの\defining{動的生存期間}と呼びます。
Schemeでは{\cf call-with-current-continuation} (\ref{continuations}~節)
によって、手続き呼び出しが戻った後もその動的生存期間に入り直すことができます。
そのため呼び出しの動的生存期間は連続した単一の時間でない場合があります。

この節では\defining{パラメータオブジェクト}が導入されます。
これは動的生存期間に対して新しい値を束縛できるオブジェクトです。
ある時点でのすべてのパラメータの束縛の集合は\defining{動的環境}と呼ばれます。

\begin{entry}{%
\proto{make-parameter}{ init}{手続き}
\rproto{make-parameter}{ init converter}{手続き}}

新しく割り当てられたパラメータオブジェクトを返します。
パラメータオブジェクトは引数を取らない手続きで、
そのパラメータオブジェクトに紐付けられた値を返します。
初期状態ではこの値は{\cf (\var{converter} \var{init})}の値、
変換手続き\var{converter}が指定されていない場合は\var{init}の値です。
紐付けられた値は以下で述べる{\cf parameterize}を使って一時的に変更することができます。

パラメータオブジェクトに引数を渡したときの効果は処理系依存です。
\end{entry}

\begin{entry}{%
\pproto{(parameterize ((\hyperi{param} \hyperi{value}) \dotsfoo)}{構文}
{\tt\obeyspaces%
\hspace*{1em}\hyper{body})}}
\mainschindex{parameterize}

\syntax
\hyperi{param}および\hyperi{value}は両方とも式です。

\domain{\hyper{param}式の値のいずれかがパラメータオブジェクトでない場合はエラーです。}
\semantics
{\cf parameterize}式は、本体を評価する間、
指定されたパラメータオブジェクトの返す値を変更するために使用します。

\hyper{param}および\hyper{value}式の評価順序は規定されていません。
\hyper{body}は新しい動的環境で評価されます。
その動的環境では、指定されたパラメータが呼ばれると
対応する値を変換手続きに渡した結果を返します。
変換手続きはパラメータオブジェクト作成時に指定したものです。
その後パラメータの以前の値が変換手続きに渡されずに復元されます。
\hyper{body}内の最後の式の結果が{\cf parameterize}式全体の結果として返されます。

\begin{note}
変換手続きが冪等でない場合、
{\cf (parameterize ((x (x))) ...)}は
パラメータ\var{x}を現在の値に束縛しているように見えるものの、
ユーザが期待する結果とは異なるかもしれません。
\end{note}

処理系がマルチスレッド実行をサポートしている場合、
{\cf parameterize}は現在のスレッドおよび\hyper{body}の中で生成されたスレッド以外の
いかなるスレッドのいかなるパラメータに紐付けられた値も変更してはなりません。

パラメータオブジェクトは呼び出しチェーンのすべての手続きに値を明示的に渡す必要なく
計算に対する変更可能な設定を指定するために使うことができます。

\begin{scheme}
(define radix
  (make-parameter
   10
   (lambda (x)
     (if (and (exact-integer? x) (<= 2 x 16))
         x
         (error "invalid radix")))))

(define (f n) (number->string n (radix)))

(f 12)                                       \ev "12"
(parameterize ((radix 2))
  (f 12))                                    \ev "1100"
(f 12)                                       \ev "12"

(radix 16)                                   \ev \unspecified

(parameterize ((radix 0))
  (f 12))                                    \ev \scherror%
\end{scheme}
\end{entry}


\subsection{例外処理}\unsection

\begin{entry}{%
\pproto{(guard (\hyper{variable}}{\exprtype}
{\tt\obeyspaces%
\hspace*{4em}\hyperi{cond clause} \hyperii{cond clause} \dotsfoo)\\
\hspace*{2em}\hyper{body})}\\
}
\mainschindex{guard}

\syntax
\hyper{cond clause}は{\cf cond}の仕様に記載されているものと同じです。

\semantics
\hyper{body}は例外ハンドラを持った状態で評価されます。
例外ハンドラでは
例外オブジェクト(\ref{exceptionsection}~節の\ide{raise}を参照)
が\hyper{variable}に束縛され、
その束縛のスコープ内でそれぞれの節が{\cf cond}式の節であるかのように評価されます。
暗黙の{\cf cond}式は{\cf guard}式の継続と動的環境で評価されます。
すべての\hyper{cond clause}の\hyper{test}が \schfalse{}に評価され、かつelse節が無い場合、
現在の例外ハンドラが{\cf guard}式のものであること以外
{\cf raise}または{\cf raise-continuable}の呼び出し元と同じ動的環境で、
その例外オブジェクトに対して{\cf raise-continuable}が呼び出されます。


例外のより完全な議論は\ref{exceptionsection}~節を参照してください。

\begin{scheme}
(guard (condition
         ((assq 'a condition) => cdr)
         ((assq 'b condition)))
  (raise (list (cons 'a 42))))
\ev 42

(guard (condition
         ((assq 'a condition) => cdr)
         ((assq 'b condition)))
  (raise (list (cons 'b 23))))
\ev (b . 23)%
\end{scheme}
\end{entry}


\subsection{quasiquote}\unsection
\label{quasiquotesection}

\begin{entry}{%
\proto{quasiquote}{ \hyper{qq template}}{\exprtype} \nopagebreak
\pproto{\backquote\hyper{qq template}}{\exprtype}
\pproto{unquote}{\auxiliarytype}
\pproto{\comma}{\auxiliarytype}
\pproto{unquote-splicing}{\auxiliarytype}
\pproto{\commaatsign}{\auxiliarytype}}

「quasiquote」\index{バッククォート}式は
全部ではないけれど部分的にあらかじめ判っているような
リストやベクタ構造を構築する場合に便利です。
\hyper{qq template}内にコンマが無ければ %
\backquote\hyper{qq template}を評価した結果は %
\singlequote\hyper{qq template}を評価した結果と同等です。
しかし\hyper{qq template}内にコンマ\mainschindex{,}がある場合、
コンマに続く式は評価(「unquote」)され、その結果がそのコンマと式の代わりにその構造内に挿入されます。
コンマにホワイトスペースを挟まずアットマーク (\atsign)\mainschindex{,@} が続いた場合、
後続の式はリストに評価できなければエラーであり、
そのリストの開き括弧および閉じ括弧は「剥ぎ取られ」、
そのリストの要素がコンマ・アットマーク・式の並びのあった場所に挿入されます。
通常コンマ・アットマークはリストおよびベクタの\hyper{qq template}内にのみ現れます。

\begin{note}
{\cf @} で始まる識別子をunquoteしたい場合は
明示的に{\cf unquote}を使うか、
コンマ・アットマークの並びと一致するのを避けるため
コンマの後にホワイトスペースを置く必要があります。
\end{note}

\begin{scheme}
`(list ,(+ 1 2) 4)  \ev  (list 3 4)
(let ((name 'a)) `(list ,name ',name)) %
          \lev  (list a (quote a))
`(a ,(+ 1 2) ,@(map abs '(4 -5 6)) b) %
          \lev  (a 3 4 5 6 b)
`(({\cf foo} ,(- 10 3)) ,@(cdr '(c)) . ,(car '(cons))) %
          \lev  ((foo 7) . cons)
`\#(10 5 ,(sqrt 4) ,@(map sqrt '(16 9)) 8) %
          \lev  \#(10 5 2 4 3 8)
(let ((foo '(foo bar)) (@baz 'baz))
  `(list ,@foo , @baz))%
          \lev  (list foo bar baz)%
\end{scheme}

quasiquote式はネストできます。
置換は最も外側のquasiquoteと同じネストレベルに現れたunquote部分にのみ行われます。
ネストレベルはquasiquoteの内側に入るごとにひとつ上がり、
unquoteの内側に入るごとにひとつ下がります。

\begin{scheme}
`(a `(b ,(+ 1 2) ,(foo ,(+ 1 3) d) e) f) %
          \lev  (a `(b ,(+ 1 2) ,(foo 4 d) e) f)
(let ((name1 'x)
      (name2 'y))
  `(a `(b ,,name1 ,',name2 d) e)) %
          \lev  (a `(b ,x ,'y d) e)%
\end{scheme}

quasiquote式は式の評価中に実行時に構築された任意の構造について、
新しく割り当てられた可変オブジェクトを返してもリテラル構造を返しても構いません。
再構築する必要のない部分は常にリテラルです。
つまり

\begin{scheme}
(let ((a 3)) `((1 2) ,a ,4 ,'five 6))%
\end{scheme}

これは以下のいずれかの式と同等なものとして扱われる可能性があります。

\begin{scheme}
`((1 2) 3 4 five 6)

(let ((a 3))
  (cons '(1 2)
        (cons a (cons 4 (cons 'five '(6))))))%
\end{scheme}

しかし以下の式と同等ではありません。

\begin{scheme}
(let ((a 3)) (list (list 1 2) a 4 'five 6))%
\end{scheme}

2種類の記法 \backquote\hyper{qq template}および
{\tt (quasiquote \hyper{qq template})}はあらゆる意味において同等です。
{\cf,\hyper{expression}}は{\cf (unquote \hyper{expression})}と同等であり
{\cf,@\hyper{expression}}は{\cf (unquote-splicing \hyper{expression})}と同等です。
\ide{write}手続きはどちらの書式で出力しても構いません。
\mainschindex{`}

\begin{scheme}
(quasiquote (list (unquote (+ 1 2)) 4)) %
          \lev  (list 3 4)
'(quasiquote (list (unquote (+ 1 2)) 4)) %
          \lev  `(list ,(+ 1 2) 4)
     {\em{}i.e.,} (quasiquote (list (unquote (+ 1 2)) 4))%
\end{scheme}


識別子{\cf quasiquote}、{\cf unquote}、{\cf unquote-splicing}のいずれかが
上で説明した以外の\hyper{qq template}内の位置に現れた場合はエラーです。

\end{entry}

\subsection{case-lambda}\unsection
\label{caselambdasection}
\begin{entry}{%
\proto{case-lambda}{ \hyper{clause} \dotsfoo}{case-lambdaライブラリ構文}}

\syntax
それぞれの\hyper{clause}は
(\hyper{formals} \hyper{body})
の形を取ります。
ただし\hyper{formals}および\hyper{body}は \lambdaexp の場合と同じ構文です。

\semantics
{\cf case-lambda}式は可変個の引数を取る手続きに評価され、
\lambdaexp{}から返される手続きと同様の字句的スコープを持ちます。
この手続きが呼ばれると、
その引数が\hyper{formals}とマッチする最初の\hyper{clause}が選択されます。
ただしマッチは\lambdaexp{}の\hyper{formals}に対するものと同様に指定されます。
\hyper{formals}の変数が新しい場所に束縛され、
その場所に引数の値が格納され、
その拡張された環境で\hyper{body}が評価され、
\hyper{body}の結果がその手続き呼び出しの結果として返されます。

引数がどの\hyper{clause}の\hyper{formals}ともマッチしなかった場合はエラーです。

\begin{scheme}
(define range
  (case-lambda
   ((e) (range 0 e))
   ((b e) (do ((r '() (cons e r))
               (e (- e 1) (- e 1)))
              ((< e b) r)))))

(range 3)    \ev (0 1 2)
(range 3 5)  \ev (3 4)%
\end{scheme}

\end{entry}

\section{マクロ}
\label{macrosection}

Schemeのプログラムでは{\em マクロ}と呼ばれる新しい派生式型を
定義して使うことができます。\mainindex{マクロ}
プログラムによって定義された式型は以下の構文を持ちます。
\begin{scheme}
(\hyper{keyword} {\hyper{datum}} ...)%
\end{scheme}%
ただし\hyper{keyword}はその式型を一意に決定する識別子です。
この識別子はそのマクロの{\em 構文キーワード}\index{構文キーワード}%
または単に{\em キーワード}\index{キーワード}と呼ばれます\index{マクロキーワード}。
\hyper{datum}の数およびその構文はその式型に依存します。

マクロの実体化はそのマクロの{\em 使用}\index{マクロの使用}と呼ばれます。
マクロの使用をよりプリミティブな式にどのように変換するかを指定する規則の集合は
そのマクロの{\em 変換子}\index{マクロ変換子}と呼ばれます。

マクロ定義機能はふたつの部分から成ります。

\begin{itemize}
\item 特定の識別子をマクロキーワードとして確立し、
それをマクロ変換子に紐付け、
マクロが定義されるスコープを制御するために使う式の集合。

\item マクロ変換子を指定するためのパターン言語。
\end{itemize}

マクロの構文キーワードは変数束縛を覆い隠し、
局所変数束縛は構文束縛を覆い隠します。\index{キーワード}
意図しない衝突を防ぐためにふたつの仕組みがあります。

\begin{itemize}

\item マクロ変換子が識別子(変数またはキーワード)に対する束縛を挿入した場合、
その識別子は他の識別子との衝突を避けるためにそのスコープにおいて実質的に改名されます。
ちなみに大域変数の定義は束縛を導入してもしなくても構いません。
\ref{defines}~節を参照してください。

\item マクロ変換子が識別子の自由参照を挿入した場合、
その参照は変換子が指定された場所から見えていた束縛を参照します。
マクロの使用場所のまわりにあるいかなる局所束縛も関係しません。

\end{itemize}

これにより
パターン言語を用いて定義されたマクロはすべて「衛生的」かつ「参照透明」であり、
Schemeの字句的スコープが保たれます。\cite{Kohlbecker86,
hygienic,Bawden88,macrosthatwork,syntacticabstraction}
\mainindex{衛生的}\mainindex{参照透明}

処理系は他の種類のマクロ機能を提供しても構いません。

\subsection{構文キーワードの束縛構文}
\label{bindsyntax}

{\cf let-syntax}および{\cf letrec-syntax}束縛構文は
{\cf let}および{\cf letrec}に似ていますが、
値を持つ場所に変数を束縛する代わりに
構文キーワードをマクロ変換子に束縛します。
構文キーワードは{\cf define-syntax}を使って大域的または局所的に束縛することもできます。
\ref{define-syntax}~節を参照してください。

\begin{entry}{%
\proto{let-syntax}{ \hyper{bindings} \hyper{body}}{\exprtype}}

\syntax
\hyper{bindings}は以下の形を取ります。
\begin{scheme}
((\hyper{keyword} \hyper{transformer spec}) \dotsfoo)%
\end{scheme}
\hyper{keyword}は識別子、
\hyper{transformer spec}は{\cf syntax-rules}のインスタンス、
\hyper{body}はひとつ以上の定義にひとつ以上の式が続いたものです。
束縛されるキーワードのリストに同じ\hyper{keyword}が2回以上現れた場合はエラーです。

\semantics
{\cf let-syntax}式の構文環境を
指定した変換子にキーワード\hyper{keyword}を束縛するマクロで拡張することによって得られた構文環境で
\hyper{body}が展開されます。
それぞれの\hyper{keyword}の束縛は\hyper{body}をその有効範囲とします。

\begin{scheme}
(let-syntax ((given-that (syntax-rules ()
               ((given-that test stmt1 stmt2 ...)
                (if test
                    (begin stmt1
                           stmt2 ...))))))
  (let ((if \schtrue))
    (given-that if (set! if 'now))
    if))                           \ev  now

(let ((x 'outer))
  (let-syntax ((m (syntax-rules () ((m) x))))
    (let ((x 'inner))
      (m))))                       \ev  outer%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{letrec-syntax}{ \hyper{bindings} \hyper{body}}{\exprtype}}

\syntax
{\cf let-syntax}と同じです。

\semantics
{\cf letrec-syntax}式の構文環境を
指定した変換子にキーワード\hyper{keyword}を束縛するマクロで拡張することによって得られた構文環境で
\hyper{body}が展開されます。
それぞれの\hyper{keyword}の束縛は
\hyper{body}と同様に\hyper{transformer spec}もその有効範囲として持ち、
そのため変換子はその{\cf letrec-syntax}式によって導入されたマクロを使用して
式を書き換えることができます。

\begin{scheme}
(letrec-syntax
    ((my-or (syntax-rules ()
              ((my-or) \schfalse)
              ((my-or e) e)
              ((my-or e1 e2 ...)
               (let ((temp e1))
                 (if temp
                     temp
                     (my-or e2 ...)))))))
  (let ((x \schfalse)
        (y 7)
        (temp 8)
        (let odd?)
        (if even?))
    (my-or x
           (let temp)
           (if y)
           y)))        \ev  7%
\end{scheme}

\end{entry}

\subsection{パターン言語}
\label{patternlanguage}

\hyper{transformer spec}は以下のいずれかの形を取ります。

\begin{entry}{%
\pproto{(syntax-rules (\hyper{literal} \dotsfoo)}{\exprtype}
{\tt\obeyspaces%
\hspace*{1em}\hyper{syntax rule} \dotsfoo)\\
}
\pproto{(syntax-rules \hyper{ellipsis} (\hyper{literal} \dotsfoo)}{\exprtype}
{\tt\obeyspaces%
\hspace*{1em}\hyper{syntax rule} \dotsfoo)}\\
\pproto{\_}{\auxiliarytype}
\pproto{\dotsfoo}{\auxiliarytype}}
\mainschindex{_}

\syntax
\hyper{literal}または2番目の形の\hyper{ellipsis}のいずれかが識別子でなければエラーです。
\hyper{syntax rule}が以下の形でない場合もエラーです。
\begin{scheme}
(\hyper{pattern} \hyper{template})%
\end{scheme}
\hyper{syntax rule}内の\hyper{pattern}
は最初の要素が識別子であるリストです。

\hyper{pattern}は識別子、定数、または以下のいずれかです。
\begin{scheme}
(\hyper{pattern} \ldots)
(\hyper{pattern} \hyper{pattern} \ldots . \hyper{pattern})
(\hyper{pattern} \ldots \hyper{pattern} \hyper{ellipsis} \hyper{pattern} \ldots)
(\hyper{pattern} \ldots \hyper{pattern} \hyper{ellipsis} \hyper{pattern} \ldots
  . \hyper{pattern})
\#(\hyper{pattern} \ldots)
\#(\hyper{pattern} \ldots \hyper{pattern} \hyper{ellipsis} \hyper{pattern} \ldots)%
\end{scheme}
\hyper{template}は識別子、定数、または以下のいずれかです。
\begin{scheme}
(\hyper{element} \ldots)
(\hyper{element} \hyper{element} \ldots . \hyper{template})
(\hyper{ellipsis} \hyper{template})
\#(\hyper{element} \ldots)%
\end{scheme}
ただし\hyper{element}は\hyper{template}であるか、
\hyper{template}に\hyper{ellipsis}が続いたものです。
\hyper{ellipsis}は{\cf syntax-rules}の2番目の形で指定された識別子であるか、
そうでなければデフォルトの識別子 {\cf ...} (連続した3つのピリオド) です。\schindex{...}

\semantics {\cf syntax-rules}のインスタンスは
衛生的な書き換えルールの並びを指定することによって新しいマクロ変換子を生成します。
{\cf syntax-rules}で指定された変換子に紐付けられたキーワードのマクロを使用すると
\hyper{syntax rule}内のパターンに対してマッチされます。
マッチは最も左の\hyper{syntax rule}から行われます。
マッチが見つかるとそのマクロ使用はテンプレートに従って衛生的に書き換えられます。

\hyper{pattern}内に現れる識別子は
アンダースコア({\cf \_})、
\hyper{literal}の一覧にあるリテラル識別子、
または\hyper{ellipsis}で、
\hyper{pattern}に現れるそれ以外のすべての識別子は{\em パターン変数}です。

\hyper{syntax rule}のパターンの最初の位置にあるキーワードは
マッチングに影響せず、パターン変数ともリテラル識別子とも見なされません。

パターン変数は任意の入力要素とマッチし、
テンプレート内でその入力要素を参照するために使われます。
ひとつの\hyper{pattern}内に同じパターン変数が2回以上現れた場合はエラーです。

アンダースコアは任意の入力要素とマッチしますがパターン変数ではなく、
その要素を参照するために使うことはできません。
アンダースコアが\hyper{literal}のリストに現れた場合はそれが優先され、
\hyper{pattern}内のアンダースコアはリテラルとしてマッチされます。
アンダースコアは\hyper{pattern}内に複数回現れることができます。

\texttt{(\hyper{literal} \dotsfoo)}内に現れた識別子は
対応する入力要素に対してマッチさせるためのリテラル識別子として解釈されます。
入力要素がリテラル識別子にマッチするには、
その入力要素が識別子であり、
マクロ式内のそれとマクロ定義内のそれが両方とも同じ字句的束縛を持っているか、
2つの識別子が同じであり両方とも字句的束縛を持っていない場合に限ります。

部分パターンに\hyper{ellipsis}が続く場合は
ゼロ個以上のその入力要素にマッチされます。
ただし\hyper{ellipsis}が\hyper{literal}内に現れた場合を除きます。
その場合はリテラルとしてマッチされます。

より形式的に言うと以下の場合に限り入力要素 $E$ はパターン $P$ にマッチします。

\begin{itemize}
\item $P$ がアンダースコア ({\cf \_}) である。

\item $P$ がリテラルでない識別子である。または

\item $P$ がリテラル識別子であり、 $E$ が同じ束縛を持つ識別子である。または

\item $P$ がリスト {\cf ($P_1$ $\dots$ $P_n$)} であり、 $E$ が $n$ 個の要素を持つリストであり、
      その要素が $P_1$〜$P_n$ にそれぞれマッチする。または

\item $P$ が非真正リスト
      {\cf ($P_1$ $P_2$ $\dots$ $P_n$ . $P_{n+1}$)}
      であり、 $E$ が $n$ 個以上の要素を持つリストであるか非真正リストであり、
      その要素が $P_1$〜$P_n$ にそれぞれマッチし、
      その $n$ 番目の末尾が $P_{n+1}$ にマッチする。または

\item $P$ が
      {\cf ($P_1$ $\dots$ $P_k$ $P_e$ \meta{ellipsis} $P_{m+1}$ \dotsfoo{} $P_n$)}
      の形であり、
      $E$ が $n$ 個の要素を持つ真正リストであり、
      その最初の $k$ 個がそれぞれ $P_1$〜$P_k$ にマッチし、
      続く $m-k$ 個の要素それぞれが $P_e$ にマッチし、
      残りの $n-m$ 個の要素が $P_{m+1}$〜$P_n$ にマッチする。
      または

\item $P$ が
      {\cf ($P_1$ $\dots$ $P_k$ $P_{e}$ \meta{ellipsis} $P_{m+1}$ \dotsfoo{} $P_n$ . $P_x$)}
      の形であり、
      $E$ が $n$ 個の要素を持つリストまたは非真正リストであり、
      その最初の $k$ 個の要素が $P_1$〜$P_k$ にマッチし、
      続く $m-k$ 個の要素それぞれが $P_e$ にマッチし、
      残りの $n-m$ 個の要素が $P_{m+1}$〜$P_n$ にマッチし、
      $n$ 番目の要素である最後の cdr が $P_x$ にマッチする。
      または

\item $P$ が {\cf \#($P_1$ $\dots$ $P_n$)} の形のベクタであり、
      $E$ が $n$ 個の要素を持つベクタであり、
      その要素が $P_1$〜$P_n$ にマッチする。
      または

\item $P$ が
      {\cf \#($P_1$ $\dots$ $P_k$ $P_{e}$ \meta{ellipsis} $P_{m+1}$ \dotsfoo $P_n$)}
      の形であり、
      $E$ が $n$ 個の要素を持つベクタであり、
      その最初の $k$ 個の要素が $P_1$〜$P_k$ にマッチし、
      続く $m-k$ 個の要素それぞれが $P_e$ にマッチし、
      残りの $n-m$ 個の要素が $P_{m+1}$〜$P_n$ にマッチする。
      または

\item $P$ が定数であり、 $E$ が $P$ と{\cf equal?} 手続きの意味において等しい。
\end{itemize}

マクロキーワードをその束縛のスコープ内において
そのパターンのいずれにもマッチしない式で使用することはエラーです。

マクロの使用がマッチした\hyper{syntax rule}のテンプレートに従って書き換えられる際、
テンプレート内のパターン変数が入力にマッチした要素に置き換えられます。
識別子\hyper{ellipsis}がひとつ以上後続する部分パターン内に現れたパターン変数は、
同じ数の\hyper{ellipsis}が後続する部分テンプレート内でだけ使うことができます。
入力中にマッチしたすべての要素により、
指定された通りの現れ方で出力中のそれらが置き換えられます。
指定された通りに出力を組み立てられない場合はエラーです。

%%% This description of output construction is very vague.  It should
%%% probably be formalized, but that is not easy...

テンプレート内に現れた、パターン変数でも識別子\hyper{ellipsis}でもない識別子は、
リテラル識別子として出力中に挿入されます。
リテラル識別子が自由識別子として挿入された場合、
それは{\cf syntax-rules}のインスタンスが現れたスコープ内のその識別子の束縛を参照します。
リテラル識別子が束縛識別子として挿入された場合、
それは自由識別子を意図せず捕捉しないよう実質的に改名されます。

{\cf (\hyper{ellipsis} \hyper{template})}
の形のテンプレートは
\hyper{template}
と同一です。
ただしこのテンプレート内では省略記号は特別な意味を持ちません。
つまり\hyper{template}内に含まれる省略記号はすべて通常の識別子として扱われます。
特にテンプレート {\cf (\hyper{ellipsis} \hyper{ellipsis})} は
単一の \hyper{ellipsis} を生成します。
これにより省略記号を含むコードに展開する構文抽象が可能になります。

\begin{scheme}
(define-syntax be-like-begin
  (syntax-rules ()
    ((be-like-begin name)
     (define-syntax name
       (syntax-rules ()
         ((name expr (... ...))
          (begin expr (... ...))))))))

(be-like-begin sequence)
(sequence 1 2 3 4) \ev 4%
\end{scheme}

例えば
\ide{let}および\ide{cond}が\ref{derivedsection}~節のように定義されている場合、
それらは衛生的であり(要求通りです)、以下はエラーとはなりません。

\begin{scheme}
(let ((=> \schfalse))
  (cond (\schtrue => 'ok)))           \ev ok%
\end{scheme}

{\cf cond}のマクロ変換子は %
{\cf =>} が局所変数であり、
従ってそれは式であり、
マクロ変換子が構文キーワードとして扱うべきbaseライブラリの識別子 {\cf =>} とは異なる
ということを認識します。
そのため上記の例は以下のように展開されます。

\begin{scheme}
(let ((=> \schfalse))
  (if \schtrue (begin => 'ok)))%
\end{scheme}

以下のようには展開されません。

\begin{scheme}
(let ((=> \schfalse))
  (let ((temp \schtrue))
    (if temp ('ok temp))))%
\end{scheme}

もしこのように展開された場合、無効な手続き呼び出しが行われてしまうでしょう。

\end{entry}

\subsection{マクロ変換子のエラー通知}


\begin{entry}{%
\pproto{(syntax-error \hyper{message} \hyper{args} \dotsfoo)}{\exprtype}}
\mainschindex{syntax-error}

{\cf syntax-error}は{\cf error} (\ref{exceptionsection})と同様に動作しますが、
展開のパスと評価のパスが分かれている処理系では
{\cf syntax-\+error}が展開されたら直ちにエラーを通知するべきです。
これはマクロの無効な使用方法である\hyper{pattern}に対する
{\cf syntax-rules}の\hyper{template}として使うことができ、
より説明的なエラーメッセージを提供することができます。
\hyper{message}は文字列リテラルで、
\hyper{args}は追加の情報を提供する任意の式です。
アプリケーションは例外ハンドラやガードで構文エラーを捕捉できると考えてはいけません。

\todo{Shinn: This doesn't check all non-identifier cases, think of a better example.}

\begin{scheme}
(define-syntax simple-let
  (syntax-rules ()
    ((\_ (head ... ((x . y) val) . tail)
        body1 body2 ...)
     (syntax-error
      "expected an identifier but got"
      (x . y)))
    ((\_ ((name val) ...) body1 body2 ...)
     ((lambda (name ...) body1 body2 ...)
       val ...))))%
\end{scheme}

\end{entry}

