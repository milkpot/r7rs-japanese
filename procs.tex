% Initial environment

%\vfill\eject
\chapter{標準手続き}
\label{initialenv}
\label{builtinchapter}

\mainindex{初期環境}
\mainindex{大域環境}
\mainindex{手続き}

この章ではSchemeの組み込み手続きを説明します。

手続き{\cf force}、{\cf promise?} および{\cf make-promise}は
式型{\cf delay}および{\cf delay-force}と密接に関連しているため、\ref{force}~節で説明しています。
同様に手続き{\cf make-\+parameter}は式型{\cf parameterize}と密接に関連しているため、
\ref{make-parameter}~節で説明しています。

\todo{consider removing unspecified effect}
プログラムは大域変数定義を用いて任意の変数を束縛できます。
それらの束縛は後に代入によって変更される可能性があります(\ref{assignment}~節を参照)。
これらの操作がこの報告書で定義されている手続きの動作を変更することはありません。
またライブラリ(\ref{libraries}~節を参照)からインポートされた手続きの動作を変更することもありません。
定義によって導入されたものでない大域変数を変更した場合、
この章で定義されている手続きの動作に与える効果は規定されていません。

手続きが\defining{新しく割り当てられた}オブジェクトを返すと言うとき、
それはそのオブジェクトの場所が新しいという意味です。

\section{等値述語}
\label{equivalencesection}

常にブーリアン値(\schtrue{}または \schfalse)を返す手続きを\defining{述語}と呼びます。
\defining{等値述語}は数学の等値関係をコンピュータ的に真似たものです。
つまり対称性を持ち、反射性を持ち、推移的です。
この節で説明している等値述語は
{\cf eq?} が最も細かく(最も識別性が高く)、
{\cf equal?} が最も粗く、
{\cf eqv?} がその中間です。


\begin{entry}{%
\proto{eqv?}{ \vari{obj} \varii{obj}}{手続き}}

{\cf eqv?} 手続きはオブジェクトに対する有用な等値関係を定義します。
大雑把に言うと{\cf eqv?} は
\vari{obj}と\varii{obj}が普通に考えて同じオブジェクトである場合に %
\schtrue{}を返します。
この関係は若干解釈の余地が残されていますが、
以下に述べる{\cf eqv?} の部分的仕様はすべてのScheme処理系において維持されています。


{\cf eqv?} は以下の場合に \schtrue{}を返します。

\begin{itemize}
\item \vari{obj}と\varii{obj}が共に \schtrue{}であるか、共に \schfalse{}である。

\item \vari{obj}と\varii{obj}が共にシンボルであり、
{\cf symbol=?} 手続きによれば等しい(\ref{symbolsection}~節)。

\item \vari{obj}と\varii{obj}が共に正確な数値であり、
({\cf =} の意味で)数値的に等しい。

\item \vari{obj}と\varii{obj}が共に不正確な数値であり、
({\cf =} の意味で)数値的に等しく、
そしてScheme標準の数値計算手続き(ただしNaN値を返さない場合に限る)
の有限個の合成関数として定義することのできる任意の他の手続きに
引数として渡したときに({\cf eqv?} の意味で)同じ結果を生成する。

\item \vari{obj}と\varii{obj}が共に文字であり、
{\cf char=?} 手続きによれば同じ文字である(\ref{charactersection}~節)。

\item \vari{obj}と\varii{obj}が共に空リストである。

\item \vari{obj}と\varii{obj}がペア、ベクタ、バイトベクタ、レコードまたは文字列であり、
同じ格納場所を指し示す(\ref{storagemodel}~節)。

\item \vari{obj}と\varii{obj}が手続きであり、
同じ場所に紐付けられている(\ref{lambda}~節)。
\end{itemize}

{\cf eqv?} 手続きは以下の場合に \schfalse{}を返します。

\begin{itemize}
\item \vari{obj}と\varii{obj}が異なる型である
(\ref{disjointness}~節)。

\item \vari{obj}または\varii{obj}の一方が \schtrue{}であり、
他方が \schfalse{}である。

\item \vari{obj}および\varii{obj}がシンボルであるが、
{\cf symbol=?} 手続きによれば同じシンボルでない
(\ref{symbolsection}~節)。

\item \vari{obj}または\varii{obj}の一方が正確な数値であり、
他方が不正確な数値である。

\item \vari{obj}と\varii{obj}が共に正確な数値であるが、
({\cf =} の意味で)数値的に等しくない。

\item \vari{obj}と\varii{obj}が共に不正確な数値であり、
({\cf =} の意味で)数値的に等しくないか、
またはScheme標準の数値計算手続き(ただしNaN値を返さない場合に限る)
の有限個の合成関数として定義することのできる任意の他の手続きに
引数として渡したときに({\cf eqv?} の意味で)同じ結果を生成しない。
例外として、\vari{obj}と\varii{obj}が共にNaNであるとき、
{\cf eqv?} の動作は規定されていません。

\item \vari{obj}および\varii{obj}が文字であり、
{\cf char=?} 手続きが \schfalse{}を返す。

\item \vari{obj}または\varii{obj}の一方が空リストであり、他方がそうでない。

\item \vari{obj}および\varii{obj}がペア、ベクタ、バイトベクタ、レコードまたは文字列であり、
その指し示す場所が異なる。

\item \vari{obj}および\varii{obj}が手続きであり、
何らかの引数に対して異なる動作をする(異なる値を返すか、異なる副作用を持つ)。

\end{itemize}

\begin{scheme}
(eqv? 'a 'a)                     \ev  \schtrue
(eqv? 'a 'b)                     \ev  \schfalse
(eqv? 2 2)                       \ev  \schtrue
(eqv? 2 2.0)                     \ev  \schfalse
(eqv? '() '())                   \ev  \schtrue
(eqv? 100000000 100000000)       \ev  \schtrue
(eqv? 0.0 +nan.0)                \ev  \schfalse
(eqv? (cons 1 2) (cons 1 2))     \ev  \schfalse
(eqv? (lambda () 1)
      (lambda () 2))             \ev  \schfalse
(let ((p (lambda (x) x)))
  (eqv? p p))                    \ev  \schtrue
(eqv? \#f 'nil)                  \ev  \schfalse%
\end{scheme}

前述のルールで{\cf eqv?} の動作が完全には規定されていない状況を以下の例に示します。
そのような場合において言えることは、
{\cf eqv?} の返す値がブーリアンでなければならない、ということだけです。

\begin{scheme}
(eqv? "" "")             \ev  \unspecified
(eqv? '\#() '\#())         \ev  \unspecified
(eqv? (lambda (x) x)
      (lambda (x) x))    \ev  \unspecified
(eqv? (lambda (x) x)
      (lambda (y) y))    \ev  \unspecified
(eqv? 1.0e0 1.0f0)       \ev  \unspecified
(eqv? +nan.0 +nan.0)     \ev  \unspecified%
\end{scheme}

負のゼロが区別されている場合{\cf (eqv? 0.0 -0.0)}は \schfalse{}を返し、
負のゼロが区別されていない場合は \schtrue{}を返します。

次の一連の例は局所的な状態を持つ手続きに対する{\cf eqv?} の使用を示します。
{\cf gen-counter}手続きは毎回別々の手続きを返さなければなりません。
なぜならそれぞれ別個の内部カウンタが必要であるためです。
しかし{\cf gen-loser}手続きは毎回操作的に同等な手続きを返します。
なぜなら局所状態がその手続きの値にも副作用にも影響しないためです。
しかし{\cf eqv?} はこの等しさを検出してもしなくても構いません。

\begin{scheme}
(define gen-counter
  (lambda ()
    (let ((n 0))
      (lambda () (set! n (+ n 1)) n))))
(let ((g (gen-counter)))
  (eqv? g g))           \ev  \schtrue
(eqv? (gen-counter) (gen-counter))
                        \ev  \schfalse
(define gen-loser
  (lambda ()
    (let ((n 0))
      (lambda () (set! n (+ n 1)) 27))))
(let ((g (gen-loser)))
  (eqv? g g))           \ev  \schtrue
(eqv? (gen-loser) (gen-loser))
                        \ev  \unspecified

(letrec ((f (lambda () (if (eqv? f g) 'both 'f)))
         (g (lambda () (if (eqv? f g) 'both 'g))))
  (eqv? f g))
                        \ev  \unspecified

(letrec ((f (lambda () (if (eqv? f g) 'f 'both)))
         (g (lambda () (if (eqv? f g) 'g 'both))))
  (eqv? f g))
                        \ev  \schfalse%
\end{scheme}

定数オブジェクト(リテラル式によって返される)を変更することはエラーであるので、
処理系は適切な状況においては定数間で構造を共有しても構いません。
そのため定数に対する{\cf eqv?} の値は処理系依存になることがあります。

\begin{scheme}
(eqv? '(a) '(a))                 \ev  \unspecified
(eqv? "a" "a")                   \ev  \unspecified
(eqv? '(b) (cdr '(a b)))	 \ev  \unspecified
(let ((x '(a)))
  (eqv? x x))                    \ev  \schtrue%
\end{scheme}

上で述べた{\cf eqv?} の定義は手続きおよびリテラルの扱いについて処理系に自由を与えます。
処理系は
2つの手続きや2つのリテラルがお互いに同等であるか検出できてもできなくてもよく、
2つの同等なオブジェクトの表現を同じビットパターンやポインタを用いて
マージするかしないかを選ぶことができます。

\begin{note}
不正確な数値がIEEE二進浮動小数点数値で表現している場合、
同じサイズの不正確な数値を単純にビットごとの比較で行う{\cf eqv?} の実装は
上記の定義によれば正しいものです。
\end{note}

\end{entry}


\begin{entry}{%
\proto{eq?}{ \vari{obj} \varii{obj}}{手続き}}

{\cf eq?} 手続きは{\cf eqv?} 手続きに似ています。
ただしいくつかの場合において{\cf eqv?} で検出可能なよりも細かい差異を識別する能力があります。
{\cf eqv?} が \schfalse{}を返す状況では同様に \schfalse{}を返さなければなりませんが、
{\cf eqv?} が \schtrue{}を返す状況でも \schfalse{}を返す場合があります。

\vest シンボル、ブーリアン、空リスト、ペア、レコード、
および空でない文字列、ベクタ、バイトベクタにおいて
{\cf eq?} と{\cf eqv?} は同じ動作をすることが保証されています。
手続きにおいては引数の場所の紐付けが同じ場合 \schtrue{}を返さなければなりません。
数値および文字においては{\cf eq?} の動作は処理系依存です。
ただし必ず真または偽のどちらかを返します。
空文字列、空ベクタ、空バイトベクタにおいても{\cf eq?} と{\cf eqv?} は異なる動作をして構いません。

\begin{scheme}
(eq? 'a 'a)                     \ev  \schtrue
(eq? '(a) '(a))                 \ev  \unspecified
(eq? (list 'a) (list 'a))       \ev  \schfalse
(eq? "a" "a")                   \ev  \unspecified
(eq? "" "")                     \ev  \unspecified
(eq? '() '())                   \ev  \schtrue
(eq? 2 2)                       \ev  \unspecified
(eq? \#\backwhack{}A \#\backwhack{}A) \ev  \unspecified
(eq? car car)                   \ev  \schtrue
(let ((n (+ 2 3)))
  (eq? n n))      \ev  \unspecified
(let ((x '(a)))
  (eq? x x))      \ev  \schtrue
(let ((x '\#()))
  (eq? x x))      \ev  \schtrue
(let ((p (lambda (x) x)))
  (eq? p p))      \ev  \schtrue%
\end{scheme}


\begin{rationale}
通常{\cf eq?} は{\cf eqv?} よりも非常に効率良く実装することができます。
例えば{\cf eqv?} がいくらか複雑な操作をする代わりに{\cf eq?} は単なるポインタの比較で済みます。
その理由のひとつは
2つの数値の{\cf eqv?} を計算することが常に定数時間でできるわけではないということです。
それに対してポインタ比較で実装された{\cf eq?} は必ず定数時間で処理できます。
\end{rationale}

\end{entry}


\begin{entry}{%
\proto{equal?}{ \vari{obj} \varii{obj}}{手続き}}

{\cf equal?} 手続きはペア、ベクタ、文字列、バイトベクタに適用された場合、それらを再帰的に比較します。
それらを(無限長の可能性もある)木構造に展開したとき
順序付きの木構造として({\cf equal?} の意味で)等しければ \schtrue{}を返し、
そうでなければ \schfalse{}を返します。
ブーリアン、シンボル、数値、文字、ポート、手続きおよび空リストに適用されたときは
{\cf eqv?} と同じです。
2つのオブジェクトが{\cf eqv?} であれば同様に{\cf equal?} でもなければなりません。
それ以外のすべての状況では
{\cf equal?} は \schtrue{}を返しても \schfalse{}を返しても構いません。
%% Note that records are {\cf equal?} if their record types are the same
%% and their correspondingly named fields are {\cf equal?}.

引数が循環データ構造であっても{\cf equal?} は必ず終了しなければなりません。

\begin{scheme}
(equal? 'a 'a)                  \ev  \schtrue
(equal? '(a) '(a))              \ev  \schtrue
(equal? '(a (b) c)
        '(a (b) c))             \ev  \schtrue
(equal? "abc" "abc")            \ev  \schtrue
(equal? 2 2)                    \ev  \schtrue
(equal? (make-vector 5 'a)
        (make-vector 5 'a))     \ev  \schtrue
(equal? '\#1=(a b . \#1\#)
        '\#2=(a b a b . \#2\#))    \ev  \schtrue
(equal? (lambda (x) x)
        (lambda (y) y))  \ev  \unspecified%
\end{scheme}

\begin{note}
大雑把に言うと、2つのオブジェクトが同じようにプリントされる場合、
一般的にそれらは{\cf equal?} です。
\end{note}



\end{entry}


\section{数値}
\label{numbersection}
\index{数値}

\newcommand{\type}[1]{{\it#1}}
\newcommand{\tupe}[1]{{#1}}

数学の数値と、
それをモデル化したSchemeの数値と、
それを表現するために使われる機械表現と、
数値を書くために使われる記法を区別することは重要です。
この報告書では
\type{数値}、\type{複素数}、\type{実数}、\type{有理数}、\type{整数}
といった型を数学の数値とSchemeの数値の両方を示すために用います。

\subsection{数値の型}
\label{numericaltypes}
\index{数値の型}

\vest 数学的には、各階がそれより上の階の部分型であるような塔に、数値を編成することができます。
\begin{tabbing}
\ \ \ \ \ \ \ \ \ \=\tupe{数値} \\
\> \tupe{複素数} \\
\> \tupe{実数} \\
\> \tupe{有理数} \\
\> \tupe{整数} 
\end{tabbing}

例えば3は整数です。
またそれゆえに3は有理数でもあり、実数でもあり、複素数でもあります。
これは3をモデル化したSchemeの数値においても同様です。
Schemeの数値では述語
\ide{number?}、\ide{complex?}、\ide{real?}、\ide{rational?} および\ide{integer?} 
によりこれらの型が定義されます。

数値の型とそのコンピュータにおける内部表現の間には単純な関係はありません。
ほとんどのScheme処理系では3の表現が少なくとも2種類は提供されていますが、
これらの異なる表現は同じ整数を表しています。

Schemeの数値計算では
数値を可能な限りその表現から独立した抽象的なデータとして扱います。
Scheme処理系は数値の内部表現を複数用いても構いませんが、
単純なプログラムを書くカジュアルプログラマーには判らないようにするべきです。

\subsection{正確性}

\mainindex{正確性} \label{exactly}

正確に表現された数値とそうでない可能性のある数値の区別は有用です。
例えばデータ構造へのインデックスは、
記号代数系における多項式の係数と同様に、
正確に判明している必要があります。
他方、計測の結果などは本質的に不正確であったり、
無理数などは有理数によって近似された不正確な近似値であったりします。
正確な数値が必要なところでの不正確な数値の使用を捕捉するために
Schemeでは正確な数値と不正確な数値を区別しています。
この区別は型の次元とは直交しています。

Schemeでは正確な定数として書かれたか、
\tupe{正確}な演算のみを用いて\tupe{正確}な数値から得られた場合、
その数値は\type{正確}です。
不正確な数値として書かれたか、
\tupe{不正確}な発生源から得られたか、
\tupe{不正確}な演算を用いて得られた場合、
その数値は\type{不正確}です。
従って数値の\tupe{不正確}性は伝染する性質を持ちます。
特に\defining{正確な複素数}は正確な実部と正確な虚部を持ち、
そうでないすべての複素数は\defining{不正確な複素数}です。

\vest 2つの処理系がある計算に対して
\tupe{不正確}な中間結果を生じずに\tupe{正確}な結果を生成する場合、
その2つの最終結果は数学的に等しくなります。
これは\tupe{不正確}な数値を生成する計算では一般的に成立しません。
浮動小数点計算のような近似的な手法が使われる場合があるためです。
しかし各々の処理系は数学上の理想的な結果に実用上十分近い結果を生成する義務があります。

\vest {\cf +} のような有理数の演算は
\tupe{正確}な引数が与えられると必ず\tupe{正確}な結果を生成します。
演算が\tupe{正確}な結果を生成することができない場合は
処理系の制限の違反を報告するか、
その結果を\tupe{不正確}な値に黙って変換しても構いません。
ただし{\cf (/~3~4)}が{\cf 0}を返すようなことは許容されません。
それは数学的に正しくありません。
\ref{restrictions}~節を参照してください。

\vest \ide{exact}を除き、
この節で説明されている演算は一般に、不正確な引数が与えられた場合は不正確な結果を返さなければなりません。
ただしその結果の値が引数の不正確性に影響を受けないことが保証できる場合は
\tupe{正確}な結果を返しても構いません。
例えば\tupe{正確}なゼロにはどんな数値を掛けても
\tupe{正確}なゼロの結果を生成することができます。
たとえそれが\tupe{不正確}な値であってもです。

具体的な例として
式 {\cf (* 0 +inf.0)} は
{\cf 0}を返しても構いませんし、
{\cf +nan.0} を返しても構いませんし、
不正確な数値をサポートしていない旨を報告しても構いませんし、
有理数でない実数をサポートしていない旨を報告しても構いませんし、
黙って死んでも構いませんし、
あるいは処理系固有の方法で騒がしくエラーを知らせても構いません。

\subsection{処理系の制限}

\index{処理系の制限}\label{restrictions}

\vest Scheme処理系は\ref{numericaltypes}~節で述べた部分型の塔全体を実装することは要求されていません。
しかし処理系の目的とScheme言語の精神の両方を満たす一貫性のある部分集合を実装しなければなりません。
例えば
すべての数値が\tupe{実数}である処理系、
\tupe{実数}以外の数値が常に\tupe{不正確}である処理系、
\tupe{正確}な数値が常に\tupe{整数}である処理系
などは依然として非常に有用でしょう。

\vest 処理系はこの節の要求を満たす限り、
任意の型の数値のある特定の範囲のみをサポートしても構いません。
任意の型の\tupe{正確}な数値のサポートされている範囲が
その型の\tupe{不正確}な数値のサポートされている範囲と異なっていても構いません。
例えば
すべての\tupe{不正確}な\tupe{実数}を表現するためにIEEE二進倍精度浮動小数点数値を採用している処理系では、
\tupe{不正確}な\tupe{実数}の範囲(ゆえに\tupe{不正確}な\tupe{整数}および\tupe{有理数}の範囲も)が
IEEE二進倍精度形式のダイナミックレンジに制限される一方、
\tupe{正確}な\tupe{整数}と\tupe{有理数}を事実上無制限の範囲でサポートしていて構いません。
さらに言えばそのような処理系では、この範囲制限に近づくにつれ
表現可能な\tupe{不正確}な\tupe{整数}および\tupe{有理数}の隙間が
非常に大きくなる可能性があります。

\vest Scheme処理系は
リスト、ベクタ、バイトベクタ、文字列のインデックスのために、
およびそれらの長さを計算した結果のために必要な数値の範囲全体に対して、
正確な整数をサポートしなければなりません。
\ide{length}、\ide{vector-length}、\ide{bytevector-length}および\ide{string-length}
手続きは正確な整数を返さなければなりません。
またインデックスとして正確な整数以外のものを使用することはエラーです。
さらにインデックス範囲内のあらゆる整数定数は、
この範囲外で適用されるいかなる処理系の制限にも関わらず、
正確な整数の構文で表現されていれば
正確な整数として読めなればなりません。
最後に、以下の一覧に記載されている手続きは
すべての引数が正確な整数でかつ数学的に期待される結果が処理系の範囲内の正確な整数で表現可能ならば
必ず正確な整数の結果を返さなければなりません。

\begin{scheme}
-                     *
+                     abs
ceiling               denominator
exact-integer-sqrt    expt
floor                 floor/
floor-quotient        floor-remainder
gcd                   lcm
max                   min
modulo                numerator
quotient              rationalize
remainder             round
square                truncate
truncate/             truncate-quotient
truncate-remainder
\end{scheme}

\vest 処理系は
事実上無制限の大きさと精度を持つ\tupe{正確}な\tupe{整数}と\tupe{正確}な\tupe{有理数}とサポートし、
上記の手続きと {\cf /} 手続きを\tupe{正確}な引数に対して必ず\tupe{正確}な結果を返すよう実装することが
推奨されますが要求されません。
これらの手続きはいずれも
\tupe{正確}な引数を与えられたとき\tupe{正確}な結果を返すことができなければ、
処理系の制限の違反を報告しても構いませんし、
黙ってその結果を\tupe{不正確}な数値に変換しても構いません。
そのような変換は後のエラーの原因となる可能性があります。
とはいえ\tupe{正確}な有理数を提供していない処理系は
処理系の制限を報告するよりも\tupe{不正確}な有理数を返す方が良いでしょう。

\vest 処理系は\tupe{不正確}な数値に対して浮動小数点や他の近似表現戦略を用いても構いません。
この報告書では IEEE 754 標準に従った浮動小数点表現を用いることが推奨されますが要求されません。
他の表現方法を用いる処理系ではこの浮動小数点標準を用いて達成可能な精度と同等かそれを超えることが
推奨されますが要求されません。
特にそのような処理系は IEEE 754-2008 の超越関数の記述に、とりわけ無限大とNaNに関して、従うべきです。

Schemeは数値に対する様々な書き方を規定していますが、
処理系はそれらの一部しかサポートしなくても構いません。
例えば数値がすべて\tupe{実数}である処理系は、複素数の直交座標表示や極座標表示をサポートする必要はありません。
処理系が\tupe{正確}な数値として表現できない\tupe{正確}な数値定数に出会った場合、
処理系の制限の違反を報告しても構いませんし、
黙って\tupe{不正確}な数値で表現しても構いません。

\subsection{処理系の拡張}
\index{処理系の拡張}

\vest 処理系は2つ以上の異なる精度の浮動小数点数値表現を提供していても構いません。
そのような処理系では不正確な結果は少なくともその演算に使われた
どの不正確引数も表現できるだけの精度を持っていなければなりません。
{\cf sqrt}のような潜在的に不正確な演算は
\tupe{正確}な引数を適用したときは\tupe{正確}な結果を生成することが望ましいものの、
もし\tupe{正確}な数値を演算して\tupe{不正確}な結果を生成する場合は
利用可能な中で最も精度の高い表現を用いなければなりません。
例えば {\cf (sqrt 4)} の値は{\cf 2}となるべきですが、
単精度と倍精度の浮動小数点数値を両方提供している処理系では、
後者を用いても構いませんが、前者を用いてはなりません。

その処理系で表現するには大きすぎる絶対値や仮数部を持つ
不正確な数値オブジェクトの使用を避けるのはプログラマーの責任です。

さらに処理系は\tupe{正の無限大}、\tupe{負の無限大}、\tupe{NaN}、および
\tupe{負のゼロ}といった特別な数値を区別しても構いません。

正の無限大は
有理数で表現可能ないかなる数値よりも大きな不定の値を表現する
不正確な実数(しかし有理数ではない)と見なされます。
負の無限大は
有理数で表現可能ないかなる数値よりも小さな不定の値を表現する
不正確な実数(しかし有理数ではない)と見なされます。

無限大の値にいかなる有限の実数を加算および乗算しても
その結果は(適切な符号の)無限大となります。
しかし正の無限大と負の無限大の和はNaNです。
正の無限大はゼロの逆数で、負の無限大は負のゼロの逆数です。
IEEE 754 に従った超越関数の動作は無限大に対して非常に複雑です。

NaNは任意の実数を表し得る不定の不正確な実数(しかし有理数ではない)と見なされます。
これには正負の無限大や、正の無限大より大きな値、負の無限大より小さな値も含まれます。
実数以外の数値をサポートしない処理系では
{\cf (sqrt -1.0)}や{\cf (asin 2.0)}のような実数でない値を表現するために
NaNを用いても構いません。

NaNはどのような数値と比較しても必ず偽になります。
NaN自身と比較しても同様です。
数値演算は引数のいずれかがNaNであればNaNを返します。
ただしそのNaNをどのような有理数と置き換えても結果は同じであると処理系が保証できる場合を除きます。
ゼロをゼロで除算すると、両方のゼロが正確でなければ、結果はNaNになります。

%% IEEE 754 specifies multiple NaN values.  Scheme generally does
%% not care if there is a single value (bit pattern) for NaN,
%% or if there are multiple values: if there are multiple NaN
%% values, or just one, they are all equivalent in terms of Scheme
%% computation.

負のゼロは不正確な実数であり、{\cf -0.0} と書かれ、
({\cf eqv?} の意味で) {\cf 0.0} と区別されます。
Scheme処理系は負のゼロを区別することは要求されません。
しかし区別する場合は超越関数の動作は IEEE 754 に従った複雑なものになります。
特に複素数と負のゼロを両方サポートするScheme処理系は、
複素対数関数の分岐を{\cf (imag-part (log -1.0-0.0i))}が$\pi$でなく$-\pi$となるように処理しなければなりません。

さらに言えば負のゼロの反数は通常のゼロであり、逆も同様です。
これは2つ以上の負のゼロの和が負であり、
負のゼロから(正の)ゼロを引いた結果も同様に負であることを暗黙に示しています。
しかし数値的な比較においては、負のゼロとゼロは等しいものとして扱われます。

ちなみに複素数の実部と虚部はいずれも
無限大、NaNまたは負のゼロを取ることができます。

\subsection{数値定数の構文}
\label{numbernotations}

数値の表現を書くための構文は\ref{numbersyntax}~節で正式に記述されています。
ちなみに数値定数では大文字小文字は区別されません。

数値は基数接頭辞を使うことで2進数、8進数、10進数または16進数で書くことができます。
基数接頭辞は %
{\cf \#b}\sharpindex{b} (2進数)、
{\cf \#o}\sharpindex{o} (8進数)、
{\cf \#d}\sharpindex{d} (10進数)、および %
{\cf \#x}\sharpindex{x} (16進数) です。
基数接頭辞が無ければ数値は10進数で表現されているとみなされます。

数値定数は接頭辞によって\tupe{正確}または\tupe{不正確}のいずれかを指定できます。
\tupe{正確}の接頭辞は {\cf \#e}\sharpindex{e}で
\tupe{不正確}の接頭辞は {\cf \#i}\sharpindex{i}です。
正確性接頭辞は基数接頭辞の前でも後でも構いません。
正確性接頭辞を付けずに数値の表現を書いた場合、
小数点または指数があればその定数は\tupe{不正確}であり、
そうでなければ\tupe{正確}です。

様々な精度の\tupe{不正確}な数値を持つシステムでは
定数の精度を指定できると有用です。
このため処理系は
\tupe{不正確}な表現の希望精度を指定する指数マーカーが書かれた数値定数
を受け付けても構いません。
その場合、文字{\cf e}の場所に、その代わりに
{\cf s}、{\cf f}、{\cf d}または{\cf l}を使うことができ、
それぞれ\var{短精度}、\var{単精度}、\var{倍精度}、\var{長精度}を意味しています。
デフォルトの精度は少なくとも\var{倍精度}以上でなければなりませんが、
処理系はこのデフォルトをユーザーの設定によって変更できても構いません。

\begin{scheme}
3.14159265358979F0
       {\rm 単精度に丸められる ---} 3.141593
0.6L0
       {\rm 長精度に拡張される ---} .600000000000000%
\end{scheme}

正の無限大、負の無限大、NaNはそれぞれ %
{\cf +inf.0}、{\cf -inf.0}、{\cf +nan.0} と書かれます。
NaNは {\cf -nan.0} と書かれることもあります。
書かれた表現の符号の使用は、もしNaN値の内部表現に符号があっても、それを反映する必要はありません。
処理系はこれらの数値をサポートすることは要求されていませんが、
サポートする場合は全般的に IEEE 754 に準拠しなければなりません。
ただし処理系は Signaling NaN をサポートしたり
異なる NaN を区別する方法を提供することは要求されません。

実数でない複素数を表記するための記法が2つあります。
ひとつは\defining{直交座標表示}で \var{a}{\cf +}\var{b}{\cf i} のように表記します。
ただし\var{a}は実部で\var{b}は虚部です。
もうひとつは\defining{極座標表示}で \var{r}{\cf @}$\theta$ のように表記します。
ただし\var{r}は動径で $\theta$ はラジアンで表した位相(偏角)です。
これらは
$a+b\mathrm{i} = r \cos\theta + (r \sin\theta) \mathrm{i}$
の関係があります。
\var{a}、\var{b}、\var{r}および $\theta$ はすべて実数です。


\subsection{数値演算}

数値ルーチンの引数の型の制限を指定するために使われる命名規約の要約については
\ref{typeconventions}~節を参照してください。
この節の例では\tupe{正確}な表記で書かれた数値定数は
いずれも実際に\tupe{正確}な数値を表しているものとみなしています。
また\tupe{不正確}な表記で書かれた数値定数は
精度を失うことなく表現されているものとみなしています。
そういった\tupe{不正確}な定数は、
不正確な数値の表現に IEEE 二進倍精度を採用している処理系で
その仮定が成立するように選ばれています。

\todo{Scheme provides the usual set of operations for manipulating
numbers, etc.}

\begin{entry}{%
\proto{number?}{ obj}{手続き}
\proto{complex?}{ obj}{手続き}
\proto{real?}{ obj}{手続き}
\proto{rational?}{ obj}{手続き}
\proto{integer?}{ obj}{手続き}}

これらの数値型の述語は数値でないものを含むいかなる型の引数にも適用できます。
オブジェクトがその名前の型であれば \schtrue{}を返し、
そうでなければ \schfalse{}を返します。
一般的に、ある型の述語がある数値に対して真であれば、
より上位の型の述語もすべてその数値に対して真となります。
従って、ある型の述語がある数値に対して偽であれば、
より下位の型の述語もすべてその数値に対して偽となります。

\vr{z}が複素数の場合
{\cf (real? \vr{z})} は {\cf (zero? (imag-part \vr{z}))} が真のときに限り真となります。
\vr{x}が不正確な実数である場合
{\cf (integer? \vr{x})} は {\cf (= \vr{x} (round \vr{x}))} が真のときに限り真となります。

{\cf +inf.0}、{\cf -inf.0} および {\cf +nan.0} は実数ですが有理数ではありません。

\begin{scheme}
(complex? 3+4i)         \ev  \schtrue
(complex? 3)            \ev  \schtrue
(real? 3)               \ev  \schtrue
(real? -2.5+0i)         \ev  \schtrue
(real? -2.5+0.0i)       \ev  \schfalse
(real? \#e1e10)          \ev  \schtrue
(real? +inf.0)           \ev  \schtrue
(real? +nan.0)           \ev  \schtrue
(rational? -inf.0)       \ev  \schfalse
(rational? 3.5)          \ev  \schtrue
(rational? 6/10)        \ev  \schtrue
(rational? 6/3)         \ev  \schtrue
(integer? 3+0i)         \ev  \schtrue
(integer? 3.0)          \ev  \schtrue
(integer? 8/4)          \ev  \schtrue%
\end{scheme}

\begin{note}
\tupe{不正確}な数値に対するこれらの型の述語の動作は信頼できません。
不正確さが結果に影響する場合があるためです。
\end{note}

\begin{note}
多くの処理系では\ide{complex?} 手続きは\ide{number?} と同じですが、
ある種の無理数を正確に表現できたり、
数値系を拡張して何らかの複素数でない数値をサポートしたりする、
普通でない処理系があるかもしれません。
\end{note}

\end{entry}

\begin{entry}{%
\proto{exact?}{ \vr{z}}{手続き}
\proto{inexact?}{ \vr{z}}{手続き}}

これらの数値述語は値の正確性を判定します。
どのようなSchemeの数値もこれらの述語のいずれか片方だけが真になります。

\begin{scheme}
(exact? 3.0)           \ev  \schfalse
(exact? \#e3.0)         \ev  \schtrue
(inexact? 3.)          \ev  \schtrue%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{exact-integer?}{ \vr{z}}{手続き}}

\vr{z}が\tupe{正確}かつ\tupe{整数}であれば \schtrue{}を返し、
そうでなければ \schfalse{}を返します。

\begin{scheme}
(exact-integer? 32) \ev \schtrue{}
(exact-integer? 32.0) \ev \schfalse{}
(exact-integer? 32/5) \ev \schfalse{}%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{finite?}{ \vr{z}}{inexactライブラリの手続き}}

{\cf finite?} 手続きは %
{\cf +inf.0}、{\cf -inf.0}、{\cf +nan.0} 以外のすべての実数
および実部と虚部が共に有限である複素数に対して \schtrue{}を返します。
そうでなければ \schfalse{}を返します。

\begin{scheme}
(finite? 3)         \ev  \schtrue
(finite? +inf.0)       \ev  \schfalse
(finite? 3.0+inf.0i)   \ev  \schfalse%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{infinite?}{ \vr{z}}{inexactライブラリの手続き}}

{\cf infinite?} 手続きは %
{\cf +inf.0}、{\cf -inf.0} および
実部または虚部または両方が無限大である複素数に対して \schtrue{}を返します。
そうでなければ \schfalse{}を返します。

\begin{scheme}
(infinite? 3)         \ev  \schfalse
(infinite? +inf.0)       \ev  \schtrue
(infinite? +nan.0)       \ev  \schfalse
(infinite? 3.0+inf.0i)   \ev  \schtrue%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{nan?}{ \vr{z}}{inexactライブラリの手続き}}

{\cf nan?} 手続きは {\cf +nan.0} および
実部または虚部または両方が {\cf +nan.0} である複素数に対して \schtrue{}を返します。
そうでなければ \schfalse{}を返します。

\begin{scheme}
(nan? +nan.0)          \ev  \schtrue
(nan? 32)              \ev  \schfalse
(nan? +nan.0+5.0i)     \ev  \schtrue
(nan? 1+2i)            \ev  \schfalse%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{=}{ \vri{z} \vrii{z} \vriii{z} \dotsfoo}{手続き}
\proto{<}{ \vri{x} \vrii{x} \vriii{x} \dotsfoo}{手続き}
\proto{>}{ \vri{x} \vrii{x} \vriii{x} \dotsfoo}{手続き}
\proto{<=}{ \vri{x} \vrii{x} \vriii{x} \dotsfoo}{手続き}
\proto{>=}{ \vri{x} \vrii{x} \vriii{x} \dotsfoo}{手続き}}

これらの手続きは引数がそれぞれ
等しい、単調に増加している、単調に減少している、
単調に減少していない、単調に増加していない場合に %
\schtrue{}を返し、そうでなければ \schfalse{}を返します。
引数のいずれかが {\cf +nan.0} の場合はどの手続きも \schfalse{}を返します。
これらは不正確なゼロと不正確な負のゼロを区別しません。

これらの手続きは推移的であることが要求されます。

\begin{note}
いずれかの引数が不正確であればすべての引数を不正確な数値に変換する、
というような実装手法は推移的ではありません。
例えば、{\cf big}を{\cf (expt 2 1000)}として、
その{\cf big}が正確であり、
不正確な数値は64ビットのIEEE二進浮動小数点数で表現されているとしましょう。
その場合、この実装手法では大きな整数のIEEE表現の制限のため
{\cf (= (- big 1) (inexact big))} と {\cf (= (inexact big) (+ big 1))} が共に真でありながら
{\cf (= (- big 1) (+ big 1))} は偽となってしまうでしょう。
不正確な数値をそれと({\cf =} の意味で)同じ正確な数値に変換すればこの問題を回避できますが、
無限大に対して特別な配慮が必要となります。
\end{note}

\begin{note}
これらの述語を用いて\tupe{不正確}な数値を比較することはエラーではありませんが、
わずかな不正確さが結果に影響を及ぼす可能性があるためその結果は信頼できません。
\ide{=} や\ide{zero?} の場合、特にそうです。
疑わしい場合は数値解析の専門家に相談してください。

\end{note}

\end{entry}

\begin{entry}{%
\proto{zero?}{ \vr{z}}{手続き}
\proto{positive?}{ \vr{x}}{手続き}
\proto{negative?}{ \vr{x}}{手続き}
\proto{odd?}{ \vr{n}}{手続き}
\proto{even?}{ \vr{n}}{手続き}}

これらの数値述語は特定の性質を判定し、\schtrue{} または \schfalse を返します。
上記の注意点も参照してください。

\end{entry}

\begin{entry}{%
\proto{max}{ \vri{x} \vrii{x} \dotsfoo}{手続き}
\proto{min}{ \vri{x} \vrii{x} \dotsfoo}{手続き}}

これらの手続きは引数の最大値または最小値を返します。

\begin{scheme}
(max 3 4)              \ev  4    ; 正確
(max 3.9 4)            \ev  4.0  ; 不正確%
\end{scheme}

\begin{note}
いずれかの引数が不正確であれば結果も不正確になります
(その不正確さが結果に影響しないほど大きくないことが保証できる場合は除きますが、
そのようなことは普通でない処理系にのみ可能なことです)。
{\cf min}または{\cf max}を使って正確性が混在した数値を比較し、
その結果の数値を正確さを犠牲にすることなく不正確な数値で表現することができない場合、
これらの手続きは処理系の制限の違反を報告しても構いません。
\end{note}

\end{entry}


\begin{entry}{%
\proto{+}{ \vri{z} \dotsfoo}{手続き}
\proto{*}{ \vri{z} \dotsfoo}{手続き}}

これらの手続きは引数の和または積を返します。

\begin{scheme}
(+ 3 4)                 \ev  7
(+ 3)                   \ev  3
(+)                     \ev  0
(* 4)                   \ev  4
(*)                     \ev  1%
\end{scheme} 
 
\end{entry}


\begin{entry}{%
\proto{-}{ \vr{z}}{手続き}
\rproto{-}{ \vri{z} \vrii{z} \dotsfoo}{手続き}
\proto{/}{ \vr{z}}{手続き}
\rproto{/}{ \vri{z} \vrii{z} \dotsfoo}{手続き}}

引数がふたつ以上の場合、
これらの手続きは左結合で引数の差または商を返します。
しかし引数がひとつの場合は、
その引数の反数または逆数を返します。

{\cf /} の第2引数以降のいずれかが正確なゼロの場合はエラーです。
第1引数が正確なゼロであり他の引数がいずれもNaNでなければ、
正確なゼロを返しても構いません。

\begin{scheme}
(- 3 4)                 \ev  -1
(- 3 4 5)               \ev  -6
(- 3)                   \ev  -3
(/ 3 4 5)               \ev  3/20
(/ 3)                   \ev  1/3%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{abs}{ x}{手続き}}

{\cf abs}手続きは引数の絶対値を返します。
\begin{scheme}
(abs -7)                \ev  7%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{floor/}{ \vri{n} \vrii{n}}{手続き}
\proto{floor-quotient}{ \vri{n} \vrii{n}}{手続き}
\proto{floor-remainder}{ \vri{n} \vrii{n}}{手続き}
\proto{truncate/}{ \vri{n} \vrii{n}}{手続き}
\proto{truncate-quotient}{ \vri{n} \vrii{n}}{手続き}
\proto{truncate-remainder}{ \vri{n} \vrii{n}}{手続き}}

これらの手続きは数論的な(整数の)除算を実装します。
\vrii{n}がゼロの場合はエラーです。
{\cf /} で終わる手続きはふたつの整数を返し、それ以外の手続きはひとつの整数を返します。
どの手続きも
$\vri{n} = \vrii{n} \vr{n_q} + \vr{n_r}$
が成り立つような商\vr{n_q}と剰余\vr{n_r}を計算します。
それぞれの除算演算子に対して3つの手続きが以下のように定義されます。

\begin{scheme}
(\hyper{operator}/ \vri{n} \vrii{n})             \ev \vr{n_q} \vr{n_r}
(\hyper{operator}-quotient \vri{n} \vrii{n})     \ev \vr{n_q}
(\hyper{operator}-remainder \vri{n} \vrii{n})    \ev \vr{n_r}%
\end{scheme}

剰余\vr{n_r}は整数\vr{n_q}が決まると自動的に
$\vr{n_r} = \vri{n} - \vrii{n} \vr{n_q}$
のように決定されます。
\vr{n_q}の決め方は各演算子によって異なります。

\begin{tabular}{l l}
\texttt{floor}     & $\vr{n_q} = \lfloor\vri{n} / \vrii{n}\rfloor$ \\
\texttt{truncate}  & $\vr{n_q} = \text{truncate}(\vri{n} / \vrii{n})$ \\
\end{tabular}

いずれの演算子も、またいずれの整数\vri{n}および\vrii{n}(ただし\vrii{n}がゼロでない場合)においても、
以下が成り立ちます。
\begin{scheme}
     (= \vri{n} (+ (* \vrii{n} (\hyper{operator}-quotient \vri{n} \vrii{n}))
           (\hyper{operator}-remainder \vri{n} \vrii{n})))
                                 \ev  \schtrue%
\end{scheme}
ただしすべての数値が正確な計算によって得られる場合に限ります。

例:

\begin{scheme}
(floor/ 5 2)         \ev 2 1
(floor/ -5 2)        \ev -3 1
(floor/ 5 -2)        \ev -3 -1
(floor/ -5 -2)       \ev 2 -1
(truncate/ 5 2)      \ev 2 1
(truncate/ -5 2)     \ev -2 -1
(truncate/ 5 -2)     \ev -2 1
(truncate/ -5 -2)    \ev 2 -1
(truncate/ -5.0 -2)  \ev 2.0 -1.0%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{quotient}{ \vri{n} \vrii{n}}{手続き}
\proto{remainder}{ \vri{n} \vrii{n}}{手続き}
\proto{modulo}{ \vri{n} \vrii{n}}{手続き}}

{\cf quotient}および{\cf remainder}手続きはそれぞれ
{\cf truncate-\+quotient}および{\cf truncate-\+remainder}と同等であり、
{\cf modulo}は{\cf floor-\+remainder}と同等です。

\begin{note}
これらの手続きは以前のバージョンの報告書との後方互換性のために提供されています。
\end{note}
\end{entry}

\begin{entry}{%
\proto{gcd}{ \vri{n} \dotsfoo}{手続き}
\proto{lcm}{ \vri{n} \dotsfoo}{手続き}}

これらの手続きは引数の最大公約数または最小公倍数を返します。
結果は必ず非負です。

\begin{scheme}
(gcd 32 -36)            \ev  4
(gcd)                   \ev  0
(lcm 32 -36)            \ev  288
(lcm 32.0 -36)          \ev  288.0  ; 不正確
(lcm)                   \ev  1%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{numerator}{ \vr{q}}{手続き}
\proto{denominator}{ \vr{q}}{手続き}}

これらの手続きは引数の分子または分母を返します。
結果は引数が既約分数として表現されているかのように計算されます。
分母は必ず正です。
ゼロの分母は1であると定義されます。
\todo{More description and examples needed.}
\begin{scheme}
(numerator (/ 6 4))  \ev  3
(denominator (/ 6 4))  \ev  2
(denominator
  (inexact (/ 6 4))) \ev 2.0%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{floor}{ x}{手続き}
\proto{ceiling}{ x}{手続き}
\proto{truncate}{ x}{手続き}
\proto{round}{ x}{手続き}
}

これらの手続きは整数を返します。
\vest {\cf floor}手続きは\vr{x}より大きくない最も大きな整数を返します。
{\cf ceiling}手続きは\vr{x}より小さくない最も小さな整数を返します。
{\cf truncate}手続きは絶対値が\vr{x}の絶対値より大きくない\vr{x}に最も近い整数を返します。
{\cf round}手続きは\vr{x}に最も近い整数を返しますが、
\vr{x}がふたつの整数の中央のときは偶数側に丸めます。

\begin{rationale}
{\cf round}手続きの偶数丸めは IEEE 754 IEEE浮動小数点標準で規定されている
デフォルトの丸めモードとの一貫性のためです。
\end{rationale}

\begin{note}
これらの手続きの引数が不正確な場合、結果も不正確になります。
正確な値が必要であれば結果を{\cf exact}手続きに渡しても構いません。
引数が無限大またはNaNの場合はそのまま返されます。
\end{note}

\begin{scheme}
(floor -4.3)          \ev  -5.0
(ceiling -4.3)        \ev  -4.0
(truncate -4.3)       \ev  -4.0
(round -4.3)          \ev  -4.0

(floor 3.5)           \ev  3.0
(ceiling 3.5)         \ev  4.0
(truncate 3.5)        \ev  3.0
(round 3.5)           \ev  4.0  ; 不正確

(round 7/2)           \ev  4    ; 正確
(round 7)             \ev  7%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{rationalize}{ x y}{手続き}
}

{\cf rationalize}手続きは\vr{x}から距離\vr{y}以内の{\em 最も簡単}な有理数を返します。
ある有理数 $r_1$ が別の有理数 $r_2$ より{\em 簡単}であるとは、\mainindex{最も簡単な有理数}
$r_1 = p_1/q_1$ および $r_2 = p_2/q_2$ (いずれも既約) としたとき、
$|p_1| \leq |p_2|$ かつ $|q_1| \leq |q_2|$ である場合のことを言います。
つまり $3/5$ は $4/7$ より簡単です。
すべての有理数がこの順序付けで比較できるわけではありませんが
($2/7$ と $3/5$ を考えてみてください)、
どのような区間においても他のすべての有理数より簡単な有理数というものがひとつ存在しています
($2/7$ と $3/5$ の間にはより簡単な $2/5$ があります)。
ちなみにすべての有理数のうち最も簡単なものは $0 = 0/1$ です。

\begin{scheme}
(rationalize
  (exact .3) 1/10)  \ev 1/3    ; 正確
(rationalize .3 1/10)        \ev \#i1/3  ; 不正確%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{exp}{ \vr{z}}{inexactライブラリの手続き}
\proto{log}{ \vr{z}}{inexactライブラリの手続き}
\rproto{log}{ \vri{z} \vrii{z}}{inexactライブラリの手続き}
\proto{sin}{ \vr{z}}{inexactライブラリの手続き}
\proto{cos}{ \vr{z}}{inexactライブラリの手続き}
\proto{tan}{ \vr{z}}{inexactライブラリの手続き}
\proto{asin}{ \vr{z}}{inexactライブラリの手続き}
\proto{acos}{ \vr{z}}{inexactライブラリの手続き}
\proto{atan}{ \vr{z}}{inexactライブラリの手続き}
\rproto{atan}{ \vr{y} \vr{x}}{inexactライブラリの手続き}}

これらの手続きは通常の超越関数を計算します。
{\cf log}手続きは引数がひとつの場合は\vr{z}の自然対数を計算し(10を底とする対数ではありません)、
引数がふたつの場合は\vrii{z}を底とする\vri{z}の対数を計算します。
{\cf asin}、{\cf acos}、{\cf atan}手続きはそれぞれ
逆正弦($\sin^{-1}$)、逆余弦($\cos^{-1}$)、逆正接($\tan^{-1}$)を計算します。
{\cf atan}の2引数バージョンは
{\tt (angle (make-rectangular \vr{x} \vr{y}))}
(後述)を計算します(処理系が複素数をサポートしていない場合でも)。

一般的に対数、逆正弦、逆余弦、逆正接といった数学関数は多値関数として定義されます。
$\log z$ の値はその虚部が $-\pi$ ({\cf -0.0} が区別されている場合は含まれず、そうでなければ含まれる)
から $\pi$ (常に含まれる) の範囲にある場合は1に定義されます。
$\log 0$の値は数学的に未定義です。
$\log$をこのように定義すると
$\sin^{-1} z$、$\cos^{-1} z$、$\tan^{-1} z$は以下の式に従います。
$$\sin^{-1} z = -i \log (i z + \sqrt{1 - z^2})$$
$$\cos^{-1} z = \pi / 2 - \sin^{-1} z$$
$$\tan^{-1} z = (\log (1 + i z) - \log (1 - i z)) / (2 i)$$

しかし処理系が無限大 (および {\cf -0.0}) をサポートしていれば、
{\cf (log 0.0)} は {\cf -inf.0} を返します
(そして {\cf (log -0.0)} は {\cf -inf.0+$\pi$i} を返します)。

\texttt{({\cf atan} \var{y} \var{x})} の範囲は以下の表のようになります。
星印 (*) は負のゼロを区別する処理系に適用される項目であることを示しています。

\begin{center}
\begin{tabular}{clll}
& $y$の条件 & $x$の条件 & 結果$r$の範囲\\\hline
& $y = 0.0$ & $x > 0.0$ & $0.0$\\
$\ast$ & $y = +0.0$  & $x > 0.0$ & $+0.0$\\
$\ast$ & $y = -0.0$ & $x > 0.0$ & $-0.0$\\
& $y > 0.0$ & $x > 0.0$ & $0.0 < r < \frac{\pi}{2}$\\
& $y > 0.0$ & $x = 0.0$ & $\frac{\pi}{2}$\\
& $y > 0.0$ & $x < 0.0$ & $\frac{\pi}{2} < r < \pi$\\
& $y = 0.0$ & $x < 0$ & $\pi$\\
$\ast$ & $y = +0.0$ & $x < 0.0$ & $\pi$\\
$\ast$ & $y = -0.0$ & $x < 0.0$ & $-\pi$\\
&$y < 0.0$ & $x < 0.0$ & $-\pi< r< -\frac{\pi}{2}$\\
&$y < 0.0$ & $x = 0.0$ & $-\frac{\pi}{2}$\\
&$y < 0.0$ & $x > 0.0$ & $-\frac{\pi}{2} < r< 0.0$\\
&$y = 0.0$ & $x = 0.0$ & 未定義\\
$\ast$& $y = +0.0$ & $x = +0.0$ & $+0.0$\\
$\ast$& $y = -0.0$ & $x = +0.0$& $-0.0$\\
$\ast$& $y = +0.0$ & $x = -0.0$ & $\pi$\\
$\ast$& $y = -0.0$ & $x = -0.0$ & $-\pi$\\
$\ast$& $y = +0.0$ & $x = 0$ & $\frac{\pi}{2}$\\
$\ast$& $y = -0.0$ & $x = 0$    & $-\frac{\pi}{2}$
\end{tabular}
\end{center}

上記の仕様は\cite{CLtL}に従ったもので、それは\cite{Penfield81}から引用されたものです。
分岐条件や境界条件およびこれらの関数の実装についてのより詳細な議論は
これらの情報源を参照してください。
可能であればこれらの手続きは実数の引数から実数の結果を生成します。


\end{entry}

\begin{entry}{%
\proto{square}{ \vr{z}}{手続き}}

\vr{z}の平方を返します。
これは \texttt{({\cf *} \var{z} \var{z})} と同等です。
\begin{scheme}
(square 42)       \ev 1764
(square 2.0)     \ev 4.0%
\end{scheme}

%% Removing this since it's inaccurate and not reflective of the
%% real rationale most members listed.  We need a proper rationale
%% document to go into detail.
%% \begin{rationale}
%% Taking the square of a large integer is more efficient than
%% multiplying arbitrary integers, and floating-point processors often
%% have a primitive square operator.
%% \end{rationale}

\end{entry}

\begin{entry}{%
\proto{sqrt}{ \vr{z}}{inexactライブラリの手続き}}

\vr{z}の正の平方根を返します。
結果は正の実部を持つか、ゼロの実部と非負の虚部を持つかのいずれかです。

\begin{scheme}
(sqrt 9)  \ev 3
(sqrt -1) \ev +i%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{exact-integer-sqrt}{ k}{手続き}}

$\var{k} = s^2 + r$ および $\var{k} < (s+1)^2$ が成り立つ
ふたつの非負の正確な整数$s$および$r$を返します。

\begin{scheme}
(exact-integer-sqrt 4) \ev 2 0
(exact-integer-sqrt 5) \ev 2 1%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{expt}{ \vri{z} \vrii{z}}{手続き}}

\vri{z}の\vrii{z}乗を返します。
\vri{z}がゼロでなければ、これは $${z_1}^{z_2} = e^{z_2 \log {z_1}}$$ です。
$0^z$ の値は{\cf (zero? z)}の場合$1$、
{\cf (real-part z)}が正の場合$0$で、
それ以外はエラーです。
$0.0^z$の場合も同様ですが不正確な結果になります。
\end{entry}




\begin{entry}{%
\proto{make-rectangular}{ \vri{x} \vrii{x}}{complexライブラリの手続き}
\proto{make-polar}{ \vriii{x} \vriv{x}}{complexライブラリの手続き}
\proto{real-part}{ \vr{z}}{complexライブラリの手続き}
\proto{imag-part}{ \vr{z}}{complexライブラリの手続き}
\proto{magnitude}{ \vr{z}}{complexライブラリの手続き}
\proto{angle}{ \vr{z}}{complexライブラリの手続き}}

実数\vri{x}、\vrii{x}、\vriii{x}、\vriv{x}および
複素数\vr{z}について
 $$ \vr{z} = \vri{x} + \vrii{x}\hbox{$i$}
 = \vriii{x} \cdot e^{i x_4}$$
が成り立つ場合、以下がすべて成り立ちます。
\begin{scheme}
(make-rectangular \vri{x} \vrii{x}) \ev \vr{z}
(make-polar \vriii{x} \vriv{x})     \ev \vr{z}
(real-part \vr{z})                  \ev \vri{x}
(imag-part \vr{z})                  \ev \vrii{x}
(magnitude \vr{z})                  \ev $|\vriii{x}|$
(angle \vr{z})                      \ev $x_{angle}$%
\end{scheme}
ただし $-\pi \le x_{angle} \le \pi$ かつ $x_{angle} = \vriv{x} + 2\pi n$
($n$は整数)とします。

{\cf make-polar}は引数が正確であっても不正確な複素数を返して構いません。
{\cf real-part}および{\cf imag-part}手続きは不正確な複素数に適用した場合でも、
{\cf make-rectangular}に渡された対応する引数が正確であったならば、正確な実数を返して構いません。


\begin{rationale}
{\cf magnitude}手続きは実数の引数に対しては\ide{abs}と同じですが、
{\cf abs}はbaseライブラリの手続きであるのに対し、
{\cf magnitude}はオプショナルなcomplexライブラリの手続きとなっています。
\end{rationale}

\end{entry}


\begin{entry}{%
\proto{inexact}{ \vr{z}}{手続き}
\proto{exact}{ \vr{z}}{手続き}}

手続き{\cf inexact}は\vr{z}の\tupe{不正確}な表現を返します。
戻り値は数値的に引数に最も近い\tupe{不正確}な数値です。
不正確な引数に対してはその引数と同じ値を返します。
正確な複素数に対しては引数の実部と虚部をそれぞれ{\cf inexact}に適用した結果を
実部と虚部に持つ複素数を返します。
\tupe{正確}な引数に十分近い({\cf =} の意味で)同等な\tupe{不正確}な値がない場合は、
処理系の制限の違反を報告しても構いません。

手続き{\cf exact}は\vr{z}の\tupe{正確}な表現を返します。
戻り値は数値的に引数に最も近い\tupe{正確}な値です。
正確な引数に対してはその引数と同じ値を返します。
整数でない不正確な実数の引数に対しては有理数による近似値を返しても構いませんし、
処理系の制限の違反を報告しても構いません。
不正確な複素数の引数に対しては引数の実部と虚部をそれぞれ{\cf exact}に適用した結果を
実部と虚部に持つ複素数を返します。
\tupe{不正確}な引数に十分近い({\cf =} の意味で)同等な\tupe{正確}な値がない場合は、
処理系の制限の違反を報告しても構いません。

これらの手続きは処理系依存の範囲内の\tupe{正確}な整数と\tupe{不正確}な整数に対して
自然な1対1の対応関係を実装しています。
\ref{restrictions}~節を参照してください。

\begin{note}
これらの手続きは\rfivers{}ではそれぞれ
{\cf exact->inexact}および{\cf inexact->exact}として知られていました。
しかしこれらは常にどちらの正確性の引数も受け付けていました。
新しい名前は\rsixrs{}と互換性があると同時により明確で短いものです。
\end{note}

\end{entry}

\medskip

\subsection{数値の入出力}

\begin{entry}{%
\proto{number->string}{ z}{手続き}
\rproto{number->string}{ z radix}{手続き}}

\domain{\vr{radix}が2、8、10、16のいずれでもなければエラーです。}
手続き{\cf number\coerce{}string}は数値と基数を取り、
以下の式を満たすような指定した基数における指定した数値の外部表現を
文字列として返します。
\begin{scheme}
(let ((number \vr{number})
      (radix \vr{radix}))
  (eqv? number
        (string->number (number->string number
                                        radix)
                        radix)))%
\end{scheme}
この式を満たせる結果が存在しない場合はエラーです。
\vr{radix}を省略した場合のデフォルト値は10です。

\vr{z}が不正確で、基数が10で、かつ小数点を含む結果によって上記の式が満たせる場合、
その結果は小数点を含む
上記の式を満たすために必要な最小限の桁数(指数と末尾のゼロを除く)
で表現されます~\cite{howtoprint,howtoread}。
そうでない場合、結果の書式は規定されていません。

{\cf number\coerce{}string}の戻り値が明示的な基数接頭辞を持つことはありません。

\begin{note}
エラーの状況は\vr{z}が複素数でないか、
実部または虚部が有理数でない複素数の場合にのみ発生する可能性があります。
\end{note}

\begin{rationale}
\vr{z}が不正確な数値かつ基数が10の場合、
上記の式は通常、小数点を含む結果によって満たすことができます。
規定されていない結果は
無限大、NaN、あるいは普通でない表現の場合に許容されます。
\end{rationale}

\end{entry}


\begin{entry}{%
\proto{string->number}{ string}{手続き}
\rproto{string->number}{ string radix}{手続き}}


\vr{string}によって表された数値の最大限に正確な表現を返します。
\domain{\vr{radix}が2、8、10、16のいずれでもなければエラーです。}
\vr{radix}が指定された場合はそれがデフォルトの基数となります。
これは\vr{string}に明示的な基数接頭辞があればオーバーライドされます
(例えば {\tt "\#o177"})。
\vr{radix}が指定されなかった場合デフォルトの基数は10です。
\vr{string}が構文的に有効な数値の表記でない場合、
または結果の数値を処理系が表現できない場合、
{\cf string->number}は \schfalse{}を返します。
\vr{string}の中身を理由にエラーが通知されることはありません。

\begin{scheme}
(string->number "100")        \ev  100
(string->number "100" 16)     \ev  256
(string->number "1e2")        \ev  100.0%
\end{scheme}

\begin{note}
処理系は{\cf string->number}の定義域を以下のように制限しても構いません。
処理系のサポートする数値が実数のみの場合、
\vr{string}が極座標表示または直交座標表示の複素数であれば
{\cf string->number}は \schfalse{}を返すことが許容されます。
数値が整数のみの場合、
分数表記が使われたら \schfalse{}を返しても構いません。
正確な数値のみの場合、
指数マーカーや明示的な正確性接頭辞が使われたら \schfalse{}を返しても構いません。
不正確な数値が整数のみの場合、
小数点が使われたら \schfalse{}を返しても構いません。

内部の数値処理、I/O、プログラム処理の間で一貫性を維持するため、
ある特定の処理系が{\cf string->number}に対して用いるルールは、
{\cf read}やプログラムの読み込みルーチンにも適用されなければなりません。
従って\vr{string}が明示的な基数接頭辞を持っている場合は %
\schfalse{}を返しても良いという\rfivers{}の記述は廃止されました。
\end{note}

\end{entry}

\section{ブーリアン}
\label{booleansection}

真および偽に対する標準のブーリアンオブジェクトは %
\schtrue{}および \schfalse{}のように書きます。\sharpindex{t}\sharpindex{f}  
代わりに、それぞれ \sharptrue{}および \sharpfalse{}と書くこともできます。
しかし本当に重要な点は、Schemeの条件式
({\cf if}、{\cf cond}、{\cf and}、{\cf or}、{\cf when}、{\cf unless}、{\cf do})
が真\index{真}または偽\index{偽}として扱うオブジェクトです。
用語「真の値」\index{真}(または単に「真」)は
条件式において真として扱われるあらゆるオブジェクトを意味し、
用語「偽の値」\index{偽}(または「偽」)は
条件式において偽として扱われるあらゆるオブジェクトを意味します。

\vest すべてのSchemeの値のうち %
\schfalse{}のみが条件式において偽とみなされます。
\schtrue{}を含め
それ以外のすべてのSchemeの値は真とみなされます。

\begin{note}
他のLisp方言と異なり、
Schemeでは \schfalse{}と空リスト\index{空リスト}はお互いに区別され、
またシンボル\ide{nil}とも区別されます。
\end{note}

\vest ブーリアン定数はそれ自身に評価されるためプログラム中でquoteする必要はありません。

\begin{scheme}
\schtrue         \ev  \schtrue
\schfalse        \ev  \schfalse
'\schfalse       \ev  \schfalse%
\end{scheme}


\begin{entry}{%
\proto{not}{ obj}{手続き}}

{\cf not}手続きは
\var{obj}が偽の場合 \schtrue{}を返し、
そうでなければ \schfalse{}を返します。

\begin{scheme}
(not \schtrue)   \ev  \schfalse
(not 3)          \ev  \schfalse
(not (list 3))   \ev  \schfalse
(not \schfalse)  \ev  \schtrue
(not '())        \ev  \schfalse
(not (list))     \ev  \schfalse
(not 'nil)       \ev  \schfalse%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{boolean?}{ obj}{手続き}}

{\cf boolean?} 述語は\var{obj}が \schtrue{}または \schfalse{}の場合 %
\schtrue{}を返し、そうでなければ \schfalse{}を返します。

\begin{scheme}
(boolean? \schfalse)  \ev  \schtrue
(boolean? 0)          \ev  \schfalse
(boolean? '())        \ev  \schfalse%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{boolean=?}{ \vari{boolean} \varii{boolean} \variii{boolean} \dotsfoo}{手続き}}

引数がすべてブーリアンで、
すべて \schtrue{}であるかすべて \schfalse{}であれば、
\schtrue{}を返します。

\end{entry}
 
\section{ペアとリスト}
\label{listsection}

\defining{ペア} (\defining{ドット対}と呼ばれることもあります)
は(歴史的理由により) carおよびcdrという名前で呼ばれるふたつのフィールドを持つレコード構造です。
ペアは手続き{\cf cons}で作ることができます。
手続き{\cf car}および{\cf cdr}でcarおよびcdrフィールドにアクセスできます。
手続き{\cf set-car!} および{\cf set-cdr!} でcarおよびcdrフィールドに代入できます。

ペアは主にリストを表現するために使われます。
\defining{リスト}は
空リスト\index{空リスト}またはcdrがリストであるペアとして
再帰的に定義できます。
より正確に言うとリストの集合は以下を満たす最小の集合\var{X}として定義されます。

\begin{itemize}
\item 空リストは\var{X}の要素です。
\item \var{リスト}が\var{X}の要素であれば、
      cdrフィールドに\var{リスト}を持つペアもすべて\var{X}の要素です。
\end{itemize}

リストを構成するペアのcarフィールドのオブジェクトはそのリストの要素です。
例えば2要素のリストとは、ペアであって、そのペアのcarが最初の要素、そのペアのcdrがまたペアであって、
そのペアのcarが2番目の要素、そのペアのcdrが空リストであるようなものを言います。
リストの長さは要素の数であり、ペアの数と同じです。

空リスト\mainindex{空リスト}は独立した型を持つ特殊なオブジェクトです。
それはペアではなく、要素を持たず、その長さはゼロです。

\begin{note}
上記の定義は、すべてのリストが有限の長さを持ち、空リストで終端することを暗黙に示しています。
\end{note}

Schemeのペアの最も汎用的な表記 (外部表現) は
\hbox{\cf (\vari{c} .\ \varii{c})}
のような「ドット」記法です。
ただし\vari{c}はcarフィールドの値で、\varii{c}はcdrフィールドの値です。
例えば {\cf (4 .\ 5)} はcarが4でありcdrが5であるペアです。
{\cf (4 .\ 5)} はペアの外部表現であって、ペアに評価される式ではないことに注意してください。

リストに対してはより流線的な記法が使われます。
単純にリストの要素をスペースで区切って括弧で囲みます。
空リスト\index{空リスト}は {\tt()} と書きます。
例を挙げます。

\begin{scheme}
(a b c d e)%
\end{scheme}

これはシンボルのリストの表記で、以下と同等です。

\begin{scheme}
(a . (b . (c . (d . (e . ())))))%
\end{scheme}

空リストで終端しないペアのチェーンは\defining{非真正リスト}と呼ばれます。
非真正リストはリストではないことに注意してください。
リストとドット記法を組み合わせて非真正リストを表現することができます。

\begin{scheme}
(a b c . d)%
\end{scheme}

これは以下と同等です。

\begin{scheme}
(a . (b . (c . d)))%
\end{scheme}

与えられたペアがリストであるかどうかはcdrフィールドに何が格納されているかに依ります。
\ide{set-cdr!} 手続きを使うと、
ある瞬間にはリストであったオブジェクトが次の瞬間にはそうでなくなる場合があります。

\begin{scheme}
(define x (list 'a 'b 'c))
(define y x)
y                       \ev  (a b c)
(list? y)               \ev  \schtrue
(set-cdr! x 4)          \ev  \unspecified
x                       \ev  (a . 4)
(eqv? x y)              \ev  \schtrue
y                       \ev  (a . 4)
(list? y)               \ev  \schfalse
(set-cdr! x x)          \ev  \unspecified
(list? x)               \ev  \schfalse%
\end{scheme}

リテラル式や\ide{read}手続きによって読み込んだオブジェクトの表現の中では %
\singlequote\hyper{datum}\schindex{'}、
\backquote\hyper{datum}、
{\tt,}\hyper{datum}\schindex{,}、
{\tt,@}\hyper{datum}
といった形は最初の要素がそれぞれシンボル
\ide{quote}、\ide{quasiquote}、\hbox{\ide{unquote}}、\ide{unquote-splicing}
である2要素のリストを表します。
それぞれの2番目の要素は\hyper{datum}です。
この規約により任意のSchemeプログラムをリストとして表現できます。
つまりSchemeの文法によれば、
すべての\meta{expression}は\meta{datum}でもある、
ということです(\ref{datum}~節を参照)。
特に、これにより{\cf read}手続きでSchemeのプログラムをパースできるようになっています。
\ref{externalreps}~節も参照してください。
 

\begin{entry}{%
\proto{pair?}{ obj}{手続き}}

{\cf pair?} 述語は\var{obj}がペアであれば \schtrue{}を返し、
そうでなければ \schfalse{}を返します。

\begin{scheme}
(pair? '(a . b))        \ev  \schtrue
(pair? '(a b c))        \ev  \schtrue
(pair? '())             \ev  \schfalse
(pair? '\#(a b))         \ev  \schfalse%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{cons}{ \vari{obj} \varii{obj}}{手続き}}

carが\vari{obj}でありcdrが\varii{obj}である新しく割り当てられたペアを返します。
このペアは既存のいかなるオブジェクトとも({\cf eqv?} の意味で)異なることが保証されています。

\begin{scheme}
(cons 'a '())           \ev  (a)
(cons '(a) '(b c d))    \ev  ((a) b c d)
(cons "a" '(b c))       \ev  ("a" b c)
(cons 'a 3)             \ev  (a . 3)
(cons '(a b) 'c)        \ev  ((a b) . c)%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{car}{ pair}{手続き}}

\var{pair}のcarフィールドの内容を返します。
空リスト\index{空リスト}のcarを取ることはエラーであることに注意してください。

\begin{scheme}
(car '(a b c))          \ev  a
(car '((a) b c d))      \ev  (a)
(car '(1 . 2))          \ev  1
(car '())               \ev  \scherror%
\end{scheme}
 
\end{entry}


\begin{entry}{%
\proto{cdr}{ pair}{手続き}}

\var{pair}のcdrフィールドの内容を返します。
空リストのcdrを取ることはエラーであることに注意してください。

\begin{scheme}
(cdr '((a) b c d))      \ev  (b c d)
(cdr '(1 . 2))          \ev  2
(cdr '())               \ev  \scherror%
\end{scheme}
 
\end{entry}


\begin{entry}{%
\proto{set-car!}{ pair obj}{手続き}}

\var{pair}のcarフィールドに\var{obj}を格納します。
\begin{scheme}
(define (f) (list 'not-a-constant-list))
(define (g) '(constant-list))
(set-car! (f) 3)             \ev  \unspecified
(set-car! (g) 3)             \ev  \scherror%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{set-cdr!}{ pair obj}{手続き}}

\var{pair}のcdrフィールドに\var{obj}を格納します。
\end{entry}

\setbox0\hbox{\tt(cadr \var{pair})}
\setbox1\hbox{手続き}


\begin{entry}{%
\proto{caar}{ pair}{手続き}
\proto{cadr}{ pair}{手続き}
\proto{cdar}{ pair}{手続き}
\proto{cddr}{ pair}{手続き}}

これらの手続きは以下のような{\cf car}および{\cf cdr}の合成関数です。

\begin{scheme}
(define (caar x) (car (car x)))
(define (cadr x) (car (cdr x)))
(define (cdar x) (cdr (car x)))
(define (cddr x) (cdr (cdr x)))%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{caaar}{ pair}{cxrライブラリの手続き}%
\proto{caadr}{ pair}{cxrライブラリの手続き}%
\pproto{\hbox to 1\wd0 {\hfil$\vdots$\hfil}}{\hbox to 1\wd1 {\hfil$\vdots$\hfil}}%
\mainschindex{cadar}\mainschindex{caddr}%
\mainschindex{cdaar}\mainschindex{cdadr}\mainschindex{cddar}\mainschindex{cdddr}%
\mainschindex{caaaar}\mainschindex{caaadr}\mainschindex{caadar}\mainschindex{caaddr}%
\mainschindex{cadaar}\mainschindex{cadadr}\mainschindex{caddar}\mainschindex{cadddr}%
\mainschindex{cdaaar}\mainschindex{cdaadr}\mainschindex{cdadar}\mainschindex{cdaddr}%
\mainschindex{cddaar}\mainschindex{cddadr}%
\proto{cdddar}{ pair}{cxrライブラリの手続き}%
\proto{cddddr}{ pair}{cxrライブラリの手続き}}

これら24個の手続きは同じ考え方に基づいた{\cf car}および{\cf cdr}のさらなる合成関数です。
例えば{\cf caddr}は以下のように定義できます。

\begin{scheme}
(define caddr (lambda (x) (car (cdr (cdr x))))){\rm.}%
\end{scheme}

深さ4までのすべての組み合わせが提供されています。

\end{entry}


\begin{entry}{%
\proto{null?}{ obj}{手続き}}

\var{obj}が空リスト\index{空リスト}であれば \schtrue{}を返し、
そうでなければ \schfalse{}を返します。

\end{entry}

\begin{entry}{%
\proto{list?}{ obj}{手続き}}

\var{obj}がリストであれば \schtrue{}を返し、
そうでなければ \schfalse{}を返します。
定義により、リストはすべて有限の長さを持ち、空リストで終端します。

\begin{scheme}
        (list? '(a b c))     \ev  \schtrue
        (list? '())          \ev  \schtrue
        (list? '(a . b))     \ev  \schfalse
        (let ((x (list 'a)))
          (set-cdr! x x)
          (list? x))         \ev  \schfalse%
\end{scheme}


\end{entry}

\begin{entry}{%
\proto{make-list}{ k}{手続き}
\rproto{make-list}{ k fill}{手続き}}

\var{k}個の要素を持つ新しく割り当てられたリストを返します。
第2引数が指定された場合は各要素が\var{fill}に初期化されます。
そうでなければ各要素の初期内容は規定されていません。

\begin{scheme}
(make-list 2 3)   \ev   (3 3)%
\end{scheme}

\end{entry}



\begin{entry}{%
\proto{list}{ \var{obj} \dotsfoo}{手続き}}

その引数から成る新しく割り当てられたリストを返します。

\begin{scheme}
(list 'a (+ 3 4) 'c)            \ev  (a 7 c)
(list)                          \ev  ()%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{length}{ list}{手続き}}

\var{list}の長さを返します。

\begin{scheme}
(length '(a b c))               \ev  3
(length '(a (b) (c d e)))       \ev  3
(length '())                    \ev  0%
\end{scheme}


\end{entry}


\begin{entry}{%
\proto{append}{ list \dotsfoo}{手続き}}

\domain{最後の引数(もしあれば)は任意の型を指定できます。}
最初の\var{list}の要素に他の\var{list}の要素を続けたものを要素とするリストを返します。
引数が無ければ空リストが返されます。
引数がひとつだけの場合はそれが返されます。
それ以外の場合は、結果のリストは常に新しく割り当てられますが、最後の引数の構造は共有します。
最後の引数が真正リストでなければ結果は非真正リストです。

\begin{scheme}
(append '(x) '(y))              \ev  (x y)
(append '(a) '(b c d))          \ev  (a b c d)
(append '(a (b)) '((c)))        \ev  (a (b) (c))%
\end{scheme}


\begin{scheme}
(append '(a b) '(c . d))        \ev  (a b c . d)
(append '() 'a)                 \ev  a%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{reverse}{ list}{手続き}}

\var{list}の要素から成る逆順の新しく割り当てられたリストを返します。

\begin{scheme}
(reverse '(a b c))              \ev  (c b a)
(reverse '(a (b c) d (e (f))))  \lev  ((e (f)) d (b c) a)%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{list-tail}{ list \vr{k}}{手続き}}

\domain{\var{list}の要素が\vr{k}個より少ない場合はエラーです。}
最初の\vr{k}個の要素を除いて得られる\var{list}の部分リストを返します。
{\cf list-tail}手続きは以下のように定義できます。

\begin{scheme}
(define list-tail
  (lambda (x k)
    (if (zero? k)
        x
        (list-tail (cdr x) (- k 1)))))%
\end{scheme} 
\end{entry}


\begin{entry}{%
\proto{list-ref}{ list \vr{k}}{手続き}}

\domain{\var{list}引数は循環構造でも構いません。
\var{list}の要素が\vr{k}個より少ない場合はエラーです。}
\var{list}の\vr{k}番目の要素を返します。
(これは {\tt(list-tail \var{list} \vr{k})} のcarと同じです。)

\begin{scheme}
(list-ref '(a b c d) 2)                 \ev  c
(list-ref '(a b c d)
          (exact (round 1.8))) \lev  c%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{list-set!}{ list k obj}{手続き}}

\domain{\vr{k}が\var{list}の有効なインデックスでない場合はエラーです。}
{\cf list-set!} 手続きは\var{list}の\vr{k}番目の要素に\var{obj}を格納します。
\begin{scheme}
(let ((ls (list 'one 'two 'five!)))
  (list-set! ls 2 'three)
  ls)      \lev  (one two three)

(list-set! '(0 1 2) 1 "oops")  \lev  \scherror  ; 定数リスト%
\end{scheme}
\end{entry}




\begin{entry}{%
\proto{memq}{ obj list}{手続き}
\proto{memv}{ obj list}{手続き}
\proto{member}{ obj list}{手続き}
\rproto{member}{ obj list compare}{手続き}}

これらの手続きはcarが\var{obj}である最初の\var{list}の部分リストを返します。
\var{list}の部分リストは
{\tt (list-tail \var{list} \var{k})}によって返される空でないリストです
(\var{k}は\var{list}の長さより小さいものとします)。
\var{list}内に\var{obj}が現れない場合は %
\schfalse{}が返されます(空リストではありません)。
{\cf memq}手続きは\var{obj}と\var{list}の要素との比較に{\cf eq?} を用いるのに対して、
{\cf memv}は{\cf eqv?} を用い、
{\cf member}は\var{compare}が指定された場合はそれを用い、そうでなければ{\cf equal?} を用います。

\begin{scheme}
(memq 'a '(a b c))              \ev  (a b c)
(memq 'b '(a b c))              \ev  (b c)
(memq 'a '(b c d))              \ev  \schfalse
(memq (list 'a) '(b (a) c))     \ev  \schfalse
(member (list 'a)
        '(b (a) c))             \ev  ((a) c)
(member "B"
        '("a" "b" "c")
        string-ci=?)            \ev  ("b" "c")
(memq 101 '(100 101 102))       \ev  \unspecified
(memv 101 '(100 101 102))       \ev  (101 102)%
\end{scheme} 
 
\end{entry}


\begin{entry}{%
\proto{assq}{ obj alist}{手続き}
\proto{assv}{ obj alist}{手続き}
\proto{assoc}{ obj alist}{手続き}
\rproto{assoc}{ obj alist compare}{手続き}}

\domain{\var{alist}(``association list''(連想リスト)の略)がペアのリストでなければエラーです。}
これらの手続きはcarフィールドが\var{obj}である\var{alist}内の最初のペアを探し、
そのペアを返します。
carに\var{obj}を持つペアが\var{alist}内に無ければ %
\schfalse{}が返されます(空リストではありません)。
{\cf assq}手続きは\var{obj}と\var{alist}内のペアのcarフィールドとの比較に{\cf eq?} を用いるのに対して、
{\cf assv}は{\cf eqv?} を用い、
{\cf assoc}は\var{compare}が指定された場合はそれを用い、そうでなければ{\cf equal?} を用います。

\begin{scheme}
(define e '((a 1) (b 2) (c 3)))
(assq 'a e)     \ev  (a 1)
(assq 'b e)     \ev  (b 2)
(assq 'd e)     \ev  \schfalse
(assq (list 'a) '(((a)) ((b)) ((c))))
                \ev  \schfalse
(assoc (list 'a) '(((a)) ((b)) ((c))))   
                           \ev  ((a))
(assoc 2.0 '((1 1) (2 4) (3 9)) =)
                           \ev (2 4)
(assq 5 '((2 3) (5 7) (11 13)))    
                           \ev  \unspecified
(assv 5 '((2 3) (5 7) (11 13)))    
                           \ev  (5 7)%
\end{scheme}


\begin{rationale}
{\cf memq}、{\cf memv}、{\cf member}、{\cf assq}、{\cf assv}および{\cf assoc}は
よく述語として用いられはしますが、名前に疑問符は付いていません。
これは単なる \schtrue{}または \schfalse{}でなく、
場合によっては有用な値を返すためです。
\end{rationale}
\end{entry}

\begin{entry}{%
\proto{list-copy}{ obj}{手続き}}

\var{obj}がリストの場合、その新しく割り当てられたコピーを返します。
コピーされるのはペア自身だけです。
結果のcarは\var{list}のcarと({\cf eqv?} の意味で)同じになります。
\var{obj}が非真正リストの場合、結果も非真正リストとなり、
最後のcdrは{\cf eqv?} の意味で同じになります。
\var{obj}がリストでない場合はそのまま返されます。
\var{obj}が循環リストの場合はエラーです。

\begin{scheme}
(define a '(1 8 2 8)) ; aは不変かもしれない
(define b (list-copy a))
(set-car! b 3)        ; bは可変
b \ev (3 8 2 8)
a \ev (1 8 2 8)%
\end{scheme}

\end{entry}


\section{シンボル}
\label{symbolsection}

シンボルはその名前が同じ綴りである場合に限り({\cf eqv?} の意味で)等しい
という事実に有用性があるオブジェクトです。
例えば他の言語では列挙型を使うような場面で使うことができます。

\vest シンボルの書き方の規則は識別子の書き方の規則とまったく同じです。
\ref{syntaxsection}~節および\ref{identifiersyntax}~節を参照してください。

\vest リテラル式の一部として返され、または{\cf read}手続きを用いて読み込まれ、
その後{\cf write}手続きを用いて書き出されたシンボルはすべて、
({\cf eqv?} の意味で)同一のシンボルとして読み戻されます。

\begin{note}
「インターン化されていないシンボル」として知られている、
write/read不変原則を破る値を持つ処理系もあります。
またこれは2つのシンボルの名前が同じ綴りの場合に限り同じであるという規則にも違反するものです。
この報告書ではそのような処理系依存の拡張の動作は規定されていません。
\end{note}


\begin{entry}{%
\proto{symbol?}{ obj}{手続き}}

\var{obj}がシンボルであれば \schtrue{}を返し、そうでなければ \schfalse{}を返します。

\begin{scheme}
(symbol? 'foo)          \ev  \schtrue
(symbol? (car '(a b)))  \ev  \schtrue
(symbol? "bar")         \ev  \schfalse
(symbol? 'nil)          \ev  \schtrue
(symbol? '())           \ev  \schfalse
(symbol? \schfalse)     \ev  \schfalse%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{symbol=?}{ \vari{symbol} \varii{symbol} \variii{symbol} \dotsfoo}{手続き}}

引数がすべてシンボルであり、その名前がすべて({\cf string=?} の意味で)同じであれば %
\schtrue{}を返します。

\begin{note}
上記の定義はどの引数もインターン化されていないシンボルではないという想定に基づいています。
\end{note}

\end{entry}

\begin{entry}{%
\proto{symbol->string}{ symbol}{手続き}}

\var{symbol}の名前を文字列として返します。
ただしエスケープは行われていません。
この手続きが返した文字列に\ide{string-set!} のような変更手続きを適用するのはエラーです。

\begin{scheme}
(symbol->string 'flying-fish)     
                                  \ev  "flying-fish"
(symbol->string 'Martin)          \ev  "Martin"
(symbol->string
   (string->symbol "Malvina"))     
                                  \ev  "Malvina"%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{string->symbol}{ string}{手続き}}

名前が\var{string}であるシンボルを返します。
この手続きにより、書き出すときにエスケープが必要な特殊な文字を含む名前のシンボルを
作ることができますが、入力中のエスケープは解釈されません。

\begin{scheme}
(string->symbol "mISSISSIppi")  \lev%
  mISSISSIppi
(eqv? 'bitBlt (string->symbol "bitBlt"))     \lev  \schtrue
(eqv? 'LollyPop
     (string->symbol
       (symbol->string 'LollyPop)))  \lev  \schtrue
(string=? "K. Harper, M.D."
          (symbol->string
            (string->symbol "K. Harper, M.D.")))  \lev  \schtrue%
\end{scheme}

\end{entry}


\section{文字}
\label{charactersection}

文字はアルファベットや数字のような印刷文字を表現するオブジェクトです。
Schemeの処理系はすべて少なくともASCII文字のレパートリーをサポートしていなければなりません。
つまりUnicode文字の U+0000〜U+007F です。
処理系は他の好きなUnicode文字をサポートしていても構いませんし、
非Unicode文字をサポートしていても構いません。
特に規定のない限り、
以下の手続きに非Unicode文字を適用した結果は処理系依存です。

文字は \sharpsign\backwhack\hyper{character} または %
\sharpsign\backwhack\hyper{character name} または %
\sharpsign\backwhack{}x\meta{hex scalar value} の記法を用いて書かれます。

以下の文字名は記載された値と共にすべての処理系でサポートされていなければなりません。
処理系は他の名前を追加しても構いませんが、
{\cf x}を前置した hex scalar value として解釈可能でないものに限ります。

$$
\begin{tabular}{ll}
{\tt \#\backwhack{}alarm}&; \textrm{U+0007}\\
{\tt \#\backwhack{}backspace}&; \textrm{U+0008}\\
{\tt \#\backwhack{}delete}&; \textrm{U+007F}\\
{\tt \#\backwhack{}escape}&; \textrm{U+001B}\\
{\tt \#\backwhack{}newline}&; 改行文字, \textrm{U+000A}\\
{\tt \#\backwhack{}null}&; 空文字, \textrm{U+0000}\\
{\tt \#\backwhack{}return}&; 復帰文字, \textrm{U+000D}\\
{\tt \#\backwhack{}space}&; 空白を書く望ましい方法\\
{\tt \#\backwhack{}tab}&; タブ文字, \textrm{U+0009}\\
\end{tabular}
$$

以下に追加の例を示します。

$$
\begin{tabular}{ll}
{\tt \#\backwhack{}a}&; 小文字\\
{\tt \#\backwhack{}A}&; 大文字\\
{\tt \#\backwhack{}(}&; 開き括弧\\
{\tt \#\backwhack{} }&; 空白文字\\
{\tt \#\backwhack{}x03BB}&; $\lambda$ (その文字がサポートされている場合)\\
{\tt \#\backwhack{}iota}&; $\iota$ (その文字と名前がサポートされている場合)\\
\end{tabular}
$$

\sharpsign\backwhack\hyper{character}
および %
\sharpsign\backwhack{\rm$\langle$character name$\rangle$}
では大文字小文字は区別されますが、
{\cf\sharpsign\backwhack{}x}\meta{hex scalar value}
では区別されません。
\sharpsign\backwhack\hyper{character} 内の
\hyper{character} がアルファベットの場合、
\hyper{character} の直後の文字が識別子に使われるものであってはなりません。
この規則は曖昧なケースを解決するためのものです。
曖昧なケースというのは、例えば
``{\tt\sharpsign\backwhack space}'' という文字の並びは、
空白文字の表現とも、
文字表現 ``{\tt\sharpsign\backwhack s}'' に
シンボルの表現 ``{\tt pace}'' が続いたものとも取れます。

\todo{Fix}
\sharpsign\backwhack{} 記法で書かれた文字はそれ自身に評価されます。
つまりプログラム中でquoteする必要はありません。

\vest 文字を操作する手続きには大文字小文字の違いを無視するものがあります。
大文字小文字を無視する手続きは名前に
\hbox{``{\tt -ci}''} (``case insensitive''(大文字小文字を区別しない)の略) が入っています。


\begin{entry}{%
\proto{char?}{ obj}{手続き}}

\var{obj}が文字であれば \schtrue{}を返し、そうでなければ \schfalse{}を返します。

\end{entry}


\begin{entry}{%
\proto{char=?}{ \vri{char} \vrii{char} \vriii{char} \dotsfoo}{手続き}
\proto{char<?}{ \vri{char} \vrii{char} \vriii{char} \dotsfoo}{手続き}
\proto{char>?}{ \vri{char} \vrii{char} \vriii{char} \dotsfoo}{手続き}
\proto{char<=?}{ \vri{char} \vrii{char} \vriii{char} \dotsfoo}{手続き}
\proto{char>=?}{ \vri{char} \vrii{char} \vriii{char} \dotsfoo}{手続き}}

\label{characterequality}

これらの手続きは引数を{\cf char\coerce{}integer}に渡した結果がそれぞれ
等しい、単調に増加している、単調に減少している、
単調に減少していない、単調に増加していない場合に %
\schtrue{}を返します。

これらの述語は推移的であることが要求されます。

\end{entry}


\begin{entry}{%
\proto{char-ci=?}{ \vri{char} \vrii{char} \vriii{char} \dotsfoo}{charライブラリの手続き}
\proto{char-ci<?}{ \vri{char} \vrii{char} \vriii{char} \dotsfoo}{charライブラリの手続き}
\proto{char-ci>?}{ \vri{char} \vrii{char} \vriii{char} \dotsfoo}{charライブラリの手続き}
\proto{char-ci<=?}{ \vri{char} \vrii{char} \vriii{char} \dotsfoo}{charライブラリの手続き}
\proto{char-ci>=?}{ \vri{char} \vrii{char} \vriii{char} \dotsfoo}{charライブラリの手続き}}

これらの手続きは{\cf char=?} 等に似ていますが、大文字小文字を同一視する点が異なります。
例えば {\cf (char-ci=?\ \#\backwhack{}A \#\backwhack{}a)} は \schtrue{}を返します。

具体的にはこれらの手続きは比較前に引数に{\cf char-foldcase}を適用したかのように動作します。

\end{entry}


\begin{entry}{%
\proto{char-alphabetic?}{ char}{charライブラリの手続き}
\proto{char-numeric?}{ char}{charライブラリの手続き}
\proto{char-whitespace?}{ char}{charライブラリの手続き}
\proto{char-upper-case?}{ letter}{charライブラリの手続き}
\proto{char-lower-case?}{ letter}{charライブラリの手続き}}

これらの手続きは引数がそれぞれアルファベットである、数字である、ホワイトスペースである、
大文字である、小文字である場合に \schtrue{}を返し、
そうでなければ \schfalse{}を返します。

具体的にはこれらはそれぞれUnicodeのプロパティである
Alphabetic、Numeric\_Digit、White\_Space、Uppercase、Lowercase
を持つ文字に適用すると \schtrue{}を返し、
そうでないUnicode文字に適用すると \schfalse{}を返します。
アルファベットでありながら大文字でも小文字でもない文字が
Unicodeにはたくさんあることに注意してください。

\end{entry}


\begin{entry}{%
\proto{digit-value}{ char}{charライブラリの手続き}}

この手続きは引数が数字(つまり{\cf char-numeric?} が \schtrue{}を返す)の場合、
その引数の数値(0〜9)を返し、それ以外の文字に対しては \schfalse{}を返します。

\begin{scheme}
(digit-value \#\backwhack{}3) \ev 3
(digit-value \#\backwhack{}x0664) \ev 4
(digit-value \#\backwhack{}x0AE6) \ev 0
(digit-value \#\backwhack{}x0EA6) \ev \schfalse%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{char->integer}{ char}{手続き}
\proto{integer->char}{ \vr{n}}{手続き}}

{\cf char\coerce{}integer}にUnicode文字を与えると、
その文字のUnicodeスカラー値と等しい
0〜{\tt \#xD7FF} または {\tt \#xE000}〜{\tt \#x10FFFF} の
正確な整数を返します。
非Unicode文字を与えると、
{\tt \#x10FFFF}より大きい正確な整数を返します。
処理系が内部的にUnicode表現を用いているか否かに関係なくこのように動作します。

ある文字に{\cf char\coerce{}integer}を適用して返された正確な整数を
{\cf integer\coerce{}char}に与えるとその文字を返します。
\end{entry}


\begin{entry}{%
\proto{char-upcase}{ char}{charライブラリの手続き}
\proto{char-downcase}{ char}{charライブラリの手続き}
\proto{char-foldcase}{ char}{charライブラリの手続き}}


{\cf char-upcase}手続きは
Unicode大文字小文字ペアの小文字を引数に与えるとその大文字を返します。
ただしそのScheme処理系がその両方の文字をサポートしている場合に限ります。
言語固有の大文字小文字ペアは用いられないことに注意してください。
引数がそのようなペアの小文字でなかった場合は引数がそのまま返されます。

{\cf char-downcase}手続きは
Unicode大文字小文字ペアの大文字を引数に与えるとその小文字を返します。
ただしそのScheme処理系がその両方の文字をサポートしている場合に限ります。
言語固有の大文字小文字ペアは用いられないことに注意してください。
引数がそのようなペアの大文字でなかった場合は引数がそのまま返されます。

{\cf char-foldcase}手続きは引数に対して
Unicodeの単純な大文字小文字畳み込みアルゴリズム
を適用し、その結果を返します。
言語固有の畳み込みは用いられないことに注意してください。
引数が大文字の場合、結果は小文字であるか、
その小文字が存在しないまたは処理系がサポートしていない場合は引数がそのまま返されます。
詳細は UAX \#29~\cite{uax29} (Unicode標準の一部) を参照してください。

対応する大文字がない小文字がUnicodeにはたくさんあることに注意してください。

\end{entry}


\section{文字列}
\label{stringsection}

文字列は文字の並びです。
\vest 文字列はダブルクォート ({\cf "}) で囲まれた文字の並びとして書かれます。
文字列リテラル内では、
様々なエスケープシーケンス\mainindex{エスケープシーケンス}が特別に解釈されます。
エスケープシーケンスは必ずバックスラッシュ(\backwhack{})で始まります。

\begin{itemize}
\item{\cf\backwhack{}a} : アラーム, U+0007
\item{\cf\backwhack{}b} : バックペース, U+0008 
\item{\cf\backwhack{}t} : タブ, U+0009 
\item{\cf\backwhack{}n} : 改行, U+000A 
\item{\cf\backwhack{}r} : 復帰, U+000D 
\item{\cf\backwhack{}}\verb|"| : ダブルクォート, U+0022 
\item{\cf\backwhack{}\backwhack{}} : バックスラッシュ, U+005C 
\item{\cf\backwhack{}|} : 垂直線, U+007C
\item{\cf\backwhack{}\arbno{\hyper{intraline whitespace}}\hyper{line ending}
      \arbno{\hyper{intraline whitespace}}} : 無
\item{\cf\backwhack{}x\meta{hex scalar value};} : 指定された文字
(最後にセミコロンが付いていることに注意)
\end{itemize}

文字列中でバックスラッシュの後にこれ以外の文字が続いた場合の結果は規定されていません。

\vest 文字列リテラル中のエスケープシーケンス外の任意の文字は、改行を除き、
それ自身を表します。
{\cf\backwhack{}\hyper{intraline whitespace}} に改行が続いたものは
(後続の intraline whitespace も含めて) 無に展開されるので、
可読性向上のため文字列をインデントするのに使うことができます。
それ以外の改行はすべて文字列中に {\cf\backwhack{}n} 文字を入れるのと
同じ効果を持ちます。

例を挙げます。

\begin{scheme}
"The word \backwhack{}"recursion\backwhack{}" has many meanings."
"Another example:\backwhack{}ntwo lines of text"
"Here's text \backwhack{} 
   containing just one line"
"\backwhack{}x03B1; is named GREEK SMALL LETTER ALPHA."%
\end{scheme}

\vest 文字列に含まれる文字の数をその文字列の{\em 長さ}と言います。
この数値は正確な非負の整数で文字列の作成時に固定されます。
文字列の長さ未満の正確な非負の整数をその文字列の\defining{有効なインデックス}と言います。
文字列の最初の文字のインデックスは0で、二番目の文字のインデックスは1で、以下同様です。


\vest 文字列を操作する手続きには大文字小文字の違いを無視するものがあります。
大文字小文字を無視するバージョンは名前の最後に
\hbox{``{\cf -ci}''} (``case insensitive''(大文字小文字を区別しない)の略)が付いています。

処理系は文字列中に特定の文字が現れることを禁止しても構いません。
ただし {\tt \#\backwhack{}null}以外のASCII文字を禁止してはなりません。
例えば、Unicodeのレパートリー全体をサポートするけれども
文字列中では U+0001〜U+00FF ({\tt \#\backwhack{}null} を除く Latin-1 のレパートリー)
しか使えない処理系などが有り得ます。

そのような禁止文字を
{\cf make-\+string}、{\cf string}、{\cf string-\+set!}、{\cf string-\+fill!}
に渡したり、リストの一部として{\cf list\coerce{}string}に渡したり、
ベクタの一部として{\cf vector\coerce{}string} (\ref{vectortostring}~節を参照)
に渡したり、バイトベクタ内にUTF-8エンコードされた形で
{\cf utf8\coerce{}string} (\ref{utf8tostring}~節を参照)に渡すことはエラーです。
また{\cf string-map} (\ref{stringmap}~節を参照) に渡した手続きが禁止文字を返したり、
{\cf read-string} (\ref{readstring}~節を参照) に禁止文字を読ませようと
試みることもエラーです。

\begin{entry}{%
\proto{string?}{ obj}{手続き}}

\var{obj}が文字列であれば \schtrue{}を返し、そうでなければ \schfalse{}を返します。
\end{entry}


\begin{entry}{%
\proto{make-string}{ \vr{k}}{手続き}
\rproto{make-string}{ \vr{k} char}{手続き}}

{\cf make-string}手続きは新しく割り当てられた長さ\vr{k}の文字列を返します。
\var{char}が与えられた場合はその文字列のすべての文字が\var{char}で初期化されます。
そうでなければ文字列の内容は規定されていません。

\end{entry}

\begin{entry}{%
\proto{string}{ char \dotsfoo}{手続き}}

引数から成る新しく割り当てられた文字列を返します。
これは{\cf list}の文字列版です。

\end{entry}

\begin{entry}{%
\proto{string-length}{ string}{手続き}}

与えられた\var{string}の文字数を返します。
\end{entry}


\begin{entry}{%
\proto{string-ref}{ string \vr{k}}{手続き}}

\domain{\vr{k}が\var{string}の有効なインデックスでなければエラーです。}
{\cf string-ref}手続きは\var{string}の\vr{k}番目の文字を返します。
インデックスはゼロから始まります。
\end{entry}
この手続きを定数時間で実行することは要求されていません。


\begin{entry}{%
\proto{string-set!}{ string k char}{手続き}}

\domain{\vr{k}が\var{string}の有効なインデックスでなければエラーです。}
{\cf string-set!} 手続きは\var{string}の\vr{k}番目の要素に\var{char}を格納します。
この手続きを定数時間で実行することは要求されていません。

\begin{scheme}
(define (f) (make-string 3 \sharpsign\backwhack{}*))
(define (g) "***")
(string-set! (f) 0 \sharpsign\backwhack{}?)  \ev  \unspecified
(string-set! (g) 0 \sharpsign\backwhack{}?)  \ev  \scherror
(string-set! (symbol->string 'immutable)
             0
             \sharpsign\backwhack{}?)  \ev  \scherror%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{string=?}{ \vri{string} \vrii{string} \vriii{string} \dotsfoo}{手続き}}

すべての文字列が同じ長さで正確に同じ文字を同じ位置に持つ場合 \schtrue{}を返し、
そうでなければ \schfalse{}を返します。

\end{entry}

\begin{entry}{%
\proto{string-ci=?}{ \vri{string} \vrii{string} \vriii{string} \dotsfoo}{charライブラリの手続き}}

大文字小文字畳み込みの後、
すべての文字列が同じ長さで同じ位置に同じ文字を持つ場合 \schtrue{}を返し、
そうでなければ \schfalse{}を返します。
具体的にはこれらの手続きは比較前に引数に{\cf string-foldcase}を適用したかのように動作します。

\end{entry}


\begin{entry}{%
\proto{string<?}{ \vri{string} \vrii{string} \vriii{string} \dotsfoo}{手続き}
\proto{string-ci<?}{ \vri{string} \vrii{string} \vriii{string} \dotsfoo}{charライブラリの手続き}
\proto{string>?}{ \vri{string} \vrii{string} \vriii{string} \dotsfoo}{手続き}
\proto{string-ci>?}{ \vri{string} \vrii{string} \vriii{string} \dotsfoo}{charライブラリの手続き}
\proto{string<=?}{ \vri{string} \vrii{string} \vriii{string} \dotsfoo}{手続き}
\proto{string-ci<=?}{ \vri{string} \vrii{string} \vriii{string} \dotsfoo}{charライブラリの手続き}
\proto{string>=?}{ \vri{string} \vrii{string} \vriii{string} \dotsfoo}{手続き}
\proto{string-ci>=?}{ \vri{string} \vrii{string} \vriii{string} \dotsfoo}{charライブラリの手続き}}

これらの手続きは引数がそれぞれ単調に増加している、単調に減少している、
単調に増加していない、単調に減少していない場合に \schtrue{}を返します。

これらの述語は推移的であることが要求されます。

これらの手続きは処理系定義の方法で文字列を比較します。
ひとつの方法として
文字に対する順序付けを文字列に辞書的に拡張することが考えられます。
その場合{\cf string<?} は文字に対する{\cf char<?} の順序付けによって
文字列に対する辞書的な順序付けを行うことになるでしょう。
また2つの文字列の長さが異なるものの短い方の文字列の長さまでは同じ内容の場合、
短い方の文字列は長い方の文字列よりも辞書的に小さいと考えられます。
しかし処理系の文字列の内部表現による自然な順序付けや、
より複雑なロケール固有の順序付けを用いることも許容されます。

いずれの場合でも、一組の文字列に対して
{\cf string<?}、{\cf string=?}、{\cf string>?}
のうちひとつだけが満たされなければならず、
{\cf string>?} が満たされない場合に限り{\cf string<=?} が満たされなければならず、
{\cf string<?} が満たされない場合に限り{\cf string>=?} が満たされなければなりません。

``{\tt -ci}'' 付き手続きは、
対応する ``{\tt -ci}'' 無しの手続きを呼ぶ前に
引数に{\cf string-foldcase}を適用したかのように動作します。


\end{entry}

\begin{entry}{%
\proto{string-upcase}{ string}{charライブラリの手続き}
\proto{string-downcase}{ string}{charライブラリの手続き}
\proto{string-foldcase}{ string}{charライブラリの手続き}}


これらの手続きは引数に対して
Unicodeの完全な大文字小文字変換アルゴリズム
を適用し、その結果を返します。
場合によっては結果の長さが引数と異なることもあります。
結果が引数と{\cf string=?} の意味で同じ場合は引数をそのまま返しても構いません。
ちなみに言語固有のマッピングおよび畳み込みは用いられません。

Unicode標準ではギリシア文字の $\Sigma$ に特別な扱いが規定されており、
通常の小文字形は $\sigma$ ですが、
単語の終わりに来た場合は $\varsigma$ になります。
詳細は UAX \#29~\cite{uax29} (Unicode標準の一部) を参照してください。
しかし{\cf string-downcase}の実装にこの動作を行うことは要求されません。
すべての場合において $\Sigma$ を $\sigma$ に変換しても構いません。

\end{entry}


\begin{entry}{%
\proto{substring}{ string start end}{手続き}}

{\cf substring}手続きは
\var{string}内のインデックス\var{start}で始まりインデックス\var{end}で終わる文字から成る
新しく割り当てられた文字列を返します。
これは同じ引数で{\cf string-copy}を呼ぶのと同等ですが、
後方互換性およびスタイル上の柔軟性のために提供されています。
\end{entry}


\begin{entry}{%
\proto{string-append}{ \var{string} \dotsfoo}{手続き}}

与えられた文字列の文字を連結した文字を持つ新しく割り当てられた文字列を返します。

\end{entry}


\begin{entry}{%
\proto{string->list}{ string}{手続き}
\rproto{string->list}{ string start}{手続き}
\rproto{string->list}{ string start end}{手続き}
\proto{list->string}{ list}{手続き}}

\domain{\var{list}の要素のいずれかが文字でなければエラーです。}
{\cf string\coerce{}list}手続きは\var{string}の\var{start}〜\var{end}の文字の
新しく割り当てられたリストを返します。
{\cf list\coerce{}string}はリスト\var{list}内の要素から成る
新しく割り当てられた文字列を返します。
どちらの手続きでも順番は維持されます。
{\cf equal?} の意味において
{\cf string\coerce{}list}および{\cf list\coerce{}string}はお互い逆関数です。

\end{entry}


\begin{entry}{%
\proto{string-copy}{ string}{手続き}
\rproto{string-copy}{ string start}{手続き}
\rproto{string-copy}{ string start end}{手続き}}

与えられた\var{string}の\var{start}〜\var{end}の部分の
新しく割り当てられたコピーを返します。

\end{entry}


\begin{entry}{%
\proto{string-copy!}{ to at from}{手続き}
\rproto{string-copy!}{ to at from start}{手続き}
\rproto{string-copy!}{ to at from start end}{手続き}}

\domain{\var{at}がゼロより小さいか\var{to}の長さより大きい場合はエラーです。
{\cf (- (string-length \var{to}) \var{at})} が
{\cf (- \var{end} \var{start})} より小さい場合もエラーです。}
文字列\var{from}の\var{start}〜\var{end}の文字を、
文字列\var{to}の\var{at}から始まる位置にコピーします。
文字がコピーされる順番は規定されていません。
ただしコピー元とコピー先が重なっている場合は、
コピー元がいったん一時的な文字列にコピーされ、
それからコピー先にコピーされたかのように動作します。
正しい方向でコピーを行うように気を付ければ
そのような状況でも領域を割り当てることなくこれを行うことができます。

\begin{scheme}
(define a "12345")
(define b (string-copy "abcde"))
(string-copy! b 1 a 0 2)
b \ev "a12de"%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{string-fill!}{ string fill}{手続き}
\rproto{string-fill!}{ string fill start}{手続き}
\rproto{string-fill!}{ string fill start end}{手続き}}

\domain{\var{fill}が文字でなければエラーです。}

{\cf string-fill!} 手続きは\var{string}の\var{start}〜\var{end}の要素に
\var{fill}を格納します。

\end{entry}


\section{ベクタ}
\label{vectorsection}

ベクタは要素を整数でインデックスする異種混合の構造体です。
ベクタは一般的に同じ長さのリストよりも小さな空間しか使用せず、
一般的にランダムに選んだ要素のアクセスに必要な平均時間が
リストよりもベクタの方が小さくて済みます。

\vest ベクタが持つ要素の数をそのベクタの{\em 長さ}と言います。
この数は非負の整数でベクタの作成時に固定されます。
ベクタの長さよりも小さい正確な非負の整数をそのベクタの
{\em 有効なインデックス}\index{有効なインデックス}と言います。
ベクタの最初の要素のインデックスは0で、
最後の要素のインデックスはベクタの長さよりも1小さい値です。

ベクタは {\tt\#(\var{obj} \dotsfoo)} という表記を用いて書きます。
例えば0番目の要素に数値のゼロ、1番目の要素にリスト {\cf(2 2 2 2)}、
2番目の要素に文字列 {\cf "Anna"} を持つ長さ3のベクタは
以下のように書くことができます。

\begin{scheme}
\#(0 (2 2 2 2) "Anna")%
\end{scheme}

ベクタ定数はそれ自身に評価されます。
そのためプログラム中でquoteする必要はありません。

\begin{entry}{%
\proto{vector?}{ obj}{手続き}}
 
\var{obj}がベクタであれば \schtrue{}を返し、そうでなければ \schfalse{}を返します。
\end{entry}


\begin{entry}{%
\proto{make-vector}{ k}{手続き}
\rproto{make-vector}{ k fill}{手続き}}

\var{k}個の要素を持つ新しく割り当てられたベクタを返します。
第2引数が与えられた場合、各要素は\var{fill}に初期化されます。
そうでなければ各要素の初期内容は規定されていません。

\end{entry}


\begin{entry}{%
\proto{vector}{ obj \dotsfoo}{手続き}}

与えられた引数を要素に持つ新しく割り当てられたベクタを返します。
これは{\cf list}のベクタ版です。

\begin{scheme}
(vector 'a 'b 'c)               \ev  \#(a b c)%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{vector-length}{ vector}{手続き}}

\var{vector}の要素の数を正確な整数として返します。
\end{entry}


\begin{entry}{%
\proto{vector-ref}{ vector k}{手続き}}

\domain{\vr{k}が\var{vector}の有効なインデックスでなければエラーです。}
{\cf vector-ref}手続きは\var{vector}の\vr{k}番目の要素の内容を返します。

\begin{scheme}
(vector-ref '\#(1 1 2 3 5 8 13 21)
            5)  \lev  8
(vector-ref '\#(1 1 2 3 5 8 13 21)
            (exact
             (round (* 2 (acos -1))))) \lev 13%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{vector-set!}{ vector k obj}{手続き}}

\domain{\vr{k}が\var{vector}の有効なインデックスでなければエラーです。}
{\cf vector-set!} 手続きは\var{vector}の\vr{k}番目の要素に\var{obj}を格納します。
\begin{scheme}
(let ((vec (vector 0 '(2 2 2 2) "Anna")))
  (vector-set! vec 1 '("Sue" "Sue"))
  vec)      \lev  \#(0 ("Sue" "Sue") "Anna")

(vector-set! '\#(0 1 2) 1 "doe")  \lev  \scherror  ; 定数ベクタ%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{vector->list}{ vector}{手続き}
\rproto{vector->list}{ vector start}{手続き}
\rproto{vector->list}{ vector start end}{手続き}
\proto{list->vector}{ list}{手続き}}

{\cf vector->list}手続きは\var{vector}の\var{start}〜\var{end}の要素に
格納されているオブジェクトから成る新しく割り当てられたリストを返します。
{\cf list->vector}手続きはリスト\var{list}の要素に初期化されている
新しく割り当てられたベクタを返します。

どちらの手続きでも順番は維持されます。

\begin{scheme}
(vector->list '\#(dah dah didah))  \lev  (dah dah didah)
(vector->list '\#(dah dah didah) 1 2) \lev (dah)
(list->vector '(dididit dah))   \lev  \#(dididit dah)%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{vector->string}{ vector}{手続き}
\rproto{vector->string}{ vector start}{手続き}
\rproto{vector->string}{ vector start end}{手続き}
\proto{string->vector}{ string}{手続き}
\rproto{string->vector}{ string start}{手続き}
\rproto{string->vector}{ string start end}{手続き}}
\label{vectortostring}

\domain{\var{vector}の\var{start}〜\var{end}の要素の
いずれかが文字でなければエラーです。}
{\cf vector->string}手続きは\var{vector}の\var{start}〜\var{end}の要素に
格納されているオブジェクトから成る新しく割り当てられた文字列を返します。
{\cf string->vector}手続きは文字列\var{string}の\var{start}〜\var{end}の要素に
初期化されている新しく割り当てられたベクタを返します。

どちらの手続きでも順番は維持されます。


\begin{scheme}
(string->vector "ABC")  \ev   \#(\#\backwhack{}A \#\backwhack{}B \#\backwhack{}C)
(vector->string
  \#(\#\backwhack{}1 \#\backwhack{}2 \#\backwhack{}3) \ev "123"
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{vector-copy}{ vector}{手続き}
\rproto{vector-copy}{ vector start}{手続き}
\rproto{vector-copy}{ vector start end}{手続き}}

与えられた\var{vector}の\var{start}〜\var{end}の要素の
新しく割り当てられたコピーを返します。
新しいベクタの要素は古いベクタの要素と
({\cf eqv?} の意味で)同じです。


\begin{scheme}
(define a \#(1 8 2 8)) ; a may be immutable
(define b (vector-copy a))
(vector-set! b 0 3)   ; b is mutable
b \ev \#(3 8 2 8)
(define c (vector-copy b 1 3))
c \ev \#(8 2)%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{vector-copy!}{ to at from}{手続き}
\rproto{vector-copy!}{ to at from start}{手続き}
\rproto{vector-copy!}{ to at from start end}{手続き}}

\domain{\var{at}がゼロより小さいか\var{to}の長さよりも大きい場合はエラーです。
{\cf (- (vector-length \var{to}) \var{at})} が
{\cf (- \var{end} \var{start})} より小さい場合もエラーです。}
ベクタ\var{from}の\var{start}〜\var{end}の要素を
ベクタ\var{to}の\var{at}から始まる位置にコピーします。
要素がコピーされる順番は規定されていません。
ただしコピー元とコピー先が重なっている場合は、
コピー元がいったん一時的なベクタにコピーされ、
それからコピー先にコピーされたかのように動作します。
正しい方向でコピーを行うように気を付ければ
そのような状況でも領域を割り当てることなくこれを行うことができます。

\begin{scheme}
(define a (vector 1 2 3 4 5))
(define b (vector 10 20 30 40 50))
(vector-copy! b 1 a 0 2)
b \ev \#(10 1 2 40 50)%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{vector-append}{ \var{vector} \dotsfoo}{手続き}}

与えられたベクタの要素を連結した要素を持つ新しく割り当てられたベクタを返します。

\begin{scheme}
(vector-append \#(a b c) \#(d e f)) \lev \#(a b c d e f)%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{vector-fill!}{ vector fill}{手続き}
\rproto{vector-fill!}{ vector fill start}{手続き}
\rproto{vector-fill!}{ vector fill start end}{手続き}}

{\cf vector-fill!} 手続きは\var{vector}の\var{start}〜\var{end}の要素に
\var{fill}を格納します。

\begin{scheme}
(define a (vector 1 2 3 4 5))
(vector-fill! a 'smash 2 4)
a \lev \#(1 2 smash smash 5)%
\end{scheme}

\end{entry}


\section{バイトベクタ}
\label{bytevectorsection}

\defining{バイトベクタ}はバイナリデータの塊を表します。
これは固定サイズのバイトの並びです。
\defining{バイト}とは、0〜255(両端を含む)の範囲の正確な整数です。
バイトベクタは一般的に同じ値を持つベクタよりも高い空間効率を持ちます。

\vest バイトベクタが持つ要素の数をそのバイトベクタの{\em 長さ}と言います。
この数は非負の整数で、バイトベクタ作成時に固定されます。
バイトベクタの長さより小さい正確な非負の整数を、そのバイトベクタの
{\em 有効なインデックス}\index{有効なインデックス}と言います。
ベクタ同様にインデックスはゼロから始まります。

バイトベクタは {\tt\#u8(\var{byte} \dotsfoo)}という表記を用いて書きます。
例えば0番目の要素にバイト0、1番目の要素にバイト10、2番目の要素にバイト5を持つ
長さ3のバイトベクタは以下のように書くことができます。

\begin{scheme}
\#u8(0 10 5)%
\end{scheme}

バイトベクタ定数はそれ自身に評価されます。
そのためプログラム中でquoteする必要はありません。


\begin{entry}{%
\proto{bytevector?}{ obj}{手続き}}

\var{obj}がバイトベクタであれば \schtrue{}を返します。
そうでなければ \schfalse{}を返します。
\end{entry}

\begin{entry}{%
\proto{make-bytevector}{ k}{手続き}
\rproto{make-bytevector}{ k byte}{手続き}}

{\cf make-bytevector}手続きは長さ\vr{k}の
新しく割り当てられたバイトベクタを返します。
\var{byte}が与えられた場合は、
そのバイトベクタのすべての要素が\var{byte}に初期化されます。
そうでなければ各要素の内容は規定されていません。

\begin{scheme}
(make-bytevector 2 12) \ev \#u8(12 12)%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{bytevector}{ \var{byte} \dotsfoo}{手続き}}

引数を持つ新しく割り当てられたバイトベクタを返します。

\begin{scheme}
(bytevector 1 3 5 1 3 5)        \ev  \#u8(1 3 5 1 3 5)
(bytevector)                          \ev  \#u8()%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{bytevector-length}{ bytevector}{手続き}}

\var{bytevector}のバイト単位の長さを正確な整数として返します。
\end{entry}

\begin{entry}{%
\proto{bytevector-u8-ref}{ bytevector k}{手続き}}

\domain{\vr{k}が\var{bytevector}の有効なインデックスでなければエラーです。}
\var{bytevector}の\var{k}番目のバイトを返します。

\begin{scheme}
(bytevector-u8-ref '\#u8(1 1 2 3 5 8 13 21)
            5)  \lev  8%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{bytevector-u8-set!}{ bytevector k byte}{手続き}}

\domain{\vr{k}が\var{bytevector}の有効なインデックスでなければエラーです。}
\var{bytevector}の\var{k}番目のバイトとして\var{byte}を格納します。
\begin{scheme}
(let ((bv (bytevector 1 2 3 4)))
  (bytevector-u8-set! bv 1 3)
  bv) \lev \#u8(1 3 3 4)%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{bytevector-copy}{ bytevector}{手続き}
\rproto{bytevector-copy}{ bytevector start}{手続き}
\rproto{bytevector-copy}{ bytevector start end}{手続き}}

\var{bytevector}の\var{start}〜\var{end}のバイトを持つ
新しく割り当てられたバイトベクタを返します。

\begin{scheme}
(define a \#u8(1 2 3 4 5))
(bytevector-copy a 2 4)) \ev \#u8(3 4)%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{bytevector-copy!}{ to at from}{手続き}
\rproto{bytevector-copy!}{ to at from start}{手続き}
\rproto{bytevector-copy!}{ to at from start end}{手続き}}

\domain{\var{at}がゼロより小さいか\var{to}の長さよりも大きい場合はエラーです。
{\cf (- (bytevector-length \var{to}) \var{at})} が
{\cf (- \var{end} \var{start})} より小さい場合もエラーです。}
バイトベクタ\var{from}の\var{start}〜\var{end}のバイトを
バイトベクタ\var{to}の\var{at}から始まる位置にコピーします。
バイトがコピーされる順番は規定されていません。
ただしコピー元とコピー先が重なっている場合は、
コピー元がいったん一時的なバイトベクタにコピーされ、
それからコピー先にコピーされたかのように動作します。
正しい方向でコピーを行うように気を付ければ
そのような状況でも領域を割り当てることなくこれを行うことができます。

\begin{scheme}
(define a (bytevector 1 2 3 4 5))
(define b (bytevector 10 20 30 40 50))
(bytevector-copy! b 1 a 0 2)
b \ev \#u8(10 1 2 40 50)%
\end{scheme}

\begin{note}
この手続きは\rsixrs{}にもありましたが、
Schemeの他の同様の手続きとは逆に、
コピー元をコピー先より先に指定するようになっていました。
\end{note}

\end{entry}

\begin{entry}{%
\proto{bytevector-append}{ \var{bytevector} \dotsfoo}{手続き}}

与えられたバイトベクタの要素を連結した要素を持つ
新しく割り当てられたバイトベクタを返します。

\begin{scheme}
(bytevector-append \#u8(0 1 2) \#u8(3 4 5)) \lev \#u8(0 1 2 3 4 5)%
\end{scheme}

\end{entry}

\label{utf8tostring}
\begin{entry}{%
\proto{utf8->string}{ bytevector} {手続き}
\rproto{utf8->string}{ bytevector start} {手続き}
\rproto{utf8->string}{ bytevector start end} {手続き}
\proto{string->utf8}{ string} {手続き}
\rproto{string->utf8}{ string start} {手続き}
\rproto{string->utf8}{ string start end} {手続き}}

\domain{\var{bytevector}が無効なUTF-8バイトシーケンスを含んでいる場合はエラーです。}
これらの手続きは文字列と
その文字列をUTF-8エンコーディングでエンコードしたバイトベクタとの間で
変換を行います。
{\cf utf8\coerce{}string}手続きはバイトベクタの\var{start}〜\var{end}のバイトを
デコードし、対応する文字列を返します。
{\cf string\coerce{}utf8}手続きは文字列の\var{start}〜\var{end}の文字を
エンコードし、対応するバイトベクタを返します。

\begin{scheme}
(utf8->string \#u8(\#x41)) \ev "A"
(string->utf8 "$\lambda$") \ev \#u8(\#xCE \#xBB)%
\end{scheme}

\end{entry}

\section{制御機能}
\label{proceduresection}

この節ではプログラム実行の流れを特殊な方法で制御する
様々なプリミティブ手続きについて述べます。
手続き引数を呼び出すこの節の手続きは
必ず元の手続き呼び出しと同じ動的環境でそれを呼び出します。
{\cf procedure?} 述語もここで述べます。

\begin{entry}{%
\proto{procedure?}{ obj}{手続き}}

\var{obj}が手続きであれば \schtrue{}を返し、そうでなければ \schfalse{}を返します。

\begin{scheme}
(procedure? car)            \ev  \schtrue
(procedure? 'car)           \ev  \schfalse
(procedure? (lambda (x) (* x x)))   
                            \ev  \schtrue
(procedure? '(lambda (x) (* x x)))  
                            \ev  \schfalse
(call-with-current-continuation procedure?)
                            \ev  \schtrue%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{apply}{ proc \vari{arg} $\ldots$ args}{手続き}}

{\cf apply}手続きはリスト
{\cf(append (list \vari{arg} \dotsfoo) \var{args})}
の要素を実引数として\var{proc}を呼び出します。

\begin{scheme}
(apply + (list 3 4))              \ev  7

(define compose
  (lambda (f g)
    (lambda args
      (f (apply g args)))))

((compose sqrt *) 12 75)              \ev  30%
\end{scheme}
\end{entry}


\begin{entry}{%
\proto{map}{ proc \vari{list} \varii{list} \dotsfoo}{手続き}}

\domain{\var{proc}が{\it list}の数と同じ数の引数を取らない場合、
および単一の値を返さない場合はエラーです。}
{\cf map}手続きは\var{list}の要素ごとに\var{proc}を適用し、
その結果の順番通りのリストを返します。
\var{list}が2つ以上与えられ、長さの異なるリストがある場合、
{\cf map}は最も短いリストを使い切った時点で終了します。
\var{list}には循環リストも使えますが、すべてのリストが循環リストであった場合はエラーです。
\var{proc}がリストのいずれかを変更した場合はエラーです。
\var{list}の要素に\var{proc}が適用される動的な順番は規定されていません。
{\cf map}からの戻りが複数回発生した場合、
先に返された値が変更されることはありません。

\begin{scheme}
(map cadr '((a b) (d e) (g h)))   \lev  (b e h)

(map (lambda (n) (expt n n))
     '(1 2 3 4 5))                \lev  (1 4 27 256 3125)

(map + '(1 2 3) '(4 5 6 7))         \ev  (5 7 9)

(let ((count 0))
  (map (lambda (ignored)
         (set! count (+ count 1))
         count)
       '(a b)))                 \ev  (1 2) \var{または} (2 1)%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{string-map}{ proc \vari{string} \varii{string} \dotsfoo}{手続き}}
\label{stringmap}

\domain{\var{proc}が{\it string}の数と同じ数の引数を取らない場合、
および単一の値を返さない場合はエラーです。}
{\cf string-map}手続きは\var{string}の要素ごとに\var{proc}を適用し、
その結果の順番通りの文字列を返します。
\var{string}が2つ以上与えられ、長さの異なる文字列がある場合、
{\cf string-map}は最も短い文字列を使い切った時点で終了します。
\var{string}の要素に\var{proc}が適用される動的な順番は規定されていません。
{\cf string-map}からの戻りが複数回発生した場合、
先に返された値が変更されることはありません。

\begin{scheme}
(string-map char-foldcase "AbdEgH") \lev  "abdegh"

(string-map
 (lambda (c)
   (integer->char (+ 1 (char->integer c))))
 "HAL")                \lev  "IBM"

(string-map
 (lambda (c k)
   ((if (eqv? k \sharpsign\backwhack{}u) char-upcase char-downcase)
    c))
 "studlycaps xxx"
 "ululululul")   \lev   "StUdLyCaPs"%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{vector-map}{ proc \vari{vector} \varii{vector} \dotsfoo}{手続き}}

\domain{\var{proc}が{\it vector}の数と同じ数の引数を取らない場合、
および単一の値を返さない場合はエラーです。}
{\cf vector-map}手続きは\var{vector}の要素ごとに\var{proc}を適用し、
その結果の順番通りのベクタを返します。
\var{vector}が2つ以上与えられ、長さの異なるベクタがある場合、
{\cf vector-map}は最も短いリストを使い切った時点で終了します。
\var{vector}の要素に\var{proc}が適用される動的な順番は規定されていません。
{\cf vector-map}からの戻りが複数回発生した場合、
先に返された値が変更されることはありません。

\begin{scheme}
(vector-map cadr '\#((a b) (d e) (g h)))   \lev  \#(b e h)

(vector-map (lambda (n) (expt n n))
            '\#(1 2 3 4 5))                \lev  \#(1 4 27 256 3125)

(vector-map + '\#(1 2 3) '\#(4 5 6 7))       \lev  \#(5 7 9)

(let ((count 0))
  (vector-map
   (lambda (ignored)
     (set! count (+ count 1))
     count)
   '\#(a b)))                     \ev  \#(1 2) \var{または} \#(2 1)%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{for-each}{ proc \vari{list} \varii{list} \dotsfoo}{手続き}}

\domain{\var{proc}が{\it list}の数と同じ数の引数を取らない場合はエラーです。}
{\cf for-each}の引数は{\cf map}の引数と同様ですが、
{\cf for-each}では値のためではなく副作用のために\var{proc}が呼ばれます。
{\cf map}と異なり、{\cf for-each}では
最初の要素から最後の要素まで順番通りに
\var{list}の要素に対して\var{proc}が呼ばれることが保証されています。
{\cf for-each}の戻り値は規定されていません。
\var{list}が2つ以上与えられ、長さの異なるリストがある場合、
{\cf for-each}は最も短いリストを使い切った時点で終了します。
\var{list}には循環リストも使えますが、すべてのリストが循環リストであった場合はエラーです。

\var{proc}がリストのいずれかを変更した場合はエラーです。


\begin{scheme}
(let ((v (make-vector 5)))
  (for-each (lambda (i)
              (vector-set! v i (* i i)))
            '(0 1 2 3 4))
  v)                                \ev  \#(0 1 4 9 16)%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{string-for-each}{ proc \vari{string} \varii{string} \dotsfoo}{手続き}}

\domain{\var{proc}が{\it string}の数と同じ数の引数を取らない場合はエラーです。}
{\cf string-\+for-\+each}の引数は{\cf string-\+map}の引数と同様ですが、
{\cf string-\+for-\+each}では値のためではなく副作用のために\var{proc}が呼ばれます。
{\cf string-\+map}と異なり、{\cf string-\+for-\+each}では
最初の要素から最後の要素まで順番通りに
\var{list}の要素に対して\var{proc}が呼ばれることが保証されています。
{\cf string-\+for-\+each}の戻り値は規定されていません。
\var{string}が2つ以上与えられ、長さの異なる文字列がある場合、
{\cf string-\+for-\+each}は最も短いリストを使い切った時点で終了します。
\var{proc}が文字列のいずれかを変更した場合はエラーです。

\begin{scheme}
(let ((v '()))
  (string-for-each
   (lambda (c) (set! v (cons (char->integer c) v)))
   "abcde")
  v)                         \ev  (101 100 99 98 97)%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{vector-for-each}{ proc \vari{vector} \varii{vector} \dotsfoo}{手続き}}

\domain{\var{proc}が{\it vector}の数と同じ数の引数を取らない場合はエラーです。}
{\cf vector-\+for-\+each}の引数は{\cf vector-\+map}の引数と同様ですが、
{\cf vector-\+for-\+each}では値のためではなく副作用のために\var{proc}が呼ばれます。
{\cf vector-\+map}と異なり、{\cf vector-\+for-\+each}では
最初の要素から最後の要素まで順番通りに
\var{vector}の要素に対して\var{proc}が呼ばれることが保証されています。
{\cf vector-\+for-\+each}の戻り値は規定されていません。
\var{vector}が2つ以上与えられ、長さの異なるベクタがある場合、
{\cf vector-\+for-\+each}は最も短いベクタを使い切った時点で終了します。
\var{proc}がベクタのいずれかを変更した場合はエラーです。

\begin{scheme}
(let ((v (make-list 5)))
  (vector-for-each
   (lambda (i) (list-set! v i (* i i)))
   '\#(0 1 2 3 4))
  v)                                \ev  (0 1 4 9 16)%
\end{scheme}

\end{entry}


\begin{entry}{%
\proto{call-with-current-continuation}{ proc}{手続き}
\proto{call/cc}{ proc}{手続き}}

\label{continuations}
\domain{\var{proc}が引数をひとつ取らない場合はエラーです。}
手続き{\cf call-with-current-continuation} (または同等の省略形{\cf call/cc}) 
は現在の継続(後述の論拠を参照)を「脱出手続き」\mainindex{脱出手続き}
としてパッケージ化し、それを引数として\var{proc}に渡します。
脱出手続きはSchemeの手続きで、後ほど呼ばれるとその時点での有効な継続を放棄し、
代わりに脱出手続き作成時点で有効であった継続を使用します。
脱出手続きを呼び出すと\ide{dynamic-wind}を用いてインストールされた
\var{before}サンクおよび\var{after}サンクが呼び出されます。

脱出手続きは\callcc{}の呼び出し元の継続と同じ数の引数を取ります。
ほとんどの継続は値をひとつだけ取ります。
{\cf call-\+with-\+values}手続き
({\cf define-\+values}、{\cf let-\+values}および{\cf let*-\+values}式の初期化式も含む)
によって作成された継続は、その消費者が期待している数の値を取ります。
{\cf lambda}、{\cf case-lambda}、{\cf begin}、
{\cf let}、{\cf let*}、{\cf letrec}、{\cf letrec*}、{\cf let-values}、
{\cf let*-values}、{\cf let-syntax}、{\cf letrec-syntax}、{\cf parameterize}、
{\cf guard}、{\cf case}、{\cf cond}、{\cf when}および{\cf unless}
式などにおける、式の並びの中にある最後でない式の継続はすべて、任意の数の値を取ります。
渡された値が何であれ破棄するだけだからです。
これらのいずれかの方法によって作成されたものでない継続にゼロ個の値を渡したり
2つ以上の値を渡した場合の効果は規定されていません。


\vest \var{proc}に渡される脱出手続きは
Schemeの他のどんな手続きとも同様に無制限の存続期間を持ちます。
変数やデータ構造に格納することができ、好きな回数だけ呼ぶことができます。
しかし{\cf raise}や{\cf error}手続き同様、呼び出し元に返ることはありません。

\vest 以下の例は{\cf call-with-current-continuation}の
最も単純な用途のみを示しています。
実際の用途がすべてこの例のように単純であれば
{\cf call-with-current-continuation}のような強力な手続きは必要ないでしょう。

\begin{scheme}
(call-with-current-continuation
  (lambda (exit)
    (for-each (lambda (x)
                (if (negative? x)
                    (exit x)))
              '(54 0 37 -3 245 19))
    \schtrue))                        \ev  -3

(define list-length
  (lambda (obj)
    (call-with-current-continuation
      (lambda (return)
        (letrec ((r
                  (lambda (obj)
                    (cond ((null? obj) 0)
                          ((pair? obj)
                           (+ (r (cdr obj)) 1))
                          (else (return \schfalse))))))
          (r obj))))))

(list-length '(1 2 3 4))            \ev  4

(list-length '(a b . c))            \ev  \schfalse%
\end{scheme}

\begin{rationale}

\vest {\cf call-with-current-continuation}の良く有る使い方は、
ループや手続き本体からの構造化された非局所的な脱出です。
しかし{\cf call-\+with-\+current-\+continuation}は
幅広い様々な高度な制御構造を実装する役に立ちます。
実際{\cf raise}および{\cf guard}は非局所的脱出のための
より構造化された仕組みです。

\vest Schemeの式が評価されるときは必ず
その結果を欲している\defining{継続}が存在しています。
継続はその計算の(デフォルトの)未来全体を表しています。
例えば式をREPLで評価する場合、その継続は、
結果を受け取り、それを画面に出力し、次の入力のためのプロンプトを表示し、
それを評価し、以下同様に永遠に繰り返すというものです。
ほとんどの場合、継続はユーザーコードによって指定されたアクションを含みます。
結果を受け取り、ある局所変数に格納された値をそれに掛け、7を加え、
そしてその答えを出力するためにREPLの継続に引き渡す、のような感じです。
通常これらの普遍的な継続は水面下に隠されており、
プログラマーはこれについて深く考えたりしません。
しかしプログラマーが明示的に継続を扱わなければならない状況も稀にあります。
{\cf call-\+with-\+current-\+continuation}手続きが
現在の継続として動作する手続きを作成することにより、
Schemeのプログラマーにはそれが可能となります。

% \vest Most programming languages incorporate one or more special-purpose
% escape constructs with names like {\tt exit}, \hbox{{\cf return}}, or
% even {\tt goto}.  In 1965, however, Peter Landin~\cite{Landin65}
% invented a general purpose escape operator called the J-operator.  John
% Reynolds~\cite{Reynolds72} described a simpler but equally powerful
% construct in 1972.  The {\cf catch} syntax described by Sussman
% and Steele in the 1975 report on Scheme is exactly the same as
% Reynolds's construct, though its name came from a less general construct
% in MacLisp.  Several Scheme implementers noticed that the full power of
% \ide{catch} could be provided by a procedure instead of by a
% special syntactic construct, and the name
% {\cf call-with-current-continuation} was coined in 1982.  This name is
% descriptive, but opinions differ on the merits of such a long name, and
% some people prefer the name \ide{call/cc} instead.
\todo{Shinn: Expand this history before restoring, possibly relegating to an appendix.}
\end{rationale}

%% \begin{note}
%% The {\cf call/cc} procedure is capable of capturing continuations
%% originating outside of Scheme when Scheme is embedded in some host
%% language. It is not always practical or even meaningful to restore
%% these continuations.
%% \end{note}
\todo{Shinn: I'm not sure we want to say anything about this.}

%% \begin{note}
%% The interactions of \callcc{} with {\cf dynamic-wind} are defined by
%% the formal semantics, but are hard to understand in complex cases.  In
%% addition, in some implementations \callcc{} consumes an amount of
%% memory that depends on the number of active continuations.
%% \end{note}
\end{entry}

\begin{entry}{%
\proto{values}{ obj $\ldots$}{手続き}}

引数をすべて継続に渡します。
{\tt values}手続きは以下のように定義することができます。
\begin{scheme}
(define (values . things)
  (call-with-current-continuation 
    (lambda (cont) (apply cont things))))%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{call-with-values}{ producer consumer}{手続き}}

\var{producer}が引数無しで呼ばれ、
その\var{producer}の呼び出し元の継続に値が渡されると、
その値を引数として\var{consumer}手続きが呼ばれます。
\var{consumer}の呼び出し元の継続は
{\tt call-with-values}の呼び出し元の継続です。

\begin{scheme}
(call-with-values (lambda () (values 4 5))
                  (lambda (a b) b))
                                                   \ev  5

(call-with-values * -)                             \ev  -1%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{dynamic-wind}{ before thunk after}{手続き}}

\var{thunk}が引数無しで呼ばれ、その呼び出しの結果を返します。
\var{before}および\var{after}も以下の規則に従って引数無しで呼ばれます。
ちなみに
\ide{call-with-current-continuation}を用いて捕捉された継続への呼び出しが無ければ、
3つの引数は順番にそれぞれ一度だけ呼ばれます。
\var{thunk}の呼び出しの動的存続期間に入るときは必ず\var{before}が呼ばれ、
その動的存続期間を出るときは必ず\var{after}が呼ばれます。
手続き呼び出しの動的存続期間とは、その呼び出しが開始されてから戻るまでの間の期間です。
\var{before}サンクおよび\var{after}サンクは
{\cf dynamic-wind}の呼び出し元と同じ動的環境で呼ばれます。
Schemeには{\cf call-with-current-continuation}が存在するため、
呼び出しの動的存続期間は連続した単一の時間でない場合があります。
これは以下のように定義されます。
\begin{itemize}
\item 呼ばれた手続きの本体の実行が開始されるとき、その動的存続期間に入ります。

\item 動的存続期間中に({\cf call-with-current-continuation}を用いて)
捕捉された継続をその動的存続期間外で呼んだときも
その動的存続期間に入ります。

\item 呼ばれた手続きから戻るとき、その動的存続期間から抜けます。

\item 動的存続期間外で捕捉された継続をその動的存続期間中に呼んだときも
その動的存続期間から抜けます。
\end{itemize}

\var{thunk}の呼び出しの動的存続期間中に
2回目の{\cf dynamic-wind}の呼び出しが発生し、
何らかの継続が呼び出されてこれら2回の{\cf dynamic-wind}呼び出しの\var{after}を
両方とも呼ぶべき状況になった場合は、
2回目の(内側の){\cf dynamic-wind}呼び出しに関連付けられている\var{after}が
先に呼ばれます。

\var{thunk}の呼び出しの動的存続期間中に
2回目の{\cf dynamic-wind}の呼び出しが発生し、
何らかの継続が呼び出されてこれら2回の{\cf dynamic-wind}呼び出しの\var{before}を
両方とも呼ぶべき状況になった場合は、
1回目の(外側の){\cf dynamic-wind}呼び出しに関連付けられている\var{before}が
先に呼ばれます。

継続が呼び出されたことにより、
ある{\cf dynamic-wind}呼び出しの\var{before}と
別の{\cf dynamic-wind}呼び出しの\var{after}を呼ぶ必要が生じた場合は、
\var{after}の方が先に呼ばれます。

\todo{consider removing unspecified effect}
捕捉した継続を用いて
\var{before}や\var{after}の呼び出しの動的存続期間を出入りした場合の効果は
規定されていません。

\begin{scheme}
(let ((path '())
      (c \#f))
  (let ((add (lambda (s)
               (set! path (cons s path)))))
    (dynamic-wind
      (lambda () (add 'connect))
      (lambda ()
        (add (call-with-current-continuation
               (lambda (c0)
                 (set! c c0)
                 'talk1))))
      (lambda () (add 'disconnect)))
    (if (< (length path) 4)
        (c 'talk2)
        (reverse path))))
    \lev (connect talk1 disconnect
               connect talk2 disconnect)%
\end{scheme}
\end{entry}

\section{例外}
\label{exceptionsection}

この節ではSchemeの例外処理および例外発生手続きについて述べます。
Schemeの例外の概念については\ref{errorsituations}~節を参照してください。
{\cf guard}構文については\ref{guard}も参照してください。

例外的な状況が通知されたときにプログラムが取るアクションを決める
手続きを\defining{例外ハンドラ}と呼びます。
例外ハンドラは引数をひとつ取ります。
システムは現在の例外ハンドラを動的環境で暗黙的に管理しています。

\index{現在の例外ハンドラ}
例外が発生すると現在の例外ハンドラが呼ばれ、
その例外に関する情報をカプセル化したオブジェクトが渡されます。
引数をひとつ取る手続きなら何でも例外ハンドラとして用いることができます。
また、どんなオブジェクトでも例外を表すために用いることができます。

\begin{entry}{%
\proto{with-exception-handler}{ \var{handler} \var{thunk}}{手続き}}

\domain{\var{handler}が引数をひとつ取らない場合はエラーです。
また\var{thunk}がゼロ個の引数を取らない場合もエラーです。}
{\cf with-exception-handler}手続きは\var{thunk}を呼び、その結果を返します。
\var{thunk}の呼び出しに対して使われる動的環境に
現在の例外ハンドラとして\var{handler}をインストールします。

\begin{scheme}
(call-with-current-continuation
 (lambda (k)
  (with-exception-handler
   (lambda (x)
    (display "condition: ")
    (write x)
    (newline)
    (k 'exception))
   (lambda ()
    (+ 1 (raise 'an-error))))))
        \ev exception
 \>{\em そして} condition: an-error {\em が出力される}

(with-exception-handler
 (lambda (x)
  (display "something went wrong\backwhack{}n"))
 (lambda ()
  (+ 1 (raise 'an-error))))
 \>{\em }  something went wrong {\em が出力される}%
\end{scheme}

2番目の例では、出力の後、別の例外が発生します。
\end{entry}

\begin{entry}{%
\proto{raise}{ \var{obj}}{手続き}}

例外を発生させ\var{obj}に対して現在の例外ハンドラを呼び出します。
ハンドラは{\cf raise}の呼び出し元と同じ動的環境で呼ばれます。
ただし現在の例外ハンドラは呼ばれるハンドラがインストールされたときのものになります。
ハンドラから戻った場合、そのハンドラと同じ動的環境で第二の例外が発生します。
\var{obj}とその第二の例外の関係は規定されていません。
\end{entry}

\begin{entry}{%
\proto{raise-continuable}{ \var{obj}}{手続き}}

例外を発生させ\var{obj}に対して現在の例外ハンドラを呼び出します。
ハンドラは{\cf raise-continuable}の呼び出し元と同じ動的環境で呼ばれます。
ただし
(1)現在の例外ハンドラは呼ばれるハンドラがインストールされたときのものになり、
(2)呼ばれたハンドラから戻った場合それが再び現在の例外ハンドラになります。
ハンドラから戻った場合、その戻り値が{\cf raise-continuable}の戻り値になります。
\end{entry}

\begin{scheme}
(with-exception-handler
  (lambda (con)
    (cond
      ((string? con)
       (display con))
      (else
       (display "a warning has been issued")))
    42)
  (lambda ()
    (+ (raise-continuable "should be a number")
       23)))
   {\it prints:} should be a number
   \ev 65%
\end{scheme}

\begin{entry}{%
\proto{error}{ \var{message} \var{obj} $\ldots$}{手続き}}

\domain{\var{message}は文字列であるべきです。}
\var{message}および\defining{イリタント}として知られる\var{obj}
によって与えられた情報をカプセル化した
処理系定義の新しく割り当てられたオブジェクトに対して
{\cf raise}を呼んだかのように例外を発生させます。
そのオブジェクトに対して手続き{\cf error-object?} を呼ぶと %
\schtrue{}を返さなければなりません。

\begin{scheme}
(define (null-list? l)
  (cond ((pair? l) \#f)
        ((null? l) \#t)
        (else
          (error
            "null-list?: argument out of domain"
            l))))%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{error-object?}{ obj}{手続き}}

\var{obj}が{\cf error}によって作成されたオブジェクトであれば \schtrue{}を返します。
何らかの処理系定義のオブジェクトに対して \schtrue{}を返す場合もあります。
そうでなければ \schfalse{}を返します。
エラーを通知するオブジェクトは、
述語{\cf file-error?} や{\cf read-error?} を満たすものも含め、
{\cf error-object?} を満たしても満たさなくても構いません。

\end{entry}

\begin{entry}{%
\proto{error-object-message}{ error-object}{手続き}}

\var{error-object}にカプセル化されているメッセージを返します。

\end{entry}

\begin{entry}{%
\proto{error-object-irritants}{ error-object}{手続き}}

\var{error-object}にカプセル化されているイリタントのリストを返します。

\end{entry}

\begin{entry}{%
\proto{read-error?}{ obj}{手続き}
\proto{file-error?}{ obj}{手続き}}

エラー型の述語です。
それぞれ\var{obj}が{\cf read}手続きによって発生した場合、
またはファイルの入出力ポートを開けなかったことによって発生した場合に %
\schtrue{}を返します。
そうでなければ \schfalse{}を返します。
% Not required to be an error object.

\end{entry}

\section{環境と評価}

\begin{entry}{%
\proto{environment}{ \vri{list} \dotsfoo}{evalライブラリの手続き}}
\label{environments}

この手続きは、空の環境を用意し、
そこに各\var{list}をインポートセットとみなしてインポートし、
その結果の環境の指定子を返します。
(インポートセットの説明は\ref{libraries}~節を参照。)
この指定子によって表された環境の束縛は環境自身と同様に不変です。

\end{entry}

\begin{entry}{%
\proto{scheme-report-environment}{ version}{r5rsライブラリの手続き}}

\var{version}が{\cf 5} (\rfivers{}に対応する) と等しければ、
\rfivers{}ライブラリで定義されている束縛のみを持つ環境の指定子を返します。
処理系はこの値の\var{version}をサポートしなければなりません。

処理系は他の値の\var{version}をサポートしても構いません。
その場合は指定されたバージョンの報告書に対応する束縛を持つ環境の指定子を返します。
\var{version}が{\cf 5}でなく、処理系がサポートしている他の値でもない場合は
エラーが通知されます。

\todo{consider removing unspecified effect}
{\cf scheme-report-environment}内で束縛されている識別子(例えば{\cf car})を
({\cf eval}の使用を通して)定義または代入した場合の効果は規定されていません。
すなわち環境とそこに含まれる束縛は両方とも不変であって構いません。

\end{entry}

\begin{entry}{%
\proto{null-environment}{ version}{r5rsライブラリの手続き}}

\var{version}が{\cf 5} (\rfivers{}に対応する) と等しければ、
\rfivers{}ライブラリで定義されているすべての構文キーワードの束縛のみを持つ
環境の指定子を返します。
処理系はこの値の\var{version}をサポートしなければなりません。

処理系は他の値の\var{version}をサポートしていても構いません。
その場合は指定されたバージョンの報告書に対応する適切な束縛を持つ環境の指定子を返します。
\var{version}が{\cf 5}でなく、処理系がサポートしている他の値でもない場合は、
エラーが通知されます。

{\cf scheme-report-environment}内で束縛されている識別子(例えば{\cf car})を
({\cf eval}の使用を通して)定義または代入した場合の効果は規定されていません。
すなわち環境とそこに含まれる束縛は、両方とも不変であっても構いません。

\end{entry}

\begin{entry}{%
\proto{interaction-environment}{}{replライブラリの手続き}}

この手続きは処理系定義の束縛の集合、
一般的には{\cf(scheme base)}からエクスポートされているもののスーパーセットを持つ
変更可能な環境の指定子を返します。
この手続きはユーザーがREPLに入力した式を評価する環境を返すことを意図しています。

\end{entry}

\begin{entry}{%
\proto{eval}{ expr-or-def environment-specifier}{evalライブラリの手続き}}

\var{expr-or-def}が式の場合、指定された環境でそれが評価され、その値が返されます。
定義の場合、指定された識別子が指定された環境で定義されます。
ただしその環境が不変でない場合に限ります。
処理系は{\cf eval}を拡張して他のオブジェクトを受け付けても構いません。

\begin{scheme}
(eval '(* 7 3) (environment '(scheme base)))
                                                   \ev  21

(let ((f (eval '(lambda (f x) (f x x))
               (null-environment 5))))
  (f + 10))
                                                   \ev  20
(eval '(define foo 32)
      (environment '(scheme base)))
                                                   \ev {\it{} エラーが通知される}%
\end{scheme}

\end{entry}

\section{入出力}

\subsection{ポート}
\label{portsection}

ポートは入出力機器を表します。
Schemeでは入力ポートは要求に応じてデータを供給するSchemeオブジェクトで、
出力ポートはデータを消費するSchemeオブジェクトです\mainindex{ポート}。
入力ポート型と出力ポート型が独立しているかどうかは処理系依存です。

{\em ポート型}によって操作するデータは異なります。
Schemeの処理系は{\em テキストポート}と{\em バイナリポート}を
サポートすることが要求されますが、他のポート型を提供していても構いません。

テキストポートは後述する{\cf read-char}および{\cf write-char}を用いた
文字ベースのバッキングストアに対する個々の文字の読み書きをサポートします。
また{\cf read}や{\cf write}といった
文字の観点で定義される操作もサポートします。

バイナリポートは後述する{\cf read-u8}および{\cf write-u8}を用いた
バイトベースのバッキングストアに対する個々のバイトの読み書きをサポートします。
またバイトの観点で定義される操作も同様にサポートします。
テキストポート型とバイナリポート型が独立しているかどうかは処理系依存です。

ポートはSchemeのプログラムを実行しているホストシステム上の
ファイルやデバイスなどにアクセスするために使うことができます。

\begin{entry}{%
\proto{call-with-port}{ port proc}{手続き}}

\domain{\var{proc}が引数をひとつ取らない場合はエラーです。}
{\cf call-with-port}手続きは\var{port}を引数として\var{proc}を呼びます。
\var{proc}から戻ると、そのポートは自動的に閉じられ、
\var{proc}の生成した値が返されます。
\var{proc}から戻らない場合、
そのポートが今後読み書き操作に使われることがないと保証できない限り、
自動的に閉じられてはなりません。

\begin{rationale}
Schemeの脱出手続きは無制限の存続期間を持つため、
現在の継続から脱出して後に再開することが可能です。
現在の継続から脱出した際にポートを閉じることを認めた場合、
{\cf call-\+with-\+current-\+continuation}と{\cf call-\+with-\+port}を両方用いた
移植性のあるコードを書くことが不可能になってしまいます。
\end{rationale} 

\end{entry}

\begin{entry}{%
\proto{call-with-input-file}{ string proc}{fileライブラリの手続き}
\proto{call-with-output-file}{ string proc}{fileライブラリの手続き}}

\domain{\var{proc}が引数をひとつ取らない場合はエラーです。}
これらの手続きは
{\cf open-input-file}または{\cf open-\+output-\+file}を用いたかのように
指定された名前のファイルを入力用または出力用に開き、テキストポートを取得します。
そしてそのポートと\var{proc}が{\cf call-\+with-\+port}と同等の手続きに渡されます。
\end{entry}

\begin{entry}{%
\proto{input-port?}{ obj}{手続き}
\proto{output-port?}{ obj}{手続き}
\proto{textual-port?}{ obj}{手続き}
\proto{binary-port?}{ obj}{手続き}
\proto{port?}{ obj}{手続き}}

これらの手続きは\var{obj}がそれぞれ入力ポートである、
出力ポートである、テキストポートである、バイナリポートである、
任意の種類のポートである場合に \schtrue{}を返します。
そうでなければ \schfalse{}を返します。

\end{entry}


\begin{entry}{%
\proto{input-port-open?}{ port}{手続き}
\proto{output-port-open?}{ port}{手続き}}

\var{port}がまだ開かれていて入出力が可能であれば %
\schtrue{}を返します。 そうでなければ \schfalse{}を返します。


\end{entry}


\begin{entry}{%
\proto{current-input-port}{}{手続き}
\proto{current-output-port}{}{手続き}
\proto{current-error-port}{}{手続き}}

それぞれ現在のデフォルトの入力ポート、出力ポート、
エラーポート(出力ポートの一種)を返します。
これらの手続きはパラメータオブジェクトであり、
{\cf parameterize} (\ref{make-parameter}~節を参照)でオーバーライドできます。
これらに対する束縛の初期値は処理系定義のテキストポートです。

\end{entry}


\begin{entry}{%
\proto{with-input-from-file}{ string thunk}{fileライブラリの手続き}
\proto{with-output-to-file}{ string thunk}{fileライブラリの手続き}}

{\cf open-input-file}または{\cf open-output-file}を用いたかのように
入力用または出力用にファイルが開かれ、
その新しいポートが
{\cf current-input-port}または{\cf current-output-port}
({\tt (read)}、{\tt (write \var{obj})}などでも使われます)
から返されるようにします。
その後\var{thunk}が引数無しで呼ばれます。
\var{thunk}が戻るとそのポートは閉じられ、以前のデフォルト値が復元されます。
\var{thunk}がゼロ個の引数を取らない場合はエラーです。
どちらの手続きでも\var{thunk}の生成した値が返されます。
脱出手続きを用いてこれらの手続きから脱出した場合、
現在の入出力ポートは
{\cf parameterize}で動的束縛されているかのように動作します。


\end{entry}


\begin{entry}{%
\proto{open-input-file}{ string}{fileライブラリの手続き}
\proto{open-binary-input-file}{ string}{fileライブラリの手続き}}
 
既存のファイルを表す\var{string}を取り、
そのファイルからデータを供給することができる
テキスト入力ポートまたはバイナリ入力ポートを返します。
そのファイルが存在しない、または開くことができなかった場合は、
{\cf file-error?} を満たすエラーが通知されます。

\end{entry}


\begin{entry}{%
\proto{open-output-file}{ string}{fileライブラリの手続き}
\proto{open-binary-output-file}{ string}{fileライブラリの手続き}}

作成される出力ファイルの名前となる\var{string}を取り、
その名前の新しいファイルにデータを書き出すことができる
テキスト出力ポートまたはバイナリ出力ポートを返します。
\todo{consider removing unspecified effect}
与えられた名前のファイルがすでに存在していた場合の効果は規定されていません。
ファイルを開くことができなかった場合は
{\cf file-error?} を満たすエラーが通知されます。

\end{entry}


\begin{entry}{%
\proto{close-port}{ port}{手続き}
\proto{close-input-port}{ port}{手続き}
\proto{close-output-port}{ port}{手続き}}

\var{port}に関連付けられているリソースを閉じ、
\var{port}を読み書きできないようにします。
最後の2つの手続きをそれぞれ入力ポートでないポート、
出力ポートでないポートに適用した場合はエラーです。
処理系はソケットのように
入力ポートであると同時に出力ポートでもあるような
ポートを提供していても構いません。
{\cf close-input-port}および{\cf close-output-port}手続きを使うと
そのようなポートの入力側と出力側を個別に閉じることができます。

ポートがすでに閉じられている場合、これらのルーチンは何の効果もありません。


\end{entry}

\begin{entry}{%
\proto{open-input-string}{ string}{手続き}}

文字列を取り、その文字列から文字を供給するテキスト入力ポートを返します。
その文字列が変更された場合の効果は規定されていません。

\end{entry}

\begin{entry}{%
\proto{open-output-string}{}{手続き}}

{\cf get-output-string}によって取得するために文字を蓄積する
テキスト出力ポートを返します。

\end{entry}

\begin{entry}{%
\proto{get-output-string}{ port}{手続き}}

\domain{\var{port}が{\cf open-output-string}を用いて作成した
ものでない場合はエラーです。}
それまでにポートに出力された文字から成る文字列を返します。
文字はそれらが出力された順番に格納されます。
結果の文字列が変更された場合の効果は規定されていません。

\begin{scheme}
(parameterize
    ((current-output-port
      (open-output-string)))
    (display "piece")
    (display " by piece ")
    (display "by piece.")
    (newline)
    (get-output-string (current-output-port)))
\lev "piece by piece by piece.\backwhack{}n"%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{open-input-bytevector}{ bytevector}{手続き}}

バイトベクタを取り、そのバイトベクタからバイトを供給する
バイナリ入力ポートを返します。

\end{entry}

\begin{entry}{%
\proto{open-output-bytevector}{}{手続き}}

{\cf get-output-bytevector}で取得するためにバイトを蓄積する
バイナリ出力ポートを返します。

\end{entry}

\begin{entry}{%
\proto{get-output-bytevector}{ port}{手続き}}

\domain{\var{port}が{\cf open-output-bytevector}を用いて作成した
ものでない場合はエラーです。}
それまでにポートに出力されたバイトから成るバイトベクタを返します。
バイトはそれらが出力された順番に格納されます。
\end{entry}


\subsection{入力}
\label{inputsection}

入力手続きで\var{port}が省略された場合は
{\cf (current-\+input-\+port)}の戻り値がデフォルト値となります。
閉じられたポートに対して入力操作を試みることはエラーです。

\noindent \hbox{ }  %???
\vspace{-5ex}


\begin{entry}{%
\proto{read}{}{readライブラリの手続き}
\rproto{read}{ port}{readライブラリの手続き}}

{\cf read}手続きはSchemeのオブジェクトの外部表現をそのオブジェクト自身に変換します。
つまりこれは
非終端記号 \meta{datum} (\ref{datum}~節および\ref{listsection}~節を参照)
のパーサーです。
与えられたテキスト入力ポート\var{port}からパース可能な次のオブジェクトを返し、
そのオブジェクトの外部表現が終わった次の文字を指すよう\var{port}を更新します。

処理系はデータム表現を持たないレコード型や他の型を表現するために
構文を拡張しても構いません。

\vest オブジェクトの始まりとなる文字が見つかる前に入力がファイルの終端に達した場合は
end-of-fileオブジェクトが返されます。
ポートは開いたまま維持され、
さらに読み取りを試みると再びend-of-fileオブジェクトが返されます。
オブジェクトの外部表現が始まった後で、
しかし外部表現が不完全なためパース不可能な状態でファイルの終端に達した場合は、
{\cf read-error?} を満たすエラーが通知されます。

\end{entry}

\begin{entry}{%
\proto{read-char}{}{手続き}
\rproto{read-char}{ port}{手続き}}

テキスト入力ポート\var{port}から利用可能な次の文字を返し、
その次の文字を指すよう\var{port}を更新します。
それ以上文字が無い場合はend-of-fileオブジェクトが返されます。

\end{entry}


\begin{entry}{%
\proto{peek-char}{}{手続き}
\rproto{peek-char}{ port}{手続き}}

テキスト入力ポート\var{port}から利用可能な次の文字を返しますが、
その次の文字を指すよう\var{port}を更新{\em しません}。
それ以上文字が無い場合はend-of-fileオブジェクトが返されます。

\begin{note}
{\cf peek-char}の呼び出しから返される値は
同じ\var{port}に対して{\cf read-char}を呼んだときに返される値と同じです。
ただし
その次その\var{port}に対して{\cf read-char}または{\cf peek-char}を呼んだとき
先に呼んだ{\cf peek-char}から返された値を返す点だけが異なります。
ちなみに対話的なポートに対する{\cf read-char}の呼び出しが
入力待ちのために停止するような状況では
{\cf peek-char}の呼び出しも同様に停止します。
\end{note}

\end{entry}

\begin{entry}{%
\proto{read-line}{}{手続き}
\rproto{read-line}{ port}{手続き}}

テキスト入力ポート\var{port}から利用可能な次の行のテキストを返し、
その後の文字を指すよう\var{port}を更新します。
行末を読み取った場合は、その行末までのテキストをすべて含む
(ただし行末自体は含まない) 文字列が返され、
その行末の直後を指すようポートを更新します。
行末を読み取る前にファイルの終端に達したが、
文字をいくつか読み取った場合は、
その文字を含む文字列が返されます。
いかなる文字も読み取ることなくファイルの終端に達した場合は、
end-of-fileオブジェクトが返されます。
この手続きにおいて行末とは
改行文字、復帰文字、または復帰文字に続く改行文字の並びのいずれかです。
処理系は他の行末文字や行末文字の並びを認識しても構いません。

\end{entry}


\begin{entry}{%
\proto{eof-object?}{ obj}{手続き}}

\var{obj}がend-of-fileオブジェクトであれば \schtrue{}を返し、
そうでなければ \schfalse{}を返します。
end-of-fileオブジェクトの正確な集合は処理系によって異なりますが、
いかなる場合でも{\cf read}によって読み取られる可能性のあるオブジェクトが
end-of-fileオブジェクトとなることはありません。

\end{entry}

\begin{entry}{%
\proto{eof-object}{}{手続き}}

end-of-fileオブジェクトを返します。
end-of-fileオブジェクトは唯一であるとは限りません。

\end{entry}


\begin{entry}{%
\proto{char-ready?}{}{手続き}
\rproto{char-ready?}{ port}{手続き}}

テキスト入力ポート\var{port}において文字の準備ができた状態であれば %
\schtrue{}を返し、そうでなければ \schfalse{}を返します。
{\cf char-ready}が \schtrue{}を返した場合は
その\var{port}に対する次の{\cf read-char}が停止しないことが保証されています。
\var{port}がファイルの終端に達している場合は \schtrue{}を返します。

\begin{rationale}
{\cf char-ready?} 手続きは
入力待ちによって停止してしまうことなく対話的なポートから文字を受け取れるようにするために
存在しています。
そういったポートにIMEが紐付いている場合は
{\cf char-ready?} によって存在が明らかになった文字が
入力から削除されることがないよう保証しなければなりません。
仮に{\cf char-ready?} がファイルの終端で \schfalse{}を返した場合、
ファイルの終端に達したポートとまだ文字が準備できていない対話的なポートを
区別することはできないでしょう。
\end{rationale}
\end{entry}

\begin{entry}{%
\proto{read-string}{ k}{手続き}
\rproto{read-string}{ k port}{手続き}}
\label{readstring}

テキスト入力ポート\var{port}から次の\var{k}個の文字
またはファイルの終端までに有る限りの文字を読み取り、
新しく割り当てられた文字列に左から右の順で格納し、
その文字列を返します。
ファイルの終端までに利用可能な文字が無い場合は
end-of-fileオブジェクトが返されます。

\end{entry}


\begin{entry}{%
\proto{read-u8}{}{手続き}
\rproto{read-u8}{ port}{手続き}}

バイナリ入力ポート\var{port}から利用可能な次のバイトを返し、
その次のバイトを指すよう\var{port}を更新します。
それ以上バイトが無い場合はend-of-fileオブジェクトが返されます。

\end{entry}

\begin{entry}{%
\proto{peek-u8}{}{手続き}
\rproto{peek-u8}{ port}{手続き}}

バイナリ入力ポート\var{port}から利用可能な次のバイトを返しますが、
その次のバイトを指すよう\var{port}を更新{\em しません}。
それ以上バイトが無い場合はend-of-fileオブジェクトが返されます。

\end{entry}

\begin{entry}{%
\proto{u8-ready?}{}{手続き}
\rproto{u8-ready?}{ port}{手続き}}


バイナリ入力ポート\var{port}においてバイトの準備ができた状態であれば %
\schtrue{}を返し、そうでなければ \schfalse{}を返します。
{\cf u8-ready}が \schtrue{}を返した場合は
その\var{port}に対する次の{\cf read-u8}が停止しないことが保証されています。
\var{port}がファイルの終端に達している場合は \schtrue{}を返します。

\end{entry}

\begin{entry}{%
\proto{read-bytevector}{ k}{手続き}
\rproto{read-bytevector}{ k port}{手続き}}

バイナリ入力ポート\var{port}から次の\var{k}個のバイト
またはファイルの終端までに有る限りのバイトを読み取り、
新しく割り当てられたバイトベクタに左から右の順で格納し、
そのバイトベクタを返します。
ファイルの終端までに利用可能なバイトが無い場合は
end-of-fileオブジェクトが返されます。

\end{entry}

\begin{entry}{%
\proto{read-bytevector!}{ bytevector}{手続き}
\rproto{read-bytevector!}{ bytevector port}{手続き}
\rproto{read-bytevector!}{ bytevector port start}{手続き}
\rproto{read-bytevector!}{ bytevector port start end}{手続き}}

バイナリ入力ポート\var{port}から次の $end - start$ 個のバイト、
またはファイルの終端までに有る限りのバイトを読み取り、
\var{bytevector}の\var{start}から始まる位置に左から右の順で格納します。
\var{end}が指定されなかった場合は
\var{bytevector}の終わりに達するまで読み取られます。
\var{start}が指定されなかった場合は0から始まる位置に読み取られます。
読み取ったバイト数を返します。
バイトが無い場合はend-of-fileオブジェクトが返されます。

\end{entry}


\subsection{出力}
\label{outputsection}

出力手続きで\var{port}が省略された場合は
{\cf (current-\+output-\+port)}の戻り値がデフォルト値となります。
閉じられたポートに対して出力操作を試みることはエラーです。

\noindent \hbox{}
\vspace{-5ex}

\begin{entry}{%
\proto{write}{ obj}{writeライブラリの手続き}
\rproto{write}{ obj port}{writeライブラリの手続き}}

与えられたテキスト出力ポート\var{port}に\var{obj}の表現を書き出します。
書き出される表現内では文字列は引用符で囲まれ、
文字列中のバックスラッシュおよび引用符はバックスラッシュでエスケープされます。
非ASCII文字を含むシンボルは垂直線でエスケープされます。
文字オブジェクトは {\cf \#\backwhack} 記法で書き出されます。

\var{obj}が循環構造を持ち、通常の書き出される表現では無限ループが発生する場合は、
少なくともその循環部分を形成するオブジェクトは
\ref{labelsection}~節で説明されているデータムラベルを用いて表現されなければなりません。
循環構造が無い場合はデータムラベルを用いてはなりません。

処理系はデータム表現を持たないレコード型や他の型を表現するために
構文を拡張しても構いません。

{\cf write}手続きの戻り値は規定されていません。

\end{entry}

\begin{entry}{%
\proto{write-shared}{ obj}{writeライブラリの手続き}
\rproto{write-shared}{ obj port}{writeライブラリの手続き}}

{\cf write-shared}手続きは{\cf write}と同じですが、
出力中に2回以上現れるすべてのペアおよびベクタに対して
その共有構造をデータムラベルで表現しなければなりません。

\end{entry}

\begin{entry}{%
\proto{write-simple}{ obj}{writeライブラリの手続き}
\rproto{write-simple}{ obj port}{writeライブラリの手続き}}

{\cf write-simple}手続きは{\cf write}と同じですが、
データムラベルで共有構造を表現することはありません。
このため、\var{obj}が循環構造を持っていると
{\cf write-simple}は終了しません。

\end{entry}


\begin{entry}{%
\proto{display}{ obj}{writeライブラリの手続き}
\rproto{display}{ obj port}{writeライブラリの手続き}}

与えられたテキスト出力ポート\var{port}に\var{obj}の表現を書き出します。
書き出される表現内に現れる文字列は
{\cf write}の代わりに{\cf write-string}を用いたかのように出力されます。
シンボルはエスケープされません。
表現内に現れる文字は{\cf write}の代わりに
{\cf write-char}を用いたかのように出力されます。

それ以外のオブジェクトに対する{\cf display}の表現は規定されていません。
しかし自己参照ペア、ベクタ、レコードに対して
{\cf display}が無限ループしてはなりません。
そのため、通常の{\cf write}の表現が使われる場合、
{\cf write}同様に循環を表現するためデータムラベルが必要です。

処理系はデータム表現を持たないレコード型や他の型を表現するために
構文を拡張しても構いません。

{\cf display}手続きの戻り値は規定されていません。

\begin{rationale}
{\cf write}は機械処理用の出力を生成し、
{\cf display}は人間が読める出力を生成する意図があります。
\end{rationale}
\end{entry}


\begin{entry}{%
\proto{newline}{}{手続き}
\rproto{newline}{ port}{手続き}}

テキスト出力ポート\var{port}に行末を書き出します。
これがどのように為されるかはオペレーティングシステムによって異なります。
戻り値は規定されていません。

\end{entry}


\begin{entry}{%
\proto{write-char}{ char}{手続き}
\rproto{write-char}{ char port}{手続き}}

与えられたテキスト出力ポート\var{port}に文字\var{char}を書き出します
(その文字の外部表現ではありません)。
戻り値は規定されていません。

\end{entry}

\begin{entry}{%
\proto{write-string}{ string}{手続き}
\rproto{write-string}{ string port}{手続き}
\rproto{write-string}{ string port start}{手続き}
\rproto{write-string}{ string port start end}{手続き}}

テキスト出力ポート\var{port}に
\var{string}の\var{start}〜\var{end}の文字を
左から右の順で書き出します。

\end{entry}

\begin{entry}{%
\proto{write-u8}{ byte}{手続き}
\rproto{write-u8}{ byte port}{手続き}}

与えられたバイナリ出力ポート\var{port}に\var{byte}を書き出します。
戻り値は規定されていません。

\end{entry}

\begin{entry}{%
\proto{write-bytevector}{ bytevector}{手続き}
\rproto{write-bytevector}{ bytevector port}{手続き}
\rproto{write-bytevector}{ bytevector port start}{手続き}
\rproto{write-bytevector}{ bytevector port start end}{手続き}}

バイナリ出力ポート\var{port}に
\var{bytevector}の\var{start}〜\var{end}のバイトを
左から右の順で書き出します。

\end{entry}

\begin{entry}{%
\proto{flush-output-port}{}{手続き}
\rproto{flush-output-port}{ port}{手続き}}

バッファリングされているすべての出力を
出力ポートのバッファから基礎となるファイルまたはデバイスにフラッシュします。
戻り値は規定されていません。

\end{entry}


\section{システムインタフェース}

一般的に言って、システムインタフェースの問題はこの報告書の対称範囲外です。
しかし以下の操作は重要であり、ここで述べるだけの価値があります。


\begin{entry}{%
\proto{load}{ filename}{loadライブラリの手続き}
\rproto{load}{ filename environment-specifier}{loadライブラリの手続き}}

\domain{\var{filename}が文字列でなければエラーです。}
\var{filename}は処理系依存の方法により
Schemeのソースコードを持つ既存のファイルの名前に変換されます。
{\cf load}手続きはそのファイルから式と定義を読み取り、
\var{environment-specifier}で指定された環境でそれらを逐次的に評価します。
\var{environment-specifier}が省略された場合は
{\cf (interaction-environment)}が想定されます。

式の結果がプリントされるか否かは規定されていません。
{\cf load}手続きは
{\cf current-\+input-\+port}や{\cf current-\+output-\+port}の戻り値に影響を与えません。
{\cf load}手続きの戻り値は規定されていません。


\begin{rationale}
移植性のため{\cf load}はソースファイルに対して動作しなければなりません。
他の種類のファイルに対する動作は処理系によって様々です。
\end{rationale}
\end{entry}

\begin{entry}{%
\proto{file-exists?}{ filename}{fileライブラリの手続き}}

\domain{\var{filename}が文字列でなければエラーです。}
{\cf file-exists?} 手続きはその名前のファイルが
手続きが呼ばれた時点で存在していれば \schtrue{}を返し、
そうでなければ \schfalse{}を返します。

\end{entry}

\begin{entry}{%
\proto{delete-file}{ filename}{fileライブラリの手続き}}

\domain{\var{filename}が文字列でなければエラーです。}
{\cf delete-file}手続きは、
その名前のファイルが存在していて削除可能であれば、それを削除します。
戻り値は規定されていません。
そのファイルが存在しないか、削除可能でなければ、
{\cf file-error?} を満たすエラーが通知されます。

\end{entry}

\begin{entry}{%
\proto{command-line}{}{process-contextライブラリの手続き}}

プロセスに渡されたコマンドラインを文字列のリストとして返します。
最初の文字列はコマンド名に対応していますが、具体的な内容は処理系依存です。
これらの文字列のいずれかを変更することはエラーです。
\end{entry}

\begin{entry}{%
\proto{exit}{}{process-contextライブラリの手続き}
\rproto{exit}{ obj}{process-contextライブラリの手続き}}

保留中のdynamic-windの\var{after}手続きをすべて実行し、
実行中のプログラムを終了し、
オペレーテイングシステムに終了値を伝えます。
引数が指定されていない場合、または\var{obj}が \schtrue{}の場合は
プログラムが正常終了した旨がオペレーティングシステムに伝えられます。
\var{obj}が \schfalse{}の場合は
プログラムが異常終了した旨がオペレーティングシステムに伝えられます。
それ以外の場合は\var{obj}が
そのオペレーティングシステム用の適切な終了値に変換されます(可能であれば)。

{\cf exit}手続きは例外を通知したり
その継続に戻ってはなりません。

\begin{note}
ハンドラを実行するという要求のため、
この手続きは単なるオペレーティングシステムの終了手続きではありません。
\end{note}

\end{entry}

\begin{entry}{%
\proto{emergency-exit}{}{process-contextライブラリの手続き}
\rproto{emergency-exit}{ obj}{process-contextライブラリの手続き}}

保留中のdynamic-windの\var{after}手続きを実行せずに
プログラムを終了し、
{\cf exit}と同様の方法でオペレーティングシステムに終了値を伝えます。

\begin{note}
{\cf emergency-exit}手続きは
WindowsやPosixにおける {\cf \_exit}手続きに対応しています。
\end{note}

\end{entry}


\todo{Shinn: Do we need any description of what an environment variable is?}

\begin{entry}{%
\proto{get-environment-variable}{ name}{process-contextライブラリの手続き}}

多くのオペレーティングシステムでは
実行中の各プロセスに\defining{環境変数}から成る\defining{環境}があります。
(この環境を{\cf eval}に渡せるSchemeの環境と混同しないようにしてください。
\ref{environments}~節を参照。)
環境変数の名前と値は両方とも文字列です。
手続き{\cf get-environment-variable}は
環境変数\var{name}の値を返します。
その名前の環境変数が無ければ \schfalse{}を返します。
環境変数の名前をエンコードしたり値をデコードするために
ロケール情報が用いられる場合があります。
{\cf get-\+environment-\+variable}が値をデコードできない場合はエラーです。
結果の文字列を変更することもエラーです。

\begin{scheme}
(get-environment-variable "PATH") \lev "/usr/local/bin:/usr/bin:/bin"%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{get-environment-variables}{}{process-contextライブラリの手続き}}

すべての環境変数の名前と値を連想リストとして返します。
各エントリのcarが名前、cdrが値で、両方とも文字列です。
リストの順番は規定されていません。
これらの文字列や連想リスト自体を変更することはエラーです。

\begin{scheme}
(get-environment-variables) \lev (("USER" . "root") ("HOME" . "/"))%
\end{scheme}

\end{entry}

\begin{entry}{%
\proto{current-second}{}{timeライブラリの手続き}}

国際原子時(TAI)を基準とした現在の時刻を表す不正確な数値を返します。
値0.0がTAIにおける1970年1月1日の真夜中 (世界時の真夜中の10秒前と同等)
を表し、値1.0がその1 TAI秒後を表します。
正確さや精度の高さは要求されません。
協定世界時に適切な定数を加えて返す程度しかできなくても構いません。
\end{entry}

\begin{entry}{%
\proto{current-jiffy}{}{timeライブラリの手続き}}

処理系定義の適切な基点から経過した
\defining{jiffy}の数を正確な整数として返します。
jiffyは1秒を処理系定義の数で割った時間の単位で、
{\cf jiffies-per-second}手続きの戻り値によって定義されます。
始まりの基点はプログラムを実行している間は一定であることが保証されていますが、
実行のたびに変わっても構いません。

\begin{rationale}
{\cf current-jiffy}を最小のオーバーヘッドで実行できるようにするため、
jiffyは処理系依存であることが認められています。
コンパクトな表現の整数で十分に戻り値を表せるようなものであるべきです。
固定のjiffyではどのように選んでも処理系によっては不適切なサイズとなるでしょう。
非常に速いマシンにおいてはマイクロ秒は長すぎますし、
一方で非常に小さな単位を用いると処理系によってはほとんどの場合に記憶領域の割り当てが必要となり、
精密な時間計測の手段としては有用性が低下してしまいます。
\end{rationale}

\end{entry}

\begin{entry}{%
\proto{jiffies-per-second}{}{timeライブラリの手続き}}

1 SI秒あたりのjiffyの数を表す正確な整数を返します。
この値は処理系固有の定数です。

\begin{scheme}
(define (time-length)
  (let ((list (make-list 100000))
        (start (current-jiffy)))
    (length list)
    (/ (- (current-jiffy) start)
       (jiffies-per-second))))%
\end{scheme}
\end{entry}

\begin{entry}{%
\proto{features}{}{手続き}}

{\cf cond-expand}が真とみなす機能識別子のリストを返します。
このリストを変更することはエラーです。
{\cf features}が返すリストの例を以下に挙げます。

\begin{scheme}
(features) \ev
  (r7rs ratios exact-complex full-unicode
   gnu-linux little-endian 
   fantastic-scheme
   fantastic-scheme-1.0
   space-ship-control-system)%
\end{scheme}
\end{entry}

