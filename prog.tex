\chapter{プログラムの構造}
\label{programchapter}

\section{Programs}

Schemeのプログラムはひとつ以上のインポート宣言に続く式および定義の並びで構成されます。
インポート宣言はプログラムまたはライブラリが依存するライブラリを指定します。
ライブラリがエクスポートしている識別子のサブセットがプログラムで利用可能となります。
式は\ref{expressionchapter}~章で説明しています。
定義は変数定義、構文定義、レコード型定義のいずれかで、これらはすべてこの章で説明します。
これらは、式を書ける場所のうちいくつかの部分(すべてではない)で、
特に\hyper{program}の最も外側のレベルおよび\hyper{body}の最初の部分で、書くことが出来ます。
\mainindex{definition}

プログラムの最も外側のレベルでは、
{\tt(begin \hyperi{expression or definition} \dotsfoo)}は
その\ide{begin}の中の式および定義の並びと等価です。
同様に、\hyper{body}では、
{\tt(begin \hyperi{definition} \dotsfoo)}は
\hyperi{definition} \dotsfoo の並びと等価です。
マクロはそのような{\cf begin}の形に展開されることがあります。
正式な定義は\ref{sequencing}~を参照してください。

インポート宣言および定義は、大域環境に束縛を作成し、または既存の大域束縛の値を変更します。
プログラムの初期状態の環境は空です。
そのため、最初の束縛を導入するために少なくともひとつのインポート宣言が必要です。

プログラムの最も外側のレベルに現れる式は束縛を作成しません。
これらはプログラムが呼び出されたとき、またはロードされたとき、順番に実行され、
通常、何らかの種類の初期化を行います。


プログラムおよびライブラリは、通常、ファイルに格納されています。
処理系によっては実行中のSchemeシステムに対話的に入力できる場合もあります。
他の方式も有り得ます。
ライブラリをファイルに格納している処理系は、
ライブラリの名前からファイルシステム中の場所への対応付けを文章化するべきです。

\section{インポート宣言}
\mainschindex{import}

インポート宣言は以下の形を取ります。
\begin{scheme}
(import \hyper{import-set} \dotsfoo)
\end{scheme}

インポート宣言はライブラリからエクスポートされている識別子をインポートする方法を提供します。
それぞれの\hyper{import set}はライブラリからインポートされる束縛の集合の名前を指定し、
またそのインポートした束縛に局所的な名前を指定することも出来ます。
以下の形のいずれかを取ります。

\begin{itemize}
\item {\tt\hyper{library name}}
\item {\tt(only \hyper{import set} \hyper{identifier} \dotsfoo)}
\item {\tt(except \hyper{import set} \hyper{identifier} \dotsfoo)}
\item {\tt(prefix \hyper{import set} \hyper{identifier})}
\item {\tt(rename \hyper{import set}\\
{\obeyspaces%
\hspace*{4em}(\hyperi{identifier} \hyperii{identifier}) \dotsfoo)}}
\end{itemize}

最初の形では、その名前のライブラリのexport節に記載されているすべての識別子を同じ名前で
(\ide{rename}でエクスポートされている場合はそのエクスポート名で)
インポートします。
追加の形の\hyper{import set}はこの集合を以下のように修正します。

\begin{itemize}

\item \ide{only}は指定された\hyper{import set}のうち、
指定された識別子 (もしあれば名前変更後の) のみを含む部分集合を生成します。

\item \ide{except}は指定された\hyper{import set}から、
指定された識別子 (もしあれば名前変更後の) を除いた部分集合を生成します。
指定された識別子のいずれかが元の集合に見つからない場合はエラーです。

\item \ide{rename}は指定された\hyper{import set}を変更し、
\hyperi{identifier}を\hyperii{identifier}に置換します。
指定された\hyperi{identifier}のいずれかが元の集合に見つからない場合はエラーです。

\item \ide{prefix}は指定された\hyper{import set}のすべての識別子を改名し、
指定された\hyper{identifier}をその先頭に付けます。

\end{itemize}

プログラムおよびライブラリ宣言では、
同じ識別子を異なる束縛でインポートしたり、
インポートした束縛を定義で再定義したり、{\cf set!}で変更したり、
識別子をインポートする前にそれを参照することはエラーです。
しかしREPLではそのような動作は許容されるべきです。

\section{変数定義}
\label{defines}
\mainindex{variable definition}

変数定義はひとつ以上の識別子を束縛し、その初期値を指定します。
最も単純な種類の変数定義は以下のいずれかの形を取ります。\mainschindex{define}

\begin{itemize}

\item{\tt(define \hyper{variable} \hyper{expression})}

\item{\tt(define (\hyper{variable} \hyper{formals}) \hyper{body})}

\hyper{formals}は、ゼロ個以上の変数の並びであるか、
ひとつ以上の変数にスペースで区切られたピリオドともうひとつ別の変数が続いたものです
(lambda式と同様です)。
この形は以下と等価です。
\begin{scheme}
(define \hyper{variable}
  (lambda (\hyper{formals}) \hyper{body}))\rm.%
\end{scheme}

\item{\tt(define (\hyper{variable} .\ \hyper{formal}) \hyper{body})}

\hyper{formal}は単一の変数です。
この形は以下と等価です。
\begin{scheme}
(define \hyper{variable}
  (lambda \hyper{formal} \hyper{body}))\rm.%
\end{scheme}

\end{itemize}

\subsection{最上位の定義}

プログラムの最も外側のレベルでは、
以下のような定義
\begin{scheme}
(define \hyper{variable} \hyper{expression})%
\end{scheme}
は、\hyper{variable}がすでに構文以外の値に束縛されている場合、
実質的に以下の代入式と同じ効果を持ちます。
\begin{scheme}
(\ide{set!}\ \hyper{variable} \hyper{expression})%
\end{scheme}
ただし、\hyper{variable}が束縛されていないか、構文キーワードである場合、
上記の定義は代入を行う前に\hyper{variable}を新しい場所に束縛します。
それに対し{\cf set!}は束縛されていない\index{unbound}変数に対して行うとエラーです。

\begin{scheme}
(define add3
  (lambda (x) (+ x 3)))
(add3 3)                            \ev  6
(define first car)
(first '(1 2))                      \ev  1%
\end{scheme}

\subsection{内部定義}
\label{internaldefines}

定義は、\hyper{body}の最初に書くことも出来ます。
\hyper{body}は、\ide{lambda},
\ide{let}, \ide{let*}, \ide{letrec}, \ide{letrec*},
\ide{let-values}, \ide{let*-values}, \ide{let-syntax}, \ide{letrec-syntax},
\ide{parameterize}, \ide{guard}, または \ide{case-lambda} の本体です。
このような本体は、他の構文の展開後まで現れない場合があることに注意してください。
そのような定義は、前述の大域定義に対して{\em 内部定義}\mainindex{internal definition}と呼ばれます。
内部定義で定義された変数はその\hyper{body}に局所的です。
つまり、\hyper{variable}は代入されるのではなく束縛され、
\hyper{body}全体をその束縛の有効範囲とします。
以下に例を示します。

\begin{scheme}
(let ((x 5))
  (define foo (lambda (y) (bar x y)))
  (define bar (lambda (a b) (+ (* a b) a)))
  (foo (+ x 3)))                \ev  45%
\end{scheme}

内部定義を持つ\hyper{body}の展開形は
完全に等価な{\cf letrec*}式に常に変換出来ます。
例えば、上の例の{\cf let}式は以下と等価です。

\begin{scheme}
(let ((x 5))
  (letrec* ((foo (lambda (y) (bar x y)))
            (bar (lambda (a b) (+ (* a b) a))))
    (foo (+ x 3))))%
\end{scheme}

この等価な{\cf letrec*}式と同様に、
\hyper{body}で定義されたそれぞれの内部定義の\hyper{expression}は
対応する\hyper{variable}および\hyper{body}内の後続する\hyper{variable}に
代入も参照もせず評価できなければならず、
そうでなければエラーです。

同じ\hyper{body}で同じ識別子を2回以上定義した場合はエラーです。

内部定義を書ける場所では常に、
{\tt(begin \hyperi{definition} \dotsfoo)}
はその\ide{begin}の本体を形成する定義の並びと等価です。

\subsection{多値の定義}

もうひとつの種類の定義は{\cf define-values}です。
複数の値を返すひとつの式から複数の定義を作成します。
{\cf define}が書ける場所ならどこでも書くことが出来ます。

\begin{entry}{%
\proto{define-values}{ \hyper{formals} \hyper{expression}}{\exprtype}}\nobreak

\hyper{formals}の集合に同じ変数が2回以上現れた場合はエラーです。

\semantics
\hyper{expression}が評価され、その戻り値が、
{\cf lambda}式が手続き呼び出しで引数を\hyper{formals}にマッチさせるのと同じ方法で、
\hyper{formals}に束縛されます。

\begin{scheme}
(define-values (x y) (integer-sqrt 17))
(list x y) \ev (4 1)

(let ()
  (define-values (x y) (values 1 2))
  (+ x y))     \ev 3%
\end{scheme}

\end{entry}

\section{構文定義}

\mainindex{syntax definition}
構文定義は以下の形を取ります。\mainschindex{define-syntax}

{\tt(define-syntax \hyper{keyword} \hyper{transformer spec})}

\hyper{keyword}は識別子で、
\hyper{transformer spec}は\ide{syntax-rules}です。
変数定義と同様、
構文定義は最も外側のレベルか\ide{body}内のネストしたレベルに書くことが出来ます。

{\cf define-syntax}が最も外側のレベルに現れた場合、
その\hyper{keyword}に指定された変換器を束縛することによって大域構文環境が拡張されますが、
\hyper{keyword}の大域束縛を用いたすでに展開済みのものはそのまま残ります。
そうでない場合、それは\defining{内部構文定義}であり、
それが定義された\hyper{body}に局所的なものとなります。
対応する定義の前に構文キーワードが使用された場合はエラーです。
特に、内部定義に先行する使用に外側の定義を適用することは出来ません。

\begin{scheme}
(let ((x 1) (y 2))
  (define-syntax swap!
    (syntax-rules ()
      ((swap! a b)
       (let ((tmp a))
         (set! a b)
         (set! b tmp)))))
  (swap! x y)
  (list x y))                \ev (2 1)%
\end{scheme}

\todo{Shinn: This description is hideous.
Cowan: But now less hideous than before.}

マクロは定義が許される文脈では定義に展開することが出来ます。
しかし、その定義自身や同じグループの内部定義に属する先行する定義の意味を決めるために
束縛が既知である必要のある識別子を定義する定義はエラーです。
同様に、
それが属する本体中の内部定義と式の境界線を決めるために既知である必要のある
識別子を定義する内部定義もエラーです。
例えば、以下の例はエラーです。

\begin{scheme}
(define define 3)

(begin (define begin list))

(let-syntax
    ((foo (syntax-rules ()
            ((foo (proc args ...) body ...)
             (define proc
               (lambda (args ...)
                 body ...))))))
  (let ((x 3))
    (foo (plus x y) (+ x y))
    (define foo x)
    (plus foo x)))%
\end{scheme}

\section{レコード型定義}
\label{usertypes}

\defining{レコード型定義}は
\defining{レコード型}と呼ばれる新しいデータ型を定義するために使われます。
他の定義と同様に、最も外側のレベルか本体内で使うことが出来ます。
レコード型の値は\defining{レコード}と呼ばれます。
レコードはゼロ個以上の\defining{フィールド}の集合体です。
それぞれのフィールドはひとつずつ場所を持ちます。
それぞれのレコード型に対して
述語、構築手続き、フィールド参照手続き、フィールド変更手続きが定義されます。

\begin{entry}{%
\mainschindex{define-record-type}
\pproto{(define-record-type \hyper{name}}{syntax}
\hspace*{4em}{\tt \hyper{constructor} \hyper{pred} \hyper{field} \dotsfoo})}

\syntax
\hyper{name}および\hyper{pred}は識別子です。
\hyper{constructor}は以下の形を取ります。
\begin{scheme}
(\hyper{constructor name} \hyper{field name} \dotsfoo)%
\end{scheme}
それぞれの\hyper{field}は以下の形のいずれかを取ります。
\begin{scheme}
(\hyper{field name} \hyper{accessor name})%

(\hyper{field name} \hyper{accessor name} \hyper{modifier name})%
\end{scheme}

フィールド名として同じ識別子が2回以上現れた場合はエラーです。
参照手続きまたは変更手続きの名前として同じ識別子が2回以上現れた場合もエラーです。

{\cf define-record-type}構文は生成的です。
Schemeの定義済みの型や他のレコード型、同じ名前や同じ構造を持つレコード型も含め、
すでに存在するどんな型とも異なる独立した新しいレコード型が、使用するたびに作られます。


{\cf define-record-type}の使用は以下の定義と同等です。

\begin{itemize}

\item \hyper{name}はレコード型それ自身の表現に束縛されます。
これは実行時オブジェクトの場合もあれば、純粋に構文的な表現の場合もあります。
この表現はこの報告書では使用されませんが、
更なる言語の拡張の際に使うためにそのレコード型を識別するためのものとして提供されます。

\item \hyper{constructor name}は、
\texttt{(\hyper{constructor name} \dotsfoo)}部分式内の
\hyper{field name}と同じ個数だけの引数を取り型\hyper{name}の新しいレコードを返す
手続きに束縛されます。
\hyper{constructor name}と共に名前が指定されたフィールドは、
対応する引数をその初期値として持ちます。
それ以外のすべてのフィールドの初期値は規定されていません。
\hyper{field name}に無いフィールド名が\hyper{constructor}内に現れた場合はエラーです。

\item \hyper{pred}は、
\hyper{constructor name}に束縛された手続きが返した値を指定すると\schtrue{}を返し、
それ以外のすべてに対して\schfalse{}を返す述語に束縛されます。

\item それぞれの\hyper{accessor name}は、
型\hyper{name}のレコードを取り対応するフィールドの現在の値を返す手続きに束縛されます。
適切な型のレコードでない値を参照手続きに渡した場合はエラーです。

\item それぞれの\hyper{modifier name}は、
型\hyper{name}のレコードと対応するフィールドの新しい値を取る手続きに束縛されます。
戻り値は規定されていません。
適切な型のレコードでない値を変更手続きの第1引数に渡した場合はエラーです。

\end{itemize}

例えば、以下のレコード型定義は

\begin{scheme}
(define-record-type <pare>
  (kons x y)
  pare?
  (x kar set-kar!)
  (y kdr))
\end{scheme}

{\cf <pare>}のインスタンスに対して
{\cf kons}を構築手続き、
{\cf kar}および{\cf kdr}を参照手続き、
{\cf set-kar!}を変更手続き、
{\cf pare?}を述語として定義します。

\begin{scheme}
  (pare? (kons 1 2))        \ev \schtrue
  (pare? (cons 1 2))        \ev \schfalse
  (kar (kons 1 2))          \ev 1
  (kdr (kons 1 2))          \ev 2
  (let ((k (kons 1 2)))
    (set-kar! k 3)
    (kar k))                \ev 3
\end{scheme}

\end{entry}


\section{ライブラリ}
\label{libraries}

ライブラリはSchemeのプログラムを、
プログラムの他の部分への明示的に定義されたインタフェースを持った
再利用可能な部品に編成する手段です。
この節ではライブラリの記法と意味論を定義します。


\subsection{ライブラリの構文}

ライブラリ定義は以下の形を取ります。
\mainschindex{define-library}

\begin{scheme}
(define-library \hyper{library name}
  \hyper{library declaration} \dotsfoo)
\end{scheme}

\hyper{library name}は識別子および正確な非負の整数を内容とするリストです。
これは他のプログラムやライブラリからインポートする際にそのライブラリを唯一に識別するために使われます。
最初の識別子が{\cf scheme}であるライブラリは、この報告書および報告書の将来のバージョンで使用するために予約されています。
最初の識別子が{\cf srfi}であるライブラリは Scheme Requests for Implementation を実装するライブラリ用に予約されています。
文字 {\cf | \backwhack{} ? * < " : > + [ ] /}
および制御文字(エスケープ展開後)を含むような識別子をライブラリ名に使用することは勧められませんが、
エラーではありません。

\label{librarydeclarations}
\hyper{library declaration}は以下のいずれかの形を取ります。

\begin{itemize}

\item{\tt(export \hyper{export spec} \dotsfoo)}

\item{\tt(import \hyper{import set} \dotsfoo)}

\item{\tt(begin \hyper{command or definition} \dotsfoo)}

\item{\tt(include \hyperi{filename} \hyperii{filename} \dotsfoo)}

\item{\tt(include-ci \hyperi{filename} \hyperii{filename} \dotsfoo)}

\item{\tt(include-library-declarations \hyperi{filename} \hyperii{filename} \dotsfoo)}

\item{\tt(cond-expand \hyperi{ce-clause} \hyperii{ce-clause} \dotsfoo)}

\end{itemize}

\ide{export}宣言は、他のライブラリまたはプログラムに見せる識別子のリストを指定します。
\hyper{export spec}は以下の形のいずれかを取ります。

\begin{itemize}
\item{\hyper{identifier}}
\item{\tt{(rename \hyperi{identifier} \hyperii{identifier})}}
\end{itemize}

\hyper{export spec}では、\hyper{identifier}が
そのライブラリで定義されたかそのライブラリにインポートされた束縛のひとつに名前を付けます。
ただしそのエクスポートする外部名はそのライブラリ内の束縛の名前と同じです。
\ide{rename}指定は、
それぞれの{\tt(\hyperi{identifier} \hyperii{identifier})}ペアについて、
そのライブラリ内で定義されたかそのライブラリにインポートされた
\hyperi{identifier}という名前の束縛を、
\hyperii{identifier}という外部名でエクスポートします。

\ide{import}宣言は他のライブラリからエクスポートされた識別子をインポートする手段です。
これはプログラムやREPLで使われるインポート宣言と同じ構文と意味論を持ちます(\ref{import}~節を参照)。

\ide{begin}、\ide{include}および\ide{include-ci}宣言はライブラリの本体を指定するために使われます。
これらは対応する形式と同じ構文と意味論を持ちます。
{\cf begin}は\ref{sequencing}~節で定義されている2種類の{\cf begin}に似ていますが、
同じではありません。

\ide{include-library-declarations}宣言は
\ide{include}と似ていますが、ファイルの内容を現在のライブラリ定義内に直接継ぎ合わせる
点が異なります。
これは例えば、同じ形のライブラリインタフェースを持つ複数のライブラリで
同じ\ide{export}宣言を共有するために使うことができます。

\ide{cond-expand}宣言は\ide{cond-expand}形式と同じ構文と意味論を持ちますが、
式が{\cf begin}で囲まれるのではなくライブラリ宣言に継ぎ合わされる点が異なります、

\todo{Shinn: Perhaps make this a separate subsection describing a
  library ``resolution'' phase which runs prior to library expansion.}

ライブラリの実装方法のひとつとして以下のような方式が考えられるでしょう。
まず、すべての\ide{cond-expand}ライブラリ宣言を展開します。
そして、すべてのインポートした束縛から成る、そのライブラリ用の新しい環境を構築します。
それから、\ide{begin}、\ide{include}および\ide{include-ci}ライブラリ宣言によるすべての式を
その環境でそのライブラリ内に現れた順番で展開します。
あるいは、
それぞれの\ide{import}宣言によってインポートされた束縛を追加するたびに環境を成長させながら、
左から右の順番で他の宣言の処理と一緒に
\ide{cond-expand}および\ide{import}宣言を処理していっても構いません。

ライブラリがロードされるとき、その式が書かれた順番で実行されます。
そのライブラリ宣言の定義がプログラムまたはライブラリ本体の展開済みの形から参照される場合、
そのライブラリは展開されたプログラムまたはライブラリ本体が評価される前にロードされなければなりません。
このルールは推移的です。
あるライブラリが2つ以上のプログラムまたはライブラリからインポートされている場合、
そのライブラリはその回数ロードされる可能性がある場合があります。

同様に、あるライブラリ{\cf (foo)}の展開中に、
そのライブラリを展開するために他のライブラリ{\cf (bar)}からインポートした構文キーワードが必要な場合、
{\cf (foo)}の展開前に、ライブラリ{\cf (bar)}が展開されその構文定義が評価されなければなりません。

ライブラリがロードされる回数に関わらず、
ライブラリから束縛をインポートするそれぞれのプログラムまたはライブラリは、
インポート宣言が現れた数に関わらず、単一のライブラリロードからそれらの束縛をインポートしなければなりません。
つまり、{\cf (import (only (foo) a))}に{\cf (import (only (foo) b))}が続いたものは、
{\cf (import (only (foo) a b))}と同じ効果を持ちます。

\subsection{ライブラリの例}
プログラムをどのように、ライブラリと比較的小さなメインプログラムに分割するかを、以下の例に示します~\cite{life}。
メインプログラムをREPLに入力する場合は、baseライブラリをインポートする必要はありません。

\begin{scheme}
(define-library (example grid)
  (export make rows cols ref each
          (rename put! set!))
  (import (scheme base))
  (begin
    ;; Create an NxM grid.
    (define (make n m)
      (let ((grid (make-vector n)))
        (do ((i 0 (+ i 1)))
            ((= i n) grid)
          (let ((v (make-vector m \sharpfalse{})))
            (vector-set! grid i v)))))
    (define (rows grid)
      (vector-length grid))
    (define (cols grid)
      (vector-length (vector-ref grid 0)))
    ;; Return \sharpfalse{} if out of range.
    (define (ref grid n m)
      (and (< -1 n (rows grid))
           (< -1 m (cols grid))
           (vector-ref (vector-ref grid n) m)))
    (define (put! grid n m v)
      (vector-set! (vector-ref grid n) m v))
    (define (each grid proc)
      (do ((j 0 (+ j 1)))
          ((= j (rows grid)))
        (do ((k 0 (+ k 1)))
            ((= k (cols grid)))
          (proc j k (ref grid j k)))))))

(define-library (example life)
  (export life)
  (import (except (scheme base) set!)
          (scheme write)
          (example grid))
  (begin
    (define (life-count grid i j)
      (define (count i j)
        (if (ref grid i j) 1 0))
      (+ (count (- i 1) (- j 1))
         (count (- i 1) j)
         (count (- i 1) (+ j 1))
         (count i (- j 1))
         (count i (+ j 1))
         (count (+ i 1) (- j 1))
         (count (+ i 1) j)
         (count (+ i 1) (+ j 1))))
    (define (life-alive? grid i j)
      (case (life-count grid i j)
        ((3) \sharptrue{})
        ((2) (ref grid i j))
        (else \sharpfalse{})))
    (define (life-print grid)
      (display "\backwhack{}x1B;[1H\backwhack{}x1B;[J")  ; clear vt100
      (each grid
       (lambda (i j v)
         (display (if v "*" " "))
         (when (= j (- (cols grid) 1))
           (newline)))))
    (define (life grid iterations)
      (do ((i 0 (+ i 1))
           (grid0 grid grid1)
           (grid1 (make (rows grid) (cols grid))
                  grid0))
          ((= i iterations))
        (each grid0
         (lambda (j k v)
           (let ((a (life-alive? grid0 j k)))
             (set! grid1 j k a))))
        (life-print grid1)))))

;; Main program.
(import (scheme base)
        (only (example life) life)
        (rename (prefix (example grid) grid-)
                (grid-make make-grid)))

;; Initialize a grid with a glider.
(define grid (make-grid 24 24))
(grid-set! grid 1 1 \sharptrue{})
(grid-set! grid 2 2 \sharptrue{})
(grid-set! grid 3 0 \sharptrue{})
(grid-set! grid 3 1 \sharptrue{})
(grid-set! grid 3 2 \sharptrue{})

;; Run for 80 iterations.
(life grid 80)

\end{scheme}

\section{REPL}

処理系によっては \defining{REPL} (Read-Eval-Print Loop) と呼ばれる対話環境を用意している場合があります。
インポート宣言、式、定義を、一度にひとつずつ入力し評価することが出来る環境です。
利便性と使用の容易さのため、REPLにおけるSchemeの大域環境は、空であってはなりません。
少なくともbaseライブラリに用意されている束縛を持った状態で開始しなければなりません。
このライブラリはSchemeの中核となる構文と、データを操作する一般的に便利な手続きが含まれています。
例えば、変数{\cf abs}は引数をひとつ取り数値の絶対値を計算する手続きに束縛されており、
変数{\cf +}は合計を計算する手続きに束縛されています。
(scheme base)の束縛の完全なリストは
付録~\ref{stdlibraries}に掲載されています。

処理系は、すべての有り得る変数が場所に束縛され、ほとんどの場所が規定されていない値を持っているかのように動作する
初期状態のREPL環境を用意していても構いません。
そのような処理系では、最上位のREPLの定義は真に代入と等価です。
ただし、その識別子が構文キーワードとして定義されている場合を除きます。

処理系はファイルから入力を読み込むREPLの動作モードを用意していても構いません。
そういったファイルは、開始以外の場所にインポート宣言を持つことができ、
一般的にプログラムと同じではありません。
