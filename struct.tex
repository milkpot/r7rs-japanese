% 1. Structure of the language

\chapter{Schemeの概要}

\section{意味論}
\label{semanticsection}

この節ではSchemeの意味論の概要を述べます。
非公式の詳細な意味論は\ref{basicchapter}~章から\ref{builtinchapter}~章で述べます。
リファレンス目的のため
\ref{formalsemanticssection}~節にSchemeの正式な意味論を掲載しています。

\vest Schemeは静的なスコープを持つプログラミング言語です。
変数の各使用はその変数の字句的に明らかな束縛に紐付けられます。

\vest Schemeは動的な型を持つ言語です。
型は変数ではなく値(オブジェクト\mainindex{object}と呼ばれることもあります)に紐付けられます。
反対に静的な型を持つ言語では、型は値だけでなく変数や式にも紐付けられます。

\vest Schemeの計算中に作成されるすべてのオブジェクトは無制限の存続期間を持ちます。
手続きや継続もそれに含まれます。
Schemeのオブジェクトは破棄されることはありません。
Schemeの処理系が(通常は!)記憶領域を使い切ることが無いのは、
あるオブジェクトが将来のいかなる計算にも影響を与える可能性がないと保証できる場合に
そのオブジェクトが占有している記憶領域を回収することができるためです。

\vest Scheme処理系は真正末尾再帰であることが要求されます。
これにより繰り返し計算が構文的には再帰手続きとして記述されていても、
その繰り返し計算を一定の空間内で実行することが可能になります。
処理系が真正末尾再帰であることにより
通常の手続き呼び出しを用いて繰り返しを表現することができます。
そのため特殊な繰り返し構文は構文糖衣としての価値しかありません。
\ref{proper tail recursion}節を参照してください。

\vest Schemeの手続きは独立したオブジェクトです。
手続きは動的に作成したり、データ構造に格納したり、
手続きの結果として返したりすることができます。

\vest Scheme特有の機能のひとつに第一級の地位を持つ継続があります。
これは他のほとんどの言語では水面下にしか存在しないものです。
継続を利用することで非局所脱出、バックトラッキング、コルーチンなど、
幅広い様々な高度な制御構造を実装できます。
\ref{continuations}~節を参照してください。

\vest Schemeの手続きの引数は常に値渡しです。
つまり実引数の式は手続きが制御を得る前に
必要とされるか否かに関わらず評価されます。

\vest Schemeの数値計算モデルは
コンピュータ内における特定の数値表現方式になるべく依存しないよう設計されています。
Schemeではすべての整数は有理数であり、すべての有理数は実数であり、
すべての実数は複素数であります。
そのため多くのプログラミング言語では整数と実数の違いが非常に重要ですが、
Schemeではそうではありません。
Schemeでそれに当たるものは正確な数値計算と不正確な数値計算の違いになります。
正確な数値計算は数学における理想的な数値計算に対応するもので、
不正確な数値計算は近似値によるものです。
正確な数値計算は整数に限定されるものではありません。

\section{構文}

Schemeは他のLisp方言と同様、完全に括弧で囲った前置記法を採用しており、
これでプログラムやその他のデータを記述します。
データに対してはSchemeの文法の部分言語が用いられます。
Schemeのプログラムで他のSchemeのプログラムやデータを簡単に統一的に扱うことができる、
というのがこのシンプルで統一された表現の重要なポイントです。
例えば{\cf eval}手続きを用いて、データとして表現されたSchemeのプログラムを評価できます。

{\cf read}手続きは読み込んだデータを字句的に分解すると共に構文的にも分解します。
{\cf read}手続きは入力をプログラムではなくデータ(\ref{datumsyntax}~節)として
パースします。

Schemeの正式な構文は\ref{BNF}~節に掲載されています。


\section{記法および用語}


\subsection{基本的な機能と選択的な機能}
\label{qualifiers}

この報告書で定義されているすべての識別子は
ひとつ以上の\defining{ライブラリ}の中に現れます。
\defining{baseライブラリ}で定義されている識別子は
この報告書の本文では特別な印は付いていません。
このライブラリにはSchemeの中核となる構文と
データを操作する一般的に便利な手続きが含まれています。
例えば変数{\cf abs}は引数をひとつ取り数値の絶対値を計算する手続きに束縛されており、
変数 {\cf +} は和を計算する手続きに束縛されています。
すべての標準ライブラリとそこからエクスポートされている識別子の完全なリストは
付録~\ref{stdlibraries}に掲載されています。

すべてのScheme処理系は:
\begin{itemize}

\item baseライブラリとそこからエクスポートされているすべての識別子を
提供しなければなりません。

\item この報告書に記載されているそれ以外のライブラリは提供しても省いても構いません。
ただしそれぞれのライブラリは
完全に提供するか完全に省くかのいずれかでなければなりません。
余計な識別子を追加することも認められません。

\item この報告書に記載されていない他のライブラリを提供しても構いません。

\item この報告書に記載されている任意の識別子の機能を拡張しても構いません。
ただしその拡張はこの報告書の言語と矛盾していてはいけません。

\item 移植性のあるコードをサポートするために、
この報告書に記載されている字句構文と矛盾しない字句構文を使用するモードを
提供しなければなりません。
\end{itemize}

\subsection{エラー状態と未規定の動作}
\label{errorsituations}

\mainindex{error}
エラー状態について述べるとき、
この報告書では「エラーが通知されます」という用語を用いて、
処理系がエラーを検出し、報告しなければならないことを示します。
エラーは\ref{exceptionsection}~節に記載されている手続き{\cf raise}
を呼び出したかのように、継続不可能な例外が発生することにより通知されます。
発生するオブジェクトは処理系依存です。
以前に同じ用途で使われたオブジェクトと独立している必要はありません。
この報告書に記載されている場面でエラーが通知される以外に、
独自のエラーを通知させたり、通知されたエラーを処理したりすることもできます。

「{\em 述語}を満たすエラーが通知されます」という用語も
上で述べたようなエラーの通知を意味しますが、それに加え
通知されたオブジェクトが指定された述語({\cf file-error?} または{\cf read-error?})
に渡されると、その述語が \schtrue{} を返します。

\vest エラーに関する議論でそのような語句が現れない場合、
処理系がエラーを検出したり報告することは推奨されますが要求されません。
そのような状況では常にではありませんが「エラーです」という用語が使われます。
そのような状況では処理系はエラーを通知しても通知しなくても構いません。
エラーを通知する場合、通知されるオブジェクトは述語
{\cf error-object?}、{\cf file-error?}、{\cf read-error?} 
を満たしても満たさなくても構いません。
それらの代わりに移植性の無い拡張を提供しても構いません。

例えば、
定義域エラーがこの報告書で言及されていない場合でも、
扱えると明示的に規定されていない型の引数を手続きに渡すことはエラーです。
処理系はエラーを通知しても構いませんし、
手続きの定義域を拡張してそのような引数を扱えるようにしても構いませんし、
何らかの破滅的な結果を引き起こしても構いません。

\vest 処理系が課す何らかの制限のために、
正しいプログラムの実行を続けることができない、という状況がありえます。
そのような状況を示すときには「処理系の制限の違反を報告しても構いません」という用語が使われます。
そのような状況では処理系はその旨を報告しても構いません。
処理系の制限は無いことが望ましいですが、
処理系は制限の違反\mainindex{implementation restriction}を報告することが推奨されます。

\vest 例えばプログラムを実行するのに十分な記憶領域がない場合、
あるいは数値計算の結果がその処理系では表現できないほど大きい正確な数値の場合、
処理系は処理系の制限の違反を報告しても構いません。

\vest 式の値が「規定されていません」と述べられている場合、
その式の結果はエラーを通知することなく何らかのオブジェクトに評価されなければなりませんが、
その値は処理系依存です。
この報告書ではどのような値が返されるか明示的に述べません。\mainindex{unspecified}

\vest 最後に、
「しなければなりません」、
「してはなりません」、
「するべきです」、
「するべきではありません」、
「しても構いません」、
「要求されます」、
「推奨されます」、
「オプショナルな」
といった語句や用語は
RFC~2119~\cite{rfc2119}で述べられているように解釈されるものとします。
これらはプログラマやプログラムの動作についてのリファレンスではなく、
処理系の作成者や処理系の動作のためのリファレンスとしてのみ用いられるものです。



\subsection{項目の書式}

\ref{expressionchapter}~章および\ref{builtinchapter}~章は項目に編成されています。
それぞれの項目はひとつの言語機能または関連する機能のグループについて記述されています。
それぞれの機能は構文または手続きのどちらかです。
項目はひとつ以上の見出し行の形で始まります。

\noindent\pproto{\var{template}}{\var{category}}\unpenalty

この場合はbaseライブラリの識別子です。

\noindent\pproto{\var{template}}{\var{name}ライブラリの\var{category}}\unpenalty

この\var{name}は付録~\ref{stdlibraries}で定義されているライブラリの短縮名です。

\var{category}が「\exprtype」の場合、その項目は式型について記述しており、
\var{template}はその式型の構文を表しています。
式の各部分は構文変数で示されています。
構文変数は山括弧を用いて書かれています。
例えば\hyper{expression}や\hyper{variable}などです。
構文変数の意図はプログラムテキストの部分を表すことです。
例えば\hyper{expression}は構文的に有効な式となる任意の文字の列を表しています。
\begin{tabbing}
\qquad \hyperi{thing} $\ldots$
\end{tabbing}
この記法はゼロ個以上の\hyper{thing}を表します。
\begin{tabbing}
\qquad \hyperi{thing} \hyperii{thing} $\ldots$
\end{tabbing}
この記法は1個以上の\hyper{thing}を表します。

\var{category}が「補助構文」の場合、
その項目は特定の式の一部にのみ現れる構文束縛について記述しています。
独立した構文として使用したり変数として使用することはエラーです。

\var{category}が「手続き」の場合、その項目は手続きについて記述しており、
見出し行はその手続きを呼び出すためのテンプレートを表しています。
テンプレート内の引数名は\var{斜体}で示されています。

\noindent\pproto{(vector-ref \var{vector} \var{k})}{手続き}\unpenalty

この見出し行は{\tt vector-ref}変数に束縛されている手続きが2つの引数、
ベクタ\var{vector}および正確な負でない整数\var{k}を取ることを表しています
(下記参照)。

\noindent%
\pproto{(make-vector \var{k})}{手続き}
\pproto{(make-vector \var{k} \var{fill})}{手続き}\unpenalty

この見出し行は
{\tt make-vector}手続きが1つまたは2つの引数を取るように
定義されていなければならないことを表しています。

\label{typeconventions}
扱えると規定されていない引数に手続きを適用することはエラーです。
正確性を保つため以下の規約に従うものとします。
引数の名前が\ref{disjointness}~節の一覧にある型名の場合、
その引数がその名前の型でなければエラーです。
例えば前述の{\tt vector-ref}の見出し行は
{\tt vector-ref}の第1引数がベクタでなければならないことを表しています。
また以下の命名規約も型の制限を暗黙に示します。
\newcommand{\foo}[1]{\vr{#1}, \vri{#1}, $\ldots$ \vrj{#1}, $\ldots$}
$$
\begin{tabular}{ll}
\vr{alist}&連想リスト(ペアのリスト)\\
\vr{boolean}&ブーリアン値(\schtrue{}または \schfalse{})\\
\vr{byte}&0以上256未満の正確な整数\\
\vr{bytevector}&バイトベクタ\\
\vr{char}&文字\\
\vr{end}&正確な非負の整数\\
\foo{k}&正確な非負の整数\\
\vr{letter}&アルファベットの文字\\
\foo{list}&リスト(\ref{listsection}~節を参照)\\
\foo{n}&整数\\
\var{obj}&任意のオブジェクト\\
\vr{pair}&ペア\\
\vr{port}&ポート\\
\vr{proc}&手続き\\
\foo{q}&有理数\\
\vr{start}&正確な非負の整数\\
\vr{string}&文字列\\
\vr{symbol}&シンボル\\
\vr{thunk}&引数を取らない手続き\\
\vr{vector}&ベクタ\\
\foo{x}&実数\\
\foo{y}&実数\\
\foo{z}&複素数\\
\end{tabular}
$$

文字列、ベクタ、バイトベクタのインデックスとして
\vr{start}および\vr{end}という名前が使われることがあります。
これは以下の事柄を暗黙に示しています。

\begin{itemize}

\item{\var{start}が\var{end}より大きい場合はエラーです。}

\item{\var{end}がその文字列、ベクタ、バイトベクタの長さより大きい場合はエラーです。}

\item{\var{start}が省略された場合、ゼロであるとみなされます。}

\item{\var{end}が省略された場合、その文字列、ベクタ、バイトベクタの長さであるとみなされます。}

\item{インデックス\var{start}は常に含まれ、インデックス\var{end}は常に含まれません。
文字列を例に取ると、
\var{start}と\var{end}が等しい場合は空文字列を表し、
\var{start}がゼロで\var{end}が文字列の長さと等しい場合はその文字列全体を表します。}

\end{itemize}

\subsection{評価の例}

プログラムの例で使われている「\evalsto」は「〜に評価される」と解釈します。
例えば

\begin{scheme}
(* 5 8)      \ev  40%
\end{scheme}

上記の例は式 {\tt(* 5 8)} がオブジェクト{\tt 40}に評価されるという意味です。
あるいはより正確に言うと
文字の並び ``{\tt(* 5 8)}'' で表される式は初期状態の環境では
文字の並び ``{\tt 40}'' で表すことのできるオブジェクトに評価されるということです。
オブジェクトの外部表現についての議論は\ref{externalreps}~節を参照してください。

\subsection{命名規約}

規約では、必ずブーリアン値を返す手続きの名前は最後の文字が \ide{?} です。
そういった手続きは\defining{述語}と呼ばれます。
一般的に述語には副作用が無いというのが暗黙の了解です。
ただし間違った型の引数を渡したときに例外が発生することはあります。

同様に、すでに割り当て済みの場所(\ref{storagemodel}~節を参照)
に値を代入する手続きの名前は最後の文字が \ide{!} です。
そういった手続きは\defining{変更手続き}と呼ばれます。
変更手続きの戻り値は規定されていません。

規約では、ある型のオブジェクトを受け取り別な型の似たオブジェクトを返す手続きは
名前の間に ``\ide{->}'' が入ります。
例えば{\cf list->vector}はリストを受け取り、そのリストと同じ要素を持つベクタを返します。

役に立つ値を返さない手続きは\defining{コマンド}と呼ばれます。
	
引数を受け取らない手続きは\defining{サンク}と呼ばれます。
